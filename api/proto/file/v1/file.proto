syntax ="proto3";
package file.v1;
option go_package="github.com/iansmith/parigot/g/file/v1;file";
import "protosupport/v1/protosupport.proto";
import "google/protobuf/timestamp.proto";


// This is the File service for parigot.  It is sandboxed such that caller to this service
// has limited access to files. The caller can expect that "/app" is a directory in which new
// files can be created and existing files can be found.  
// 
// Paths must be UTF-8 encoded with no control characters, without leading -, without . or ..
// elements, and without carriage returns or newlines.
//
// This api provides no synchronous interface to reading or writing file content.  The caller will
// be handed an Id upon successfully starting a read or write.  That Id can be used later to 
// query the status of the read or write and it is expected that this will be driven by the *end user*,
// such as a user on the internet with a web browser.


service File {
  // Open handles the READ-only operation on a file
  rpc Open(OpenRequest) returns (OpenResponse);

  // Create handles the WRITE-only operation on a file. It creates or truncates the name file
  // in the path. If the file already exists, it is truncated. If the file does not exist, it is created.
  rpc Create(CreateRequest) returns (CreateResponse);

  // Close changes the status of a file to "close"
  rpc Close(CloseRequest) returns (CloseResponse);

  // Load does NOT check that the file(s) referred to are reasonable in length, do not contain
  // symlinks, are readable, etc.  Don't allow this call in prod.
  rpc LoadTestData(LoadTestDataRequest) returns (LoadTestDataResponse);

  rpc Read(ReadRequest) returns (ReadResponse);

  rpc Write(WriteRequest) returns (WriteResponse);

  // Delete free a file from memory (datacache) or delete it from the disk
  rpc Delete(DeleteRequest) returns (DeleteResponse);
}


message CreateRequest {
  string path  = 1;
  string content = 2;
}

message OpenRequest {
  string path  = 1;
}

message CloseRequest {
  protosupport.v1.IdRaw id = 1;
}

message CreateResponse {
  string path = 1;
  protosupport.v1.IdRaw id = 2;
  bool truncated = 3;
}

message OpenResponse {
  string path = 1;
  protosupport.v1.IdRaw id = 2;
}

// CloseResponse is not empty because it can return an error. However, there is no
// action that the receiver of this response can take other than perhaps issuing a warning
// to the system operators.
message CloseResponse {
  protosupport.v1.IdRaw id = 1;
}

// LoadTestDataRequest loads the contents of given directory from the _host_ file system into the /app directory
// of the test filesystem (in memory).   This is only intended to be use for test code.
message LoadTestDataRequest {
  // path is a path to a directory on the _host_ filesystem that is to be loaded in /app
  string dir_path = 1;
  // where this new file will exist in the in-memory filesystem... this path
  // will be cleaned lexically and then joined to /app.  Note that it is possible
  // create paths with this parameter that cannot be opened because of
  // restrictions on the path in open.
  string mount_location = 2;
  // returnOnFail should be set to true if you do NOT want the normal behavior of using panic on error.
  // If this value is set to true, the paths that cause an error on import are return in the TestDataResponse.
  bool return_on_fail = 3;
}

// LoadTestDataResponse contains a list of paths that caused an error during loading. This value is only
// returned if the LoadRequest has the returnOnFail set to true.  If LoadDataRequest.return_on_fail is
// false since by definition the error_path will be empty.
message LoadTestDataResponse {
  repeated string error_path = 1;
}

message ReadRequest {
  protosupport.v1.IdRaw id = 1;
  // Reads up to len(buf) bytes into buf
  bytes buf = 2;
}

message ReadResponse {
  protosupport.v1.IdRaw id = 1;
  // The number of bytes read (0 <= num_read <= len(buf))
  int32 num_read = 2;
}

message WriteRequest {
  protosupport.v1.IdRaw id = 1;
  // Writes len(buf) bytes from buf
  bytes buf = 2;
}

message WriteResponse {
  protosupport.v1.IdRaw id = 1;
  // The number of bytes written from buf (0 <= num_write <= len(buf)) 
  int32 num_write = 2;
}

message DeleteRequest {
  string path = 1;
}

message DeleteResponse {
  string path = 1;
  protosupport.v1.IdRaw id = 2;
}

// StatRequest asks for the information about a file
message StatRequest {
  string path = 1;
}


// Define the FileInfo struct
message FileInfo {
  string path = 1;
  bool is_dir = 3;
  int32 size = 4;
  google.protobuf.Timestamp create_time = 5; // creation time
  google.protobuf.Timestamp mod_time = 6; // modification time
}

// Use the FileInfo struct in the StatResponse message
message StatResponse {
  FileInfo file_info = 1;
}

enum FileErr {
  option (protosupport.v1.parigot_error) = true;
  NoError = 0; // mandatory
  DispatchError = 1; //mandatory
  UnmarshalError = 2; // mandatory
  MarshalError = 3; // mandatory

  // Path related errors

  // InvalidPathError: Provided path name is not valid based on following rules:
  //  1. The separator should be "/"
  //  2. It should start with specific prefix -> '/parigot/app/'
  //  3. It should not contain any "." or ".." in the path
  //  4. It should not exceed a specific value for the number (max is 20) of parts in the path
  //  5. It should avoid certain special characters, including:
  //     Asterisk (*)					Question mark (?)		Greater than (>)
  //     Less than (<)				Pipe symbol (|)			Ampersand (&)
  //     Semicolon (;)				Dollar sign ($)			Backtick (`)
  //     Double quotation marks (")	Single quotation mark (')
  //
  // Invalid example:
  //
  //	'/parigot/app/..' -> '..' is not allowed
  //	'/parigot/app/./' -> '.' is not allowed
  //	'/parigot/app/foo\bar' -> '\' is not allowed
  //	'//parigot/app/foo', '/parigot/app' -> prefix should be '/parigot/app/'
  InvalidPathError = 4;

  // File status related errors
  AlreadyInUseError = 5; // The file is already being used.
  NotExistError = 6; // The file/path does not exist
  FileClosedError = 7; // The file status is CLOSED, cannot be accessed by a read or write request
  EOFError = 8; // The file is at the end of the file
  ReadError = 9; // Some error happened during reading a file
  WriteError = 10; // Some error happened during writing a file
  OpenError = 11; // Some error happened during opening a file
  DeleteError = 12; // Some error happened during deleting a file
  CreateError = 13; // Some error happened during creating a file
  NoDataFoundError = 14; // No data file found in the directory
  
  LargeBufError = 15; // The buffer for the file is too large
  InternalError = 16; // There are internal issues with the file service
}