syntax ="proto3";
package file.v1;
option go_package="github.com/iansmith/parigot/g/file/v1;file";
import "protosupport/v1/protosupport.proto";


// This is the File service for parigot.  It is sandboxed such that caller to this service
// has limited access to files. The caller can expect that "/app" is a directory in which new
// files can be created and existing files can be found.  
// 
// Paths must be UTF-8 encoded with no control characters, without leading -, without . or ..
// elements, and without carriage returns or newlines.
//
// This api provides no synchronous interface to reading or writing file content.  The caller will
// be handed an Id upon successfully starting a read or write.  That Id can be used later to 
// query the status of the read or write and it is expected that this will be driven by the *end user*,
// such as a user on the internet with a web browser.


service File {
  // Open handles the READ-only operation on a file
  rpc Open(OpenRequest) returns (OpenResponse);

  // Create handles the WRITE-only operation on a file. It creates or truncates the name file
  // in the path. If the file already exists, it is truncated. If the file does not exist, it is created.
  rpc Create(CreateRequest) returns (CreateResponse);

  // Close changes the status of a file to "close"
  rpc Close(CloseRequest) returns (CloseResponse);

  // Load does NOT check that the file(s) referred to are reasonable in length, do not contain
  // symlinks, are readable, etc.  Don't allow this call in prod.
  rpc LoadTestData(LoadTestDataRequest) returns (LoadTestDataResponse);

  rpc Read(ReadRequest) returns (ReadResponse);

  rpc Write(WriteRequest) returns (WriteResponse);

  // Delete free a file from memory (datacache) or delete it from the disk
  rpc Delete(DeleteRequest) returns (DeleteResponse);
}


message CreateRequest {
  string path  = 1;
  string content = 2;
}

message OpenRequest {
  string path  = 1;
}

message CloseRequest {
  protosupport.v1.IdRaw id = 1;
}

message CreateResponse {
  string path = 1;
  protosupport.v1.IdRaw id = 2;
  bool truncated = 3;
}

message OpenResponse {
  string path = 1;
  protosupport.v1.IdRaw id = 2;
}

// CloseResponse is not empty because it can return an error. However, there is no
// action that the receiver of this response can take other than perhaps issuing a warning
// to the system operators.
message CloseResponse {
  protosupport.v1.IdRaw id = 1;
}

// LoadTestDataRequest loads the contents of given directory from the _host_ file system into the /app directory
// of the test filesystem (in memory).   This is only intended to be use for test code.
message LoadTestDataRequest {
  // path is a path to a directory on the _host_ filesystem that is to be loaded in /app
  string path = 1;
  // where this new file will exist in the in-memory filesystem... this path
  // will be cleaned lexically and then joined to /app.  Note that it is possible
  // create paths with this parameter that cannot be opened because of
  // restrictions on the path in open.
  string mount_location = 2;
  // returnOnFail should be set to true if you do NOT want the normal behavior of using panic on error.
  // If this value is set to true, the paths that cause an error on import are return in the TestDataResponse.
  bool return_on_fail = 3;
}

// LoadTestDataResponse contains a list of paths that caused an error during loading. This value is only
// returned if the LoadRequest has the returnOnFail set to true.  If LoadDataRequest.return_on_fail is
// false since by definition the error_path will be empty.
message LoadTestDataResponse {
  repeated string error_path = 1;
}

message ReadRequest {
  protosupport.v1.IdRaw id = 1;
  // Reads up to len(buf) bytes into buf
  bytes buf = 2;
}

message ReadResponse {
  protosupport.v1.IdRaw id = 1;
  // The number of bytes read (0 <= num_read <= len(buf))
  int32 num_read = 2;
}

message WriteRequest {
  protosupport.v1.IdRaw id = 1;
  // Writes len(buf) bytes from buf
  bytes buf = 2;
}

message WriteResponse {
  protosupport.v1.IdRaw id = 1;
  // The number of bytes written from buf (0 <= num_write <= len(buf)) 
  int32 num_write = 2;
}

message DeleteRequest {
  protosupport.v1.IdRaw id = 1;
}

message DeleteResponse {
  protosupport.v1.IdRaw id = 1;
}

enum FileErr {
  option (protosupport.v1.parigot_error) = true;
  NoError = 0; // mandatory
  DispatchError = 1; //mandatory
  UnmarshalError = 2; // mandatory
  MarshalError = 3; // mandatory

  // Path related errors
  // InvalidPathError: Provided path name is not valid based on following rules:
  // 1. The separator should be "/"
  // 2. It should start with specific prefix
  // 3. It should not contain any "." or ".." in the path
  // 4. It should not exceed a specific limit for the number of parts in the path
  InvalidPathError = 4;

  // File state related errors
  AlreadyInUseError = 5; // The file is already being used.
  NotExistError = 6; // The file does not exist
  FileClosedError = 7; // The file status is CLOSED, cannot be accessed by a read or write request
  
  LargeBufError = 8; // The buffer for the file is too large
  InternalError = 9; // There are internal issues with the file service
}