
// These functions are for the use of the container implementation.   Use of these
// functions implies that "you know what you are doing".
//
// This file gets moved to the command/runner/g directory by the makefile, thus this
// code is place in the package for its destination.

package g
import (
    "unsafe"

	wasmtime "github.com/bytecodealliance/wasmtime-go"
)


// This interface makes it easy to avoid import cycles. The implementation is
// provided by the container.

type Caller interface {
{{- range .info.Service }}
{{- range .GetWasmMethod}}
{{- .SetProtoPackage "command.runner.g"}}

{{- $methodParamDecl:=call .FuncChoice.MethodParamDecl .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput  . }}
{{- $methodRet:=call .FuncChoice.MethodRet .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput true . }}
{{- $usesRet:=call .FuncChoice.UsesReturnValuePtr .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput  . }}

    {{- if $usesRet}}
    {{.GetName}}(retVal int32,{{$methodParamDecl}})
    {{- else }}
    {{.GetName}}({{$methodParamDecl}}) {{$methodRet}}
    {{- end }}
{{- end}}
{{- end}}
    GetMemPtr() uintptr
}

var impl Caller
func SetCaller(i Caller) {
    impl=i
}

func bytesConvert(memPtr uintptr, ptr int32, length int32, _ int32) []byte{
	buf := make([]byte, length)
	for i := int32(0); i < length; i++ {
		b := (*byte)(unsafe.Pointer(memPtr + uintptr(ptr+i)))
		buf[i] = *b
	}
	return buf
}

func strConvert(memPtr uintptr, ptr int32, length int32) string {
    // we could probably go bytesConvert and claim our cap was equal to our len but...
	buf := make([]byte, length)
	for i := int32(0); i < length; i++ {
		b := (*byte)(unsafe.Pointer(memPtr + uintptr(ptr+i)))
		buf[i] = *b
	}
	s := string(buf)
	return s
}

// These functions with the trailing underscore are the true implementations
// at the WASM level. Note that these can only use the 4 basic WASM types
// (int32,int64,float32,float64) and must understand the calling convention
// of the compiler.
//
// The implementations shown here are really just for the convenience of the
// container implementation.
//

{{- range .info.Service }}
{{- range .GetWasmMethod}}
{{- .SetProtoPackage "command.runner.g"}}
{{- $methodParamDeclWasm:=call .FuncChoice.MethodParamDeclWasm .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput  . }}
{{- $methodCallWasm:=call .FuncChoice.MethodCallWasm .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput  . }}
{{- $methodRet:=call .FuncChoice.MethodRet .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput true . }}
{{- $usesRet:=call .FuncChoice.UsesReturnValuePtr .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput  . }}
{{- $needsRet:=call .FuncChoice.NeedsRet .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput  }}

{{- if $usesRet }}
func {{.GetWasmMethodName}}_({{$methodParamDeclWasm}}) {
{{- else }}
func {{.GetWasmMethodName}}_({{$methodParamDeclWasm}}) {{$methodRet}} {
{{- end }}
    {{- if $usesRet }}
    impl.{{.GetName}}(retVal,{{$methodCallWasm}})
    {{- else}}
    {{- if $needsRet}}
    return impl.{{.GetName}}({{$methodCallWasm}})
    {{- else}}
    impl.{{.GetName}}({{$methodCallWasm}})
    {{- end}}
    {{- end}}
}

{{- end}}
{{- end}}

func WasmTimeWrapABI(impl Caller, store wasmtime.Storelike, result map[string]*wasmtime.Func) {
// bind the names of the container implementation
{{- range .info.Service }}
{{- range .GetWasmMethod}}
{{- .SetProtoPackage "command.runner.g"}}

result["{{.Parent.GetWasmServiceName}}.{{.GetWasmMethodName}}_"]=wasmtime.WrapFunc(store, {{.GetWasmMethodName}}_)
result["env.github.com/iansmith/parigot/g/parigot/abi.{{LastSegmentOfPackage .GetWasmMethodName}}_"]=wasmtime.WrapFunc(store, {{.GetWasmMethodName}}_)

{{/*
{{- end }} */}}
{{- end }}
{{- end }}
}


