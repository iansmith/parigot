
// These functions are for the use of the container implementation.   Use of these
// functions implies that "you know what you are doing".
//
// This file gets moved to the command/runner/g directory by the makefile, thus this
// code is place in the package for its destination.

package g
import (
    "unsafe"

    "github.com/iansmith/parigot/g/parigot/abi"

	wasmtime "github.com/bytecodealliance/wasmtime-go"
)


// This interface makes it easy to avoid import cycles. The implementation is
// provided by the container.

type Caller interface {
{{- range .info.Service }}
{{- range .GetWasmMethod}}
{{- .SetProtoPackage "command.runner.g"}}

{{- $methodParamDecl:=call .FuncChoice.MethodParamDecl .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput  . }}
{{- $methodRet:=call .FuncChoice.MethodRet .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput true . }}
    {{.GetName}}({{$methodParamDecl}}) {{$methodRet}}
{{- end}}
{{- end}}
    GetMemPtr() uintptr
}

var impl Caller
func SetCaller(i Caller) {
    impl=i
}

func bytesConvert(memPtr uintptr, ptr int32, length int32, _ int32) []byte{
	buf := make([]byte, length)
	for i := int32(0); i < length; i++ {
		b := (*byte)(unsafe.Pointer(memPtr + uintptr(ptr+i)))
		buf[i] = *b
	}
	return buf
}

func strConvert(memPtr uintptr, ptr int32, length int32) string {
    // we could probably go bytesConvert and claim our cap was equal to our len but...
	buf := make([]byte, length)
	for i := int32(0); i < length; i++ {
		b := (*byte)(unsafe.Pointer(memPtr + uintptr(ptr+i)))
		buf[i] = *b
	}
	s := string(buf)
	return s
}


func WasmTimeWrapABI(impl Caller, store wasmtime.Storelike, result map[string]*wasmtime.Func) {
// bind the names of the container implementation
{{- range .info.Service }}
{{- range .GetWasmMethod}}
{{- .SetProtoPackage "command.runner.g"}}

{{/*
{{- $complexParam:=call .FuncChoice.HasComplexParam .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput . }}
{{- if $complexParam}}
result["{{.Parent.GetWasmServiceName}}.{{.GetWasmMethodName}}_"]=wasmtime.WrapFunc(store, {{.GetWasmMethodName}}_)
{{- else }} */}}
result["{{.Parent.GetWasmServiceName}}.{{.GetWasmMethodName}}_"]=wasmtime.WrapFunc(store, {{.GetWasmMethodName}}_)
result["env.github.com/iansmith/parigot/g/parigot/abi.{{LastSegmentOfPackage .GetWasmMethodName}}_"]=wasmtime.WrapFunc(store, {{.GetWasmMethodName}}_)

{{/*
{{- end }} */}}
{{- end }}
{{- end }}
}


// These functions are the ones that are actually behind the abi for each
// function call that cannot accept and return wasm compatible values.
// These will get bound to the implementation of the interface provided with
// SetCaller().  Note that these true implementations can only use the four
// real types of WASM (I32,F32,I64,F64).

{{- range .info.Service }}
{{- range .GetWasmMethod}}
{{- .SetProtoPackage "command.runner.g"}}

{{- $methodRet:=call .FuncChoice.MethodRet .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput true . }}
{{- $needsRet:=call .FuncChoice.NeedsRet .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput}}
{{- $retValue:=call .FuncChoice.RetValue .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput . }}
{{/*
{{- $methParamDeclWasm:=call .FuncChoice.MethodParamDeclWasm .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput . }}
*/}}
{{- $methParamDecl:=call .FuncChoice.MethodParamDecl .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput . }}

{{/*
{{- $methodCallWasm:=call .FuncChoice.MethodCallWasm .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput  . }}
*/}}
{{- $methodCall:=call .FuncChoice.MethodCall .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput  . }}

func {{.GetWasmMethodName}}_({{$methParamDecl}}) {{$methodRet}} {
{{- if $needsRet}}
    return impl.{{.GetName}}({{$methodCall}})
{{- else }}
    impl.{{.GetName}}({{$methodCall}})
{{- end}}
}
{{- end }}
{{- end }}

