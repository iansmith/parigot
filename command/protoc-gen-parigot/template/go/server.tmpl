//go:build wasip1 

// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}

{{$file:=.file}}
{{$package:=.package}}

import (
	"context"
	"io"
	"os"
	"sync"
    "unsafe"

{{- range $j,$i := .import  }}
	{{$j -}}
{{- end}} {{/* imports */}}

    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
	"github.com/iansmith/parigot/apiwasm"  
	guestsyscall "github.com/iansmith/parigot/apiwasm/syscall"  
	pcontext "github.com/iansmith/parigot/context"
	"github.com/iansmith/parigot/g/syscall/v1"
	"github.com/iansmith/parigot/apishared/id"
	
)
var _ =  unsafe.Sizeof([]byte{})


{{- $info:=.info }}
{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}

type {{$svcCamel}}Server interface {
{{- range .GetWasmMethod }}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $iParam:=.InputParam.CGType.String $package}}
{{- $oParam:=.OutputParam.CGType.String $package}}
{{- if .InputCodeNeeded }}
	{{$methCamel}}(ctx context.Context,in *{{$iParam}}) 
{{- else }}
	{{$methCamel}}(ctx context.Context) 
{{- end }} 
{{- if .OutputCodeNeeded -}}
    (*{{$oParam}}, {{$errId}})
{{- else -}}
    {{$errId}}
{{- end}} {{/* end of output code needed */}}
{{- end}} {{/* end of range over methods */}}
	Ready(ctx context.Context) bool
}
{{- end}} {{/* end of range over services */}}

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $svcCamelFL:=toCamelCaseFirstLower .GetWasmServiceName }}
{{- $svcLowerNoService:=toLowerNoService .GetWasmServiceName }}

var {{$svcCamel}}MethodNameToId = make(map[string]id.MethodId)

func (s * Wrap{{$svcCamel}}) Ready(ctx context.Context) bool {
	return s.impl.Ready(ctx)
}
func Run{{$svcCamel}}(ctx context.Context, sid id.ServiceId, impl {{$svcCamel}}Server) {
	defer func() {
		pcontext.Dump(ctx)
	}()
	// wait until all the go routines are done
	var wg sync.WaitGroup
	err:={{$svcCamelFL}}Bind(ctx,sid, impl,&wg)
	if err!=0{
		pcontext.Errorf(ctx,"error returned from {{$svcCamel}}Bind:%d",
			err)
		return
	}

	wg.Wait()			
}

func {{$svcCamelFL}}Bind(ctx context.Context,sid id.ServiceId, impl {{$svcCamel}}Server, wg *sync.WaitGroup)  syscall.KernelErr {
	var fp io.Reader
	var err error
	var bindReq *syscall.BindMethodRequest
	var mid id.MethodId

{{- range .GetWasmMethod}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $methCamelFL:=toCamelCaseFirstLower .WasmMethodName}}
{{ $dir :=call .FuncChoice.BindDirection .InputCodeNeeded .OutputCodeNeeded false false .}}

	bindReq = &syscall.BindMethodRequest{}
	bindReq.ServiceId = sid.Marshal()
	bindReq.MethodName = "{{$methCamel}}"
	// we create and bind the message id below

//
// {{.ProtoPackage}}.{{$methCamel}}
//
{{- if eq $dir "Both" }}
	bindReq.Direction = syscall.MethodDirection_METHOD_DIRECTION_BOTH
	fp, err=os.OpenFile("{{.ProtoPackage}}.{{$methCamel}}",os.O_CREATE | os.O_RDWR, 0600)
{{- else }} {{/* else of InOut */}}
{{- if eq $dir "Out" }}
	bindReq.Direction =syscall.MethodDirection_METHOD_DIRECTION_OUT
	fp, err=os.OpenFile("{{.ProtoPackage}}.{{$methCamel}}",os.O_CREATE | os.O_WRONLY, 0200)
{{- else }} {{/* else of "Out */}}
	bindReq.Direction =syscall.MethodDirection_METHOD_DIRECTION_IN
	fp, err=os.OpenFile("{{.ProtoPackage}}.{{$methCamel}}",os.O_CREATE | os.O_RDONLY, 0400)
{{- end }} {{/* end of Out */}}
{{- end }} {{/* end of Both */}}
	if err!=nil {
		pcontext.Errorf(ctx,"Unable to open '{{.ProtoPackage}}.{{$methCamel}}', open failed:%s",err.Error())
		return  syscall.KernelErr_NotFound
	}
	if !impl.Ready(ctx){
		pcontext.Errorf(ctx,"Unable to start {{.ProtoPackage}}.{{$methCamel}}, Ready returned false")
		pcontext.Dump(ctx)
		return syscall.KernelErr_NotReady
	}
	mid=guestsyscall.MustBindMethodName(bindReq)
	{{$svcCamel}}MethodNameToId["{{$methCamel}}"]=mid

{{- if eq $dir "Both" }}
	go func(c context.Context, rd io.Reader, wr io.Writer, impl {{$svcCamel}}Server, wg *sync.WaitGroup) {
		wg.Add(1)
		//
		// input and output
		//
		defer func() {
			pcontext.Dump(c)
		}()
		for {
			pcontext.Dump(c) // from last iteration
			var msg {{$iParam}}
			bpi := apiwasm.NewBytePipeIn[*{{$iParam}}](ctx, rd)
			bpo := apiwasm.NewBytePipeOut[*{{$oParam}}](ctx, wr)

			var errValue int32
			err =bpi.ReadProto(&msg,&errValue)
			if err!=nil {
				if err==apiwasm.ErrSignalExit{
					break
				}
				pcontext.Fatalf(c,"error in '{{.ProtoPackage}}.{{$methCamel}}' reading next message: %v",err)
				break
			}
			if errValue!=0 {
				pcontext.Errorf(c,"error id received (%d),not calling '{{.ProtoPackage}}.{{$methCamel}}'",errValue)
				continue
			}
			pcontext.Infof(c,"Read in a new request of type: %s","{{$iParam}}")
			resp, fleazil := impl.{{$methCamel}}(c, &msg)
			if fleazil!=0 {
				pcontext.Errorf(c,"Error returned from {{$methCamel}}: %d",fleazil)				
				if err:=bpo.WriteProto(nil,int32(fleazil)); err!=nil {
					pcontext.Errorf(c,"Error writing errId response in {{$methCamel}}: %v",err)
				} 
				continue
			}
			errId:=syscall.KernelErr_NoError
			if err=bpo.WriteProto(resp,int32(errId)); err!=nil {
				pcontext.Errorf(c,"Error writing proto response in {{$methCamel}}: %v",err)
				continue
			}
		}
		wg.Wait()
		pcontext.Errorf(c,"service {{$svc}} has had all go routines stop")
		pcontext.Dump(c)
	}(ctx,fp,fp.(io.Writer),impl,wg)
{{- else }} {{/* else of Both */}}
{{- if eq $dir "In" }}
	//
	// input only
	//

	go func(c context.Context, rd io.Reader, wr io.Writer, impl {{$svcCamel}}Server, wg *sync.WaitGroup) {
		defer func() {
			pcontext.Dump(c)
		}()
		wg.Add(1)
		for {
			pcontext.Dump(c) // from last iteration
			var msg {{$iParam}}
			bpi := apiwasm.NewBytePipeIn[*{{$iParam}}](ctx, rd)
			var rawError int32

			err =bpi.ReadProto(&msg,&rawError)
			if err!=nil {
				if err==apiwasm.ErrSignalExit{
					break
				}
				pcontext.Fatalf(c,"error in '{{.ProtoPackage}}.{{$methCamel}}' reading next message: %v",err)
				break
			}
			if rawError!=0 {
				pcontext.Errorf(c,"error id received (%d),not calling '{{.ProtoPackage}}.{{$methCamel}}'",rawError)
				continue
			}
			pcontext.Infof(c,"Read in a new request of type: %s","{{$iParam}}")
			fleazil := impl.{{$methCamel}}(c, &msg)
			if fleazil!=0 {
				pcontext.Errorf(c,"Ignoring error returned from {{$methCamel}}: %d",fleazil)				
				continue
			}
		}
		wg.Wait()
		pcontext.Errorf(c,"service {{$svc}} has had all go routines stop")
		pcontext.Dump(c)
	}(ctx,fp,fp.(io.Writer),impl,wg)
{{- else }} {{/* else of "In */}}
	go func(c context.Context,wr io.Writer, impl {{$svcCamel}}Server, wg *sync.WaitGroup) {
		defer func() {
			pcontext.Dump(c)
		}()
		wg.Add(1)
		//
		// output only
		//

		for {
			pcontext.Dump(c) // from last iteration
			bpo := apiwasm.NewBytePipeOut[*{{$oParam}}](ctx, wr)
			resp, fleazil := impl.{{$methCamel}}(c)
			if int32(fleazil)!=0 {
				pcontext.Errorf(c,"Error returned from {{$methCamel}}: %d",int32(fleazil))				
				if err:=bpo.WriteProto(nil,int32(fleazil)); err!=nil {
					pcontext.Errorf(c,"Error writing errId response in {{$methCamel}}: %v",err)
					break
				}
				continue
			}
			errId:=syscall.KernelErr_NoError
			if err=bpo.WriteProto(resp,int32(errId)); err!=nil {
				pcontext.Errorf(c,"Error writing proto response in {{$methCamel}}: %v",err)
				break
			}
		}
		wg.Wait()
		pcontext.Errorf(c,"service {{$svc}} has had all go routines stop, giving up")
		pcontext.Dump(c)
	}(ctx,fp.(io.Writer),impl,wg)
{{- end }} {{/* end of In */}}
{{- end }} {{/* end of InOut */}}

{{- end }} {{/* end of range over methods */}}
	pcontext.Dump(ctx)
	return syscall.KernelErr_NoError
}

{{- /* range over methods again to do the generated refs */}}
{{- $goname:=packageToGoName .GetParent.Package}}
{{- $pkg:=toSnakeCase $goname}}
{{- $pkgFL:=toSnakeCaseFirstUpper $goname }}
{{- $svc:=toSnakeCase .GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}


type Wrap{{$svcCamel}} struct {
	impl {{$svcCamel}}Server
}
func NewWrap{{$svcCamel}} (ctx context.Context, impl {{$svcCamel}}Server) *Wrap{{$svcCamel}} {
	return &Wrap{{$svcCamel}}{
		impl: impl,
	}
}
{{- range .GetWasmMethod }}
{{- $methSnake:=toSnakeCase .WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}

{{- $hostFuncName:= $methCamel}}
{{- $hostFuncNameSnake:= $methSnake}}
{{- if ne .HostFuncName ""}} 
{{- $hostFuncName = .HostFuncName}}
{{- $hostFuncNameSnake = toSnakeCase .HostFuncName}}
{{- end }} {{/* end of if host func option used */}}

// If you want to implement part of your server in host cost you should call 
// {{$methCamel}}Host from your server implementation. These will be optimized 
// away by the compiler if you don't use them--in other words, if you 
// implement everything on the guest side).
//
//go:wasmimport {{packageToGoName $pkg}} {{$hostFuncNameSnake}}_
func {{$hostFuncName}}_(int32,int32,int32,int32) int64
func {{$hostFuncName}}Host(inPtr *{{$iParam}}) (*{{$oParam}}, {{$errId}}) {
	outProtoPtr := (*{{$oParam}})(nil)
	ctx := apiwasm.ManufactureGuestContext("[{{$svcCamel}}]{{$methCamel}}")
	defer pcontext.Dump(ctx)
	ret, raw, signal:= apiwasm.ClientSide(ctx, inPtr, outProtoPtr, {{$methCamel}}_)
	if signal {
		os.Exit(1)
	}
	return ret, {{$errId}}(raw)
}
{{- end }}  {{/* end range over methods */}}
{{- end }} {{/* range over services */}}
