//go:build wasip1 

// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}

{{$file:=.file}}
{{$package:=.package}}

import (
	"context"
	"io"
	"os"
	"sync"
    "unsafe"

{{- range $j,$i := .import  }}
	{{$j -}}
{{- end}} {{/* imports */}}

    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
	"github.com/iansmith/parigot/apishared/id"
	"github.com/iansmith/parigot/apiwasm"  
	pcontext "github.com/iansmith/parigot/context"
	
)
var _ =  unsafe.Sizeof([]byte{})
{{- $info:=.info }}
{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}
var {{$svcCamel}}fsName = "/parigotvirt"

//
// {{$svcCamel}}Server (from {{$file}})
//

type {{$svcCamel}}Server interface {
{{range .GetWasmMethod }}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}
{{- if .InputCodeNeeded }}
	{{$methCamel}}(ctx context.Context,in *{{$iParam}}) 
{{- else }}
	{{$methCamel}}(ctx context.Context) 
{{- end }} 
{{- if .OutputCodeNeeded -}}
    (*{{$oParam}}, {{$errId}})
{{- else -}}
    {{$errId}}
{{- end}} {{/* end of output code needed */}}
{{- end}} {{/* end of range over methods */}}
	Ready(ctx context.Context) bool
}
{{- end}} {{/* end of range over services */}}

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $svcCamelFL:=toCamelCaseFirstLower .GetWasmServiceName }}
{{- $svcLowerNoService:=toLowerNoService .GetWasmServiceName }}

func (s * Wrap{{$svcCamel}}) Ready(ctx context.Context) bool {
	return s.impl.Ready(ctx)
}
func Run{{$svcCamel}}(ctx context.Context, impl {{$svcCamel}}Server) {
	defer func() {
		pcontext.Dump(ctx)
	}()
	// wait until all the go routines are done
	var wg sync.WaitGroup
	err:={{$svcCamelFL}}Bind(ctx,impl,&wg)
	if err.IsError() {
		pcontext.Errorf(ctx,"error returned from {{$svcCamel}}Bind:%v", err)
		return
	}

	wg.Wait()			
}

func {{$svcCamelFL}}Bind(ctx context.Context,impl {{$svcCamel}}Server, wg *sync.WaitGroup)  id.KernelErrId {
	var fp io.Reader
	var err error

{{- range .GetWasmMethod}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}


{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $methCamelFL:=toCamelCaseFirstLower .WasmMethodName}}
{{ $dir :=call .FuncChoice.BindDirection .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}

//
// {{.ProtoPackage}}.{{$methCamel}}
//
{{- if eq $dir "Both" }}
	fp, err=os.OpenFile("{{.ProtoPackage}}.{{$methCamel}}",os.O_CREATE | os.O_RDWR, 0600)
{{- else }} {{/* else of InOut */}}
{{- if eq $dir "Out" }}
	fp, err=os.OpenFile("{{.ProtoPackage}}.{{$methCamel}}",os.O_CREATE | os.O_WRONLY, 0200)
{{- else }} {{/* else of "Out */}}
	fp, err=os.OpenFile("{{.ProtoPackage}}.{{$methCamel}}",os.O_CREATE | os.O_RDONLY, 0400)
{{- end }} {{/* end of Out */}}
{{- end }} {{/* end of Both */}}
	if err!=nil {
		pcontext.Errorf(ctx,"Unable to open '{{.ProtoPackage}}.{{$methCamel}}', open failed:%s",err.Error())
		return  id.NewKernelErrId(id.KernelNotFound)
	}
	if !impl.Ready(ctx){
		pcontext.Errorf(ctx,"Unable to start {{.ProtoPackage}}.{{$methCamel}}, Ready returned false")
		pcontext.Dump(ctx)
		return id.NewKernelErrId(id.KernelNotReady)
	}
{{- if eq $dir "Both" }}
	go func(c context.Context, rd io.Reader, wr io.Writer, impl {{$svcCamel}}Server, wg *sync.WaitGroup) {
		wg.Add(1)
		//
		// input and output
		//
		defer func() {
			pcontext.Dump(c)
		}()
		for {
			pcontext.Dump(c) // from last iteration
			var msg {{$iParam}}
			bpi := apiwasm.NewBytePipeIn[*{{$iParam}}](ctx, rd)
			bpo := apiwasm.NewBytePipeOut[*{{$oParam}}](ctx, wr)

			var idRaw id.IdRaw
			err =bpi.ReadProto(&msg,&idRaw)
			if err!=nil {
				if err==apiwasm.ErrSignalExit{
					break
				}
				pcontext.Fatalf(c,"error in '{{.ProtoPackage}}.{{$methCamel}}' reading next message: %v",err)
				break
			}
			if idRaw.IsError() {
				pcontext.Errorf(c,"error id received (%s),not calling '{{.ProtoPackage}}.{{$methCamel}}'",idRaw.String())
				continue
			}
			pcontext.Infof(c,"Read in a new request of type: %s","{{$iParam}}")
			resp, fleazil := impl.{{$methCamel}}(c, &msg)
			idRaw=fleazil.Raw()
			if idRaw.IsError() {
				pcontext.Errorf(c,"Error returned from {{$methCamel}}: %v",idRaw.String())				
				if err:=bpo.WriteProto(nil,idRaw); err!=nil {
					pcontext.Errorf(c,"Error writing errId response in {{$methCamel}}: %v",err)
				}
				continue
			}
			errId:=id.KernelErrIdNoErr
			if err=bpo.WriteProto(resp,errId.Raw()); err!=nil {
				pcontext.Errorf(c,"Error writing proto response in {{$methCamel}}: %v",err)
				continue
			}
		}
		wg.Wait()
		pcontext.Errorf(c,"service {{$svc}} has had all go routines stop")
		pcontext.Dump(c)
	}(ctx,fp,fp.(io.Writer),impl,wg)
{{- else }} {{/* else of Both */}}
{{- if eq $dir "In" }}
	//
	// input only
	//

	go func(c context.Context, rd io.Reader, wr io.Writer, impl {{$svcCamel}}Server, wg *sync.WaitGroup) {
		defer func() {
			pcontext.Dump(c)
		}()
		wg.Add(1)
		for {
			pcontext.Dump(c) // from last iteration
			var msg {{$iParam}}
			bpi := apiwasm.NewBytePipeIn[*{{$iParam}}](ctx, rd)
			var idRaw id.IdRaw

			err =bpi.ReadProto(&msg,&idRaw)
			if err!=nil {
				if err==apiwasm.ErrSignalExit{
					break
				}
				pcontext.Fatalf(c,"error in '{{.ProtoPackage}}.{{$methCamel}}' reading next message: %v",err)
				break
			}
			if idRaw.IsError() {
				pcontext.Errorf(c,"error id received (%s),not calling '{{.ProtoPackage}}.{{$methCamel}}'",idRaw.String())
				continue
			}
			pcontext.Infof(c,"Read in a new request of type: %s","{{$iParam}}")
			fleazil := impl.{{$methCamel}}(c, &msg)
			idRaw = fleazil.Raw()
			if idRaw.IsError() {
				pcontext.Errorf(c,"Ignoring error returned from {{$methCamel}}: %v",idRaw.String())				
				continue
			}
		}
		wg.Wait()
		pcontext.Errorf(c,"service {{$svc}} has had all go routines stop")
		pcontext.Dump(c)
	}(ctx,fp,fp.(io.Writer),impl,wg)
{{- else }} {{/* else of "In */}}
	go func(c context.Context,wr io.Writer, impl {{$svcCamel}}Server, wg *sync.WaitGroup) {
		defer func() {
			pcontext.Dump(c)
		}()
		wg.Add(1)
		//
		// output only
		//

		for {
			pcontext.Dump(c) // from last iteration
			bpo := apiwasm.NewBytePipeOut[*{{$oParam}}](ctx, wr)
			var idRaw id.IdRaw
			resp, fleazil := impl.{{$methCamel}}(c)
			idRaw=fleazil.Raw()
			if idRaw.IsError() {
				pcontext.Errorf(c,"Error returned from {{$methCamel}}: %v",idRaw.String())				
				if err:=bpo.WriteProto(nil,idRaw); err!=nil {
					pcontext.Errorf(c,"Error writing errId response in {{$methCamel}}: %v",err)
				}
				continue
			}
			errId:=id.KernelErrIdNoErr
			if err=bpo.WriteProto(resp,errId.Raw()); err!=nil {
				pcontext.Errorf(c,"Error writing proto response in {{$methCamel}}: %v",err)
				continue
			}
		}
		wg.Wait()
		pcontext.Errorf(c,"service {{$svc}} has had all go routines stop, giving up")
		pcontext.Dump(c)
	}(ctx,fp.(io.Writer),impl,wg)
{{- end }} {{/* end of In */}}
{{- end }} {{/* end of InOut */}}

{{- end }} {{/* end of range over methods */}}
	pcontext.Dump(ctx)
	return id.KernelErrIdNoErr
}

{{- /* range over methods again to do the generated refs */}}
{{- $goname:=packageToGoName .GetParent.Package}}
{{- $pkg:=toSnakeCase $goname}}
{{- $pkgFL:=toSnakeCaseFirstUpper $goname }}
{{- $svc:=toSnakeCase .GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}


type Wrap{{$svcCamel}} struct {
	impl {{$svcCamel}}Server
}
func NewWrap{{$svcCamel}} (ctx context.Context, impl {{$svcCamel}}Server) *Wrap{{$svcCamel}} {
	return &Wrap{{$svcCamel}}{
		impl: impl,
	}
}
{{- range .GetWasmMethod }}
{{- $methSnake:=toSnakeCase .WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}

// If you want to implement part of your server in host cost you should call 
// {{$methCamel}}Host from your server implementation. These will be optimized 
// away by the compiler if you don't use them--in other words, if you 
// implement everything on the guest side).
//go:wasmimport {{packageToGoName $pkg}} {{$methSnake}}_
func {{$methCamel}}_(int32,int32,int32,int32) int64
func {{$methCamel}}Host(inPtr *{{$iParam}}) (*{{$oParam}}, {{$errId}}) {
	outProtoPtr := (*{{$oParam}})(nil)
	ctx := apiwasm.ManufactureGuestContext("[{{$svcCamel}}]{{$methCamel}}")
	defer pcontext.Dump(ctx)
	ret, raw, signal:= apiwasm.ClientSide(ctx, inPtr, outProtoPtr, {{$methCamel}}_)
	if signal {
		os.Exit(1)
	}
	return ret, {{$errId}}(raw)
}
{{- end }}  {{/* end range over methods */}}
{{- end }} {{/* range over services */}}
