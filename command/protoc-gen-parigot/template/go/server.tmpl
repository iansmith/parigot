//go:build wasip1 

// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}

{{$file:=.file}}
{{$package:=.package}}

import (
	"context"
    "unsafe"

{{- range $j,$i := .import  }}
	{{$j -}}
{{- end}} {{/* imports */}}

    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
	"github.com/iansmith/parigot/apiwasm"  
	guestsyscall "github.com/iansmith/parigot/apiwasm/syscall"  
	pcontext "github.com/iansmith/parigot/context"
	"github.com/iansmith/parigot/g/syscall/v1"
	"github.com/iansmith/parigot/apishared/id"

	"google.golang.org/protobuf/types/known/anypb"

	
)
var _ =  unsafe.Sizeof([]byte{})


{{- $info:=.info }}
{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}

type Server{{$svcCamel}} interface {
{{- range .GetWasmMethod }}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $iParam:=.InputParam.CGType.String $package}}
{{- $oParam:=.OutputParam.CGType.String $package}}
{{- if .InputCodeNeeded }}
	{{$methCamel}}(ctx context.Context,in *{{$iParam}}) 
{{- else }}
	{{$methCamel}}(ctx context.Context) 
{{- end }} 
{{- if .OutputCodeNeeded -}}
    (*{{$oParam}}, {{$errId}})
{{- else -}}
    {{$errId}}
{{- end}} {{/* end of output code needed */}}
{{- end}} {{/* end of range over methods */}}
	Ready(ctx context.Context, sid id.ServiceId) bool
}
{{- end}} {{/* end of range over services */}}

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $svcCamelFL:=toCamelCaseFirstLower .GetWasmServiceName }}
{{- $svcLowerNoService:=toLowerNoService .GetWasmServiceName }}


func Launch{{$svcCamel}}(ctx context.Context, sid id.ServiceId, impl Server{{$svcCamel}}) syscall.KernelErr{
	defer func() {
		pcontext.Dump(ctx)
	}()

	if !impl.Ready(ctx,sid){
		pcontext.Errorf(ctx,"Unable to start {{.ProtoPackage}}.{{$svcCamel}}, Ready returned false")
		pcontext.Dump(ctx)
		return syscall.KernelErr_NotReady
	}

	return syscall.KernelErr_NoError
}

func Init{{$svcCamel}}(ctx context.Context,require []apiwasm.MustRequireFunc, impl Server{{$svcCamel}}) *apiwasm.ServiceMethodMap{
	defer func() {
		if r := recover(); r != nil {
			pcontext.Infof(ctx, "Init{{$svcCamel}}: trapped a panic in the guest side: %v", r)
		}
		pcontext.Dump(ctx)
	}()

	myId := MustRegister{{$svcCamel}}(ctx)
	MustExport{{$svcCamel}}(ctx)
	if len(require)>0 {
		for _, f := range require {
			f(ctx, myId)
		}
	}
	smmap:=MustWaitSatisfied{{$svcCamel}}(ctx, myId, impl)
	Launch{{$svcCamel}}(ctx, myId, impl)
	return smmap
}
func Run{{$svcCamel}}(ctx context.Context,
	binding *apiwasm.ServiceMethodMap, timeoutInMillis int32, bg apiwasm.Backgrounder) syscall.KernelErr{
	defer func() {
		if r := recover(); r != nil {
			pcontext.Infof(ctx, "Run{{$svcCamel}}: trapped a panic in the guest side: %v", r)
		}
		pcontext.Dump(ctx)
	}()
	var kerr syscall.KernelErr
	for {
		kctx:=pcontext.CallTo(ctx,"ReadOneAndCall{{$svcCamel}}")
		kerr = ReadOneAndCall{{$svcCamel}}(ctx, binding, timeoutInMillis)
		pcontext.Dump(kctx)
		if kerr == syscall.KernelErr_ReadOneTimeout {
			if bg==nil {
				continue
			}
			pcontext.Infof(ctx,"calling backgrounder of {{$svcCamel}}")
			bgctx:=pcontext.CallTo(ctx,"Background")
			bg.Background(bgctx)
			pcontext.Dump(bgctx)
			continue
		}
		if kerr == syscall.KernelErr_NoError {
			continue
		}
		break
	}
	pcontext.Errorf(ctx, "error while waiting for {{$svcCamel}} service calls: %s", syscall.KernelErr_name[int32(kerr)])
	return kerr
}

var TimeoutInMillis{{$svcCamel}} = int32(5000)

func ReadOneAndCall{{$svcCamel}}(ctx context.Context, binding *apiwasm.ServiceMethodMap, 
	timeoutInMillis int32)  syscall.KernelErr {
	req:=syscall.ReadOneRequest{}

	for _, pair := range binding.Pair() {
		req.Pair=append(req.Pair, pair)
	}
	fail:=false
	req.TimeoutInMillis = timeoutInMillis
	resp, err:=guestsyscall.ReadOne(&req)
	if err!=syscall.KernelErr_NoError {
		fail=true
		return err
	}
	if resp.Timeout {
		return syscall.KernelErr_ReadOneTimeout
	}

	sid:=id.UnmarshalServiceId(resp.GetPair().ServiceId)
	mid:=id.UnmarshalMethodId(resp.GetPair().MethodId)

	rvReq:=&syscall.ReturnValueRequest{}
	rvReq.ServiceId=resp.GetPair().ServiceId
	rvReq.MethodId=resp.GetPair().MethodId
	rvReq.CallId=resp.CallId
	rvReq.Failed=fail

	if !fail{
		fn:=binding.Func(sid,mid)
		funcAny, err:=fn(resp.Param)
		rvReq.Result = funcAny
		rvReq.Err = err
	}
	err=guestsyscall.ReturnValue(rvReq)
	return err
}

func {{$svcCamelFL}}Bind(ctx context.Context,sid id.ServiceId, impl Server{{$svcCamel}}) (*apiwasm.ServiceMethodMap, syscall.KernelErr) {
	var bindReq *syscall.BindMethodRequest
	var mid id.MethodId
	var fn apiwasm.FuncAnyIO
	smmap:=apiwasm.NewServiceMethodMap()

{{- $goname:=packageToGoName .GetParent.Package}}
{{- range .GetWasmMethod}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $methCamelFL:=toCamelCaseFirstLower .WasmMethodName}}
{{- $dir :=call .FuncChoice.BindDirection .InputCodeNeeded .OutputCodeNeeded false false .}}
//
// {{.ProtoPackage}}.{{$svcCamel}}.{{$methCamel}}
//

	bindReq = &syscall.BindMethodRequest{}
	bindReq.ServiceId = sid.Marshal()
	bindReq.MethodName = "{{$methCamel}}"
{{- if eq $dir "Both" }}
	bindReq.Direction = syscall.MethodDirection_METHOD_DIRECTION_BOTH

{{- else }} {{/* else of InOut */}}
{{- if eq $dir "Out" }}
	bindReq.Direction =syscall.MethodDirection_METHOD_DIRECTION_OUT
{{- else }} {{/* else of "Out */}}
	bindReq.Direction =syscall.MethodDirection_METHOD_DIRECTION_IN
{{- end }} {{/* end of Out */}}
{{- end }} {{/* end of Both */}}
	mid=guestsyscall.MustBindMethodName(bindReq)

	fn=func(in *anypb.Any)(*anypb.Any,int32){
{{- if eq $dir "Both" }}
		var tmp {{$iParam}}
		err:=in.UnmarshalTo(&tmp)
		if err!=nil {
			pcontext.Errorf(ctx,"unmarshal of anypb.Any failed: %v",err)
			return nil,int32(syscall.KernelErr_UnmarshalFailed)
		}
		out,raw:= impl.{{$methCamel}}(ctx,&tmp)
		a,err :=anypb.New(out)
		if err!=nil {
			pcontext.Errorf(ctx,"unmarshal of anypb.Any failed: %v",err)
			return nil,int32(syscall.KernelErr_MarshalFailed)
		}
		result:=int32(raw)
		return a,result
{{- else }} {{/* else of InOut */}}
{{- if eq $dir "Out" }}
		out,raw:= impl.{{$methCamel}}(ctx)
		a,err :=anypb.New(out)
		if err!=nil {
			pcontext.Errorf(ctx,"unmarshal of anypb.Any failed: %v",err)
			return nil,int32(syscall.KernelErr_MarshalFailed)
		}
		result:=int32(raw)
		return a,result
{{- else }} {{/* else of "Out */}}
		var tmp {{$iParam}}
		err:=in.UnmarshalTo(&tmp)
		if err!=nil {
			pcontext.Errorf(ctx,"unmarshal of anypb.Any failed: %v",err)
			return nil,int32(syscall.KernelErr_UnmarshalFailed)
		}
		raw:= impl.{{$methCamel}}(ctx,&tmp)
		result:=int32(raw)
		return nil,result
{{- end }} {{/* end of Out */}}
{{- end }} {{/* end of Both */}}
	}
	smmap.AddServiceMethod(sid,mid,"{{$svcCamel}}",bindReq.MethodName,fn)

{{- end }} {{/* end of range over methods */}}
	pcontext.Dump(ctx)
	return smmap,syscall.KernelErr_NoError
}

{{- /* range over methods again to do the generated refs */}}
{{- $goname:=packageToGoName .GetParent.Package}}
{{- $pkg:=toSnakeCase $goname}}
{{- $pkgFL:=toSnakeCaseFirstUpper $goname }}
{{- $svc:=toSnakeCase .GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}

{{- range .GetWasmMethod }}
{{- $methSnake:=toSnakeCase .WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}

{{- $hostFuncName:= $methCamel}}
{{- $hostFuncNameSnake:= $methSnake}}
{{- if ne .HostFuncName ""}} 
{{- $hostFuncName = .HostFuncName}}
{{- $hostFuncNameSnake = toSnakeCase .HostFuncName}}
{{- end }} {{/* end of if host func option used */}}

// If you want to implement part of your server in host cost you should call 
// {{$methCamel}}Host from your server implementation. These will be optimized 
// away by the compiler if you don't use them--in other words, if you 
// implement everything on the guest side).
//
//go:wasmimport {{packageToGoName $pkg}} {{$hostFuncNameSnake}}_
func {{$hostFuncName}}_(int32,int32,int32,int32) int64
func {{$hostFuncName}}Host(inPtr *{{$iParam}}) (*{{$oParam}}, {{$errId}}) {
	outProtoPtr := (*{{$oParam}})(nil)
	ctx := apiwasm.ManufactureGuestContext("[{{$svcCamel}}]{{$methCamel}}")
	defer pcontext.Dump(ctx)
	ret, raw, signal:= apiwasm.ClientSide(ctx, inPtr, outProtoPtr, {{$methCamel}}_)
	if signal {
		pcontext.Infof(ctx, "{{$hostFuncName}} exiting because of parigot signal")
		pcontext.Dump(ctx)
	}
	return ret, {{$errId}}(raw)
}
{{- end }}  {{/* end range over methods */}}
{{- end }} {{/* range over services */}}
