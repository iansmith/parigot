//go:build wasip1 

// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}

{{$file:=.file}}
{{$package:=.package}}

import (
	"context"
	"fmt"
    "unsafe"
{{- range $j,$i := .import  }}
	{{- $j -}}
{{- end}} {{/* imports */}}
    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
	syscallguest "github.com/iansmith/parigot/api/guest/syscall"  
	lib "github.com/iansmith/parigot/lib/go"
	"github.com/iansmith/parigot/g/syscall/v1"
	"github.com/iansmith/parigot/api/shared/id"
	apishared "github.com/iansmith/parigot/api/shared"
	"github.com/iansmith/parigot/lib/go/future"
	"github.com/iansmith/parigot/lib/go/client"
	"github.com/iansmith/parigot/api/guest"  

	"google.golang.org/protobuf/types/known/anypb"
	"google.golang.org/protobuf/proto"

)
var _ =  unsafe.Sizeof([]byte{})

{{- $needServiceDifferentiation:=true }}
{{- $svcLen := len .service }}
{{- if eq $svcLen 1 }}
{{- $needServiceDifferentiation = false}}
{{- end}}
{{- $info:=.info }}

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $svcCamelFL:=toCamelCaseFirstLower .GetWasmServiceName }}
{{- $svcLowerNoService:=toLowerNoService .GetWasmServiceName }}
{{- $svcDiff:=""}}
{{- $svcDiffFL:=""}}
{{if $needServiceDifferentiation}}
{{- $svcDiff = $svcCamel }}
{{- $svcDiffFL = $svcCamelFL }}
{{end}} {{/* end of need differentiation */}}
func Launch{{$svcDiff}}(ctx context.Context, sid id.ServiceId, impl {{$svcCamel}}) *future.Base[bool] {

	readyResult:=future.NewBase[bool]()

	ready:=impl.Ready(ctx,sid)
	ready.Handle(func (b bool) {
		if b {
			readyResult.Set(true)			
			return
		}
		guest.Log(ctx).Error("Unable to start {{.ProtoPackage}}.{{$svcCamel}}, Ready returned false")
		readyResult.Set(false)
	})

	return readyResult
}

// Note that  Init{{$svcDiff}} returns a future, but the case of failure is covered
// by this definition so the caller need only deal with Success case.
// The context passed here does not need to contain a logger, one will be created.
func Init{{$svcDiff}}(require []lib.MustRequireFunc, impl {{$svcCamel}}) (*lib.ServiceMethodMap,*syscallguest.LaunchFuture, context.Context, id.ServiceId){
	defer func() {
		if r := recover(); r != nil {
			guest.Log(context.Background()).Info("Init{{$svcCamel}}: trapped a panic in the guest side","recovered", r)
		}
	}()

	// tricky, this context really should not be used but is
	// passed so as to allow printing if things go wrong
	ctx, myId := MustRegister{{$svcDiff}}()
	MustExport{{$svcDiff}}(context.Background(),myId)
	if len(require)>0 {
		for _, f := range require {
			f(ctx, myId)
		}
	}
	smmap, launchF:=MustLaunchService{{$svcDiff}}(ctx, myId, impl)
	launchF.Failure(func (err syscall.KernelErr) {
		t:=syscall.KernelErr_name[int32(err)]
		guest.Log(ctx).Error("launch failure on call {{$svcCamel}}","error",t)
		lib.ExitClient(ctx, 1, myId, "unable to Launch in Init{{$svcDiff}}:"+t,
			"unable to call Exit in Init{{$svcDiff}}:"+t)
	})
	return smmap,launchF, ctx,myId
}
func Run{{$svcDiff}}(ctx context.Context,
	binding *lib.ServiceMethodMap, timeoutInMillis int32, bg lib.Backgrounder) syscall.KernelErr{
	defer func() {
		if r := recover(); r != nil {
			s, ok:=r.(string)
			if !ok && s!=apishared.ControlledExit {
				guest.Log(ctx).Error("Run{{$svcDiff}}: trapped a panic in the guest side", "recovered", r)
			}
		}
	}()
	var kerr syscall.KernelErr
	for {
		kerr:=ReadOneAndCall{{$svcDiff}}(ctx, binding, timeoutInMillis)
		if kerr == syscall.KernelErr_ReadOneTimeout {
			if bg==nil {
				continue
			}
			guest.Log(ctx).Info("calling backgrounder of {{$svcCamel}}")
			bg.Background(ctx)
			continue
		}
		if kerr == syscall.KernelErr_NoError {
			continue
		}
		break
	}
	guest.Log(ctx).Error("error while waiting for {{$svcDiff}} service calls", "error",syscall.KernelErr_name[int32(kerr)])
	return kerr
}
// Increase this value at your peril!
// Decreasing this value may make your overall program more responsive if you have many services.
var TimeoutInMillis{{$svcDiff}} = int32(50)

func ReadOneAndCall{{$svcDiff}}(ctx context.Context, binding *lib.ServiceMethodMap, 
	timeoutInMillis int32) syscall.KernelErr{
	req:=syscall.ReadOneRequest{}

	req.TimeoutInMillis = timeoutInMillis
	req.HostId = syscallguest.CurrentHostId().Marshal()
	resp, err:=syscallguest.ReadOne(ctx, &req)
	if err!=syscall.KernelErr_NoError {
		return err
	}
	// is timeout?
	if resp.Timeout {
		return syscall.KernelErr_ReadOneTimeout
	}

	// check for finished futures from within our address space
	ctx, t:=lib.CurrentTime(ctx)
	syscallguest.ExpireMethod(ctx,t)

	// is a promise being completed that was fulfilled somewhere else
	if r:=resp.GetResolved(); r!=nil {
		cid:=id.UnmarshalCallId(r.GetCallId())
		syscallguest.CompleteCall(ctx, syscallguest.CurrentHostId(),cid,r.GetResult(), r.GetResultError())
		return syscall.KernelErr_NoError
	}

	// its a method call from another address space
	sid:=id.UnmarshalServiceId(resp.GetBundle().GetServiceId())
	mid:=id.UnmarshalMethodId(resp.GetBundle().GetMethodId())
	cid:=id.UnmarshalCallId(resp.GetBundle().GetCallId())

	if mid.Equal(apishared.ExitMethod) {
		panic(apishared.ControlledExit)
	}
	// we let the invoker handle the unmarshal from anypb.Any because it
	// knows the precise type to be consumed
	fn:=binding.Func(sid,mid)
	if fn==nil {
		guest.Log(ctx).Error("unable to find binding for method %s on service, ignoring","mid",mid.Short(),"sid", sid.Short())
		return syscall.KernelErr_NoError
	}
	fut:=fn.Invoke(ctx,resp.GetParamOrResult())
	fut.Success(func (result proto.Message){
		rvReq:=&syscall.ReturnValueRequest{}
		rvReq.Bundle=&syscall.MethodBundle{}

		rvReq.Bundle.CallId= cid.Marshal()
		rvReq.Bundle.HostId= syscallguest.CurrentHostId().Marshal()
		var a anypb.Any
		if err:=a.MarshalFrom(result); err!=nil {
			guest.Log(ctx).Error("unable to marshal result for return value request")
			return
		}
		rvReq.Result = &a
		rvReq.ResultError = 0
		syscallguest.ReturnValue(ctx, rvReq) // nowhere for return value to go
	})
	fut.Failure(func (err int32) {
		rvReq:=&syscall.ReturnValueRequest{}
		rvReq.Bundle=&syscall.MethodBundle{}

		rvReq.Bundle.CallId= cid.Marshal()
		rvReq.Bundle.HostId= syscallguest.CurrentHostId().Marshal()
		rvReq.ResultError = err
		syscallguest.ReturnValue(ctx,rvReq) // nowhere for return value to go
	})
	return syscall.KernelErr_NoError

}

func {{$svcDiffFL}}bind(ctx context.Context,sid id.ServiceId, impl {{$svcCamel}}) (*lib.ServiceMethodMap, syscall.KernelErr) {
	smmap:=lib.NewServiceMethodMap()
	var mid id.MethodId
	var bindReq *syscall.BindMethodRequest
	var resp *syscall.BindMethodResponse
	var err syscall.KernelErr
{{- $goname:=packageToGoName .GetParent.Package}}
{{- range .GetWasmMethod}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $methCamelFL:=toCamelCaseFirstLower .WasmMethodName}}
{{- $dir :=call .FuncChoice.BindDirection .InputCodeNeeded .OutputCodeNeeded false false .}}
//
// {{.ProtoPackage}}.{{$svcCamel}}.{{$methCamel}}
//

	bindReq = &syscall.BindMethodRequest{}
	bindReq.HostId = syscallguest.CurrentHostId().Marshal()
	bindReq.ServiceId = sid.Marshal()
	bindReq.MethodName = "{{$methCamel}}"
	resp, err=syscallguest.BindMethod(ctx, bindReq)
	if err!=syscall.KernelErr_NoError {
		return nil, err
	}
	mid=id.UnmarshalMethodId(resp.GetMethodId())

	// completer already prepared elsewhere
	smmap.AddServiceMethod(sid,mid,"{{$svcCamel}}","{{$svcDiff}}{{$methCamel}}",
		Generate{{$svcDiff}}{{$methCamel}}Invoker(impl))

{{- end }} {{/* end of range over methods */}}
	return smmap,syscall.KernelErr_NoError
}

{{- /* range over methods again to do the generated refs */}}
{{- $goname:=packageToGoName .GetParent.Package}}
{{- $pkg:=toSnakeCase $goname}}
{{- $pkgFL:=toSnakeCaseFirstUpper $goname }}
{{- $svc:=toSnakeCase .GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}

// Locate finds a reference to the client interface of {{$svc}}.  
func Locate{{$svcDiff}}(ctx context.Context,sid id.ServiceId) (Client{{$svcDiff}},syscall.KernelErr) {
    cs, kerr:=client.LocateDynamic(ctx, "{{.ProtoPackage}}","{{$svc}}", sid)
    if kerr!=syscall.KernelErr_NoError{
        return nil, kerr
    }
    return &Client{{$svcDiff}}_{
        BaseService: cs,
    },syscall.KernelErr_NoError
}

func MustLocate{{$svcDiff}}(ctx context.Context, sid id.ServiceId) Client{{$svcDiff}} {
    result, err:=Locate{{$svcDiff}}(ctx, sid)
    name:=syscall.KernelErr_name[int32(err)]
    normal:="unable to locate {{.ProtoPackage}}.{{$svc}}:"+name
    if err!=0 {
        if err == syscall.KernelErr_NotRequired {
            guest.Log(ctx).Error("service was located, but it was not required")
            panic("locate attempted on a service that was not required")
        }
        panic(normal)
    }
    return result
}


func Register{{$svcDiff}}() (id.ServiceId, syscall.KernelErr){
    req := &syscall.RegisterRequest{}
	debugName:=fmt.Sprintf("%s.%s","{{.ProtoPackage}}","{{$svc}}")
	req.HostId = syscallguest.CurrentHostId().Marshal()
	req.DebugName = debugName

	resp, err := syscallguest.Register(context.Background(), req)
    if err!=syscall.KernelErr_NoError{
        return id.ServiceIdZeroValue(), err
    }
    sid:=id.UnmarshalServiceId(resp.ServiceId)
    if sid.IsZeroOrEmptyValue() {
        panic("received bad service Id from register")
    }

    return sid,syscall.KernelErr_NoError
}
func MustRegister{{$svcDiff}}() (context.Context,id.ServiceId) {
    sid, err:=Register{{$svcDiff}}()
    if err!=syscall.KernelErr_NoError {
        guest.Log(context.Background()).Error("unable to register","package","{{.ProtoPackage}}","service name","{{$svc}}")
        panic("unable to register "+"{{$svc}}")
    }
    return guest.NewContextWithLogger(sid), sid
}

func MustRequire{{$svcDiff}}(ctx context.Context, sid id.ServiceId) {
    _, err:=lib.Require1(ctx, "{{.ProtoPackage}}","{{$svc}}",sid)
    if err!=syscall.KernelErr_NoError {
        if err==syscall.KernelErr_DependencyCycle{
            guest.Log(ctx).Error("unable to require because it creates a dependcy loop","package","{{.ProtoPackage}}","service name","{{$svc}}","error",syscall.KernelErr_name[int32(err)])
            panic("require {{.ProtoPackage}}.{{$svc}} creates a dependency loop")
        }
        guest.Log(ctx).Error("unable to require","package","{{.ProtoPackage}}","service name","{{$svc}}","error",syscall.KernelErr_name[int32(err)])
        panic("not able to require {{.ProtoPackage}}.{{$svc}}:"+syscall.KernelErr_name[int32(err)])
    }
}

func MustExport{{$svcDiff}}(ctx context.Context, sid id.ServiceId) {
    _, err:=lib.Export1(ctx,"{{.ProtoPackage}}","{{$svc}}",sid)
    if err!=syscall.KernelErr_NoError{
        guest.Log(ctx).Error("unable to export","package","{{.ProtoPackage}}","service name","{{$svc}}")
        panic("not able to export {{.ProtoPackage}}.{{$svc}}:"+syscall.KernelErr_name[int32(err)])
    }
}

func LaunchService{{$svcDiff}}(ctx context.Context, sid id.ServiceId, impl {{$svcCamel}}) (*lib.ServiceMethodMap,*syscallguest.LaunchFuture,syscall.KernelErr) {
	smmap, err:={{$svcDiffFL}}bind(ctx,sid, impl)
	if err!=0{
		return  nil,nil,syscall.KernelErr(err)
	}
	cid:=id.NewCallId()
	req:=&syscall.LaunchRequest{
		ServiceId: sid.Marshal(),
		CallId: cid.Marshal(),
		HostId: syscallguest.CurrentHostId().Marshal(),
		MethodId: apishared.LaunchMethod.Marshal(),
	}
	fut:=syscallguest.Launch(ctx,req)

    return smmap,fut,syscall.KernelErr_NoError
}

func MustLaunchService{{$svcDiff}}(ctx context.Context, sid id.ServiceId, impl {{$svcCamel}}) (*lib.ServiceMethodMap, *syscallguest.LaunchFuture) {
    smmap,fut,err:=LaunchService{{$svcDiff}}(ctx,sid,impl)
    if err!=syscall.KernelErr_NoError {
        panic("Unable to call LaunchService successfully: "+syscall.KernelErr_name[int32(err)])
    }
    return smmap,fut
}


// If you want to implement part of your server in host cost you should call 
// {{$svcDiff}}<methodName>Host from your server implementation. These will be optimized 
// away by the compiler if you don't use them--in other words, if you want to 
// implement everything on the guest side).
//

{{- range .GetWasmMethod }}
{{- $methSnake:=toSnakeCase .WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}

{{- $hostFuncName:= $methCamel}}
{{- $hostFuncNameSnake:= $methSnake}}
{{- if ne .HostFuncName ""}} 
{{- $hostFuncName = .HostFuncName}}
{{- $hostFuncNameSnake = toSnakeCase .HostFuncName}}
{{- end }} {{/* end of if host func option used */}}

//go:wasmimport {{packageToGoName $pkg}} {{$hostFuncNameSnake}}{{$svcDiff}}_
func {{$hostFuncName}}_(int32,int32,int32,int32) int64
func {{$hostFuncName}}{{$svcDiff}}Host(ctx context.Context,inPtr *{{$iParam}}) *Future{{$svcDiff}}{{$methCamel}} {
	outProtoPtr := (*{{$oParam}})(nil)
	ret, raw, _:= syscallguest.ClientSide(ctx, inPtr, outProtoPtr, {{$methCamel}}_)
	f:=NewFuture{{$svcDiff}}{{$methCamel}}()
	f.CompleteMethod(ctx,ret,raw)
	return f
}
{{- end }}  {{/* end range over methods */}}

{{- range .GetWasmMethod }}
{{- $methSnake:=toSnakeCase .WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}
{{- $inParamDecl:=call .FuncChoice.InParamDecl .InputCodeNeeded .OutputCodeNeeded false false .}}

// This is interface for invocation.
type invoke{{$svcDiff}}{{$methCamel}} struct {
    fn func(context.Context,*{{$iParam}}) *Future{{$svcDiff}}{{$methCamel}}
}

func (t *invoke{{$svcDiff}}{{$methCamel}}) Invoke(ctx context.Context,a *anypb.Any) future.Completer {
{{- if .InputCodeNeeded }}
	// xxx {{$iParam}} and '{{$inParamDecl}}' why empty?
    in:=&{{$iParam}}{}
    err:=a.UnmarshalTo(in)
    if err!=nil {
        guest.Log(ctx).Error("unmarshal inside Invoke() failed","error",err.Error())
        return nil
    }
    return t.fn(ctx,in) 
{{- else }}
    return  t.fn(ctx,nil)
{{- end }} {{/* end of input needed */}}

}

func Generate{{$svcDiff}}{{$methCamel}}Invoker(impl {{$svcCamel}}) future.Invoker {
{{- if .InputCodeNeeded }}
	return &invoke{{$svcDiff}}{{$methCamel}}{fn:impl.{{$svcDiff}}{{$methCamel}}}
{{- else }}
	x:=func(ctx context.Context,_ *{{$iParam}}) *Future{{$svcDiff}}{{$methCamel}} {
		return impl.{{$svcDiff}}{{$methCamel}}(ctx)
	}
	return &invoke{{$svcDiff}}{{$methCamel}}{fn:x}

{{- end }} {{/* input code needed */}}
}

{{- end }} {{/*end of range over methods*/}}
{{- end }} {{/* range over services */}}
