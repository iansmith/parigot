// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}

{{$file:=.file}}
{{$package:=.package}}

import (
	"fmt"
	"context"
    "unsafe"

{{ range $j,$i := .import -}}
	{{$j -}}
{{- end}} {{/* imports */}}

	os "os"
    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
	"github.com/iansmith/parigot/g/msg/protosupport/v1"
	"github.com/iansmith/parigot/g/msg/syscall/v1"
	"github.com/iansmith/parigot/apiwasm/syscall"
	"github.com/iansmith/parigot/apiwasm/background"
	"github.com/iansmith/parigot/apishared/id"
	//"github.com/iansmith/parigot/apiwasm"  
	lib "github.com/iansmith/parigot/lib/go"  
	pcontext "github.com/iansmith/parigot/context"
	
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/anypb"

)
var _ =  unsafe.Sizeof([]byte{})

{{- $info:=.info }}
{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}

//
// {{$svcCamel}}Server (from {{$file}})
//

type {{$svcCamel}}Server interface {
{{range .GetWasmMethod }}

{{- $genTest:=call .FuncChoice.GenMethodPossibleTest . }}
{{- if eq false $genTest }} 
	//skipping {{.WasmMethodName}}(), not in test mode
    {{- continue -}}
{{- end}}


{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}

{{- if .InputCodeNeeded }}
	{{$methCamel}}(ctx context.Context,in *{{$iParam}}) 
{{- else }}
	{{$methCamel}}(ctx context.Context) 
{{- end }} 
{{- if .OutputCodeNeeded -}}
    (*{{$oParam}}, error)
{{- else -}}
    error
{{- end}} {{/* end of output code needed */}}
{{- end}} {{/* end of range over methods */}}
	Ready(ctx context.Context) bool
}
{{- end}} {{/* end of range over services */}}

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $svcCamelFL:=toCamelCaseFirstLower .GetWasmServiceName }}
{{- $svcLowerNoService:=toLowerNoService .GetWasmServiceName }}

//
// {{$svcCamel}} method ids
//
{{- range .GetWasmMethod }}

{{- $genTest:=call .FuncChoice.GenMethodPossibleTest . }}
{{- if eq false $genTest }} 
	//skipping {{.}}, not in test mode
    {{- continue}} 
{{- end}}

{{- $methCamelFL:=toCamelCaseFirstLower .WasmMethodName}}
var {{$methCamelFL}}Method id.Id
{{- end }} {{/* range over methods */}}


var {{$svcCamelFL}}ServerVerbose = true
var {{$svcCamelFL}}Background background.Background

func Run{{$svcCamel}}(impl {{$svcCamel}}Server) {
	// register all methods
	method, err := {{$svcCamelFL}}Bind(impl)
	if err != nil {
		panic("failed to register method successfully: " + method + ":" + err.Error())
	}
	// loop on handling calls
	for {
		//
		// wait for notification
		//
		resp,err := {{$svcCamelFL}}BlockUntilCall({{$svcCamelFL}}Background!=nil)
		if err != nil {
			// error is likely local to this process
			{{$svcCamelFL}}Print("RUN:primary for loop ", "Unable to dispatch method call: %v", err)
			continue
		}
		if resp.TimedOut{
			if {{$svcCamelFL}}Background==nil {
				continue
			}
			ctx:=pcontext.CallTo(pcontext.ServerWasmContext(context.Background()),"Background")
			{{$svcCamelFL}}Background.Background(ctx)
			pcontext.Dump(ctx)
			continue
		}
		mid := id.Unmarshal(resp.GetMethod())
		cid := id.Unmarshal(resp.GetCall())

		//
		// pick the method
		//
		var marshalError, execError error
		var out proto.Message
		switch {
{{- range .GetWasmMethod}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false true .}}

{{- $genTest:=call .FuncChoice.GenMethodPossibleTest . }}
{{- if eq false $genTest }} 
	//skipping {{.}}, not in test mode
    {{- continue}} 
{{- end}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $methCamelFL:=toCamelCaseFirstLower .WasmMethodName}}
		case mid.Equal({{$methCamelFL}}Method):
			ctx:=pcontext.CallTo(pcontext.ServerWasmContext(context.Background()),"{{$methCamelFL}}")

{{- if .InputCodeNeeded}}
			req := &{{$inParam}}{}
			marshalError = resp.GetParam().UnmarshalTo(req)
			if marshalError != nil {
				break
			}
{{- else}}
            // no input for this method
{{- end}}
{{- if .OutputCodeNeeded}}

{{- if .InputCodeNeeded}}
			out, execError = impl.{{$methCamel}}(ctx,req)
{{- else }}
			out, execError = impl.{{$methCamel}}(ctx)
{{- end }} {{/* end of input code needed for the call of the implementation */}}

{{- else}}
{{/* no need for checking input code needed here, because if that were false, 
you would have a method with no input or output, which is checked elsewhere */}}
            execError = impl.{{$methCamel}}(ctx,req)
{{- end}}
			pcontext.Dump(ctx)
			if execError != nil {
				break
			}
{{- end}} {{/*end of ranging over methods for the switch */}}
        }
		//
		// could be error, could be everything is cool
		ctx:=pcontext.CallTo(pcontext.ServerWasmContext(context.TODO()),"ReturnValue")
		a:=&anypb.Any{}
		err=a.MarshalFrom(out) 
		if err!=nil {
			pcontext.Errorf(ctx,"marshal failed:%v",err)
		}
		if execError!=nil {
			pcontext.Errorf(ctx,"exec failed:%v",execError)
		}
		retreq:=&syscallmsg.ReturnValueRequest{
			Call: id.Marshal[protosupportmsg.CallId](cid),
			Method: id.Marshal[protosupportmsg.MethodId](mid),
			Result: a,
			Pctx:nil,
			MarshalError: marshalError.Error(),
			ExecError: execError.Error(),
			// XXX this error setup needs to be fixed properly
			ExecErrorId: nil,
		}
		retresp,err:=syscall.ReturnValue(retreq)
		if err!=nil {
			pcontext.Errorf(ctx, "return value failed: %v",err)
		}
		if retresp.ExitAfterUse {
			os.Exit(2)
		}
		// about to loop again
	}
	// wont reach here
}


func {{$svcCamelFL}}Bind(impl {{$svcCamel}}Server) (string, error) {
{{- range .GetWasmMethod}}

{{- $genTest:=call .FuncChoice.GenMethodPossibleTest . }}
{{- if eq false $genTest }} 
	//skipping {{.WasmMethodName}}(), not in test mode
    {{- continue}} 
{{- end}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $methCamelFL:=toCamelCaseFirstLower .WasmMethodName}}
{{ $dir :=call .FuncChoice.BindDirection .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
	resp, {{$methCamelFL}}err := lib.BindMethod{{$dir}}(&syscallmsg.BindMethodRequest{
		ProtoPackage: "{{.ProtoPackage}}",
		Service:      "{{$svcCamel}}",
		Method:       "{{$methCamel}}",
	})
	//, impl.{{$methCamel}})
	if {{$methCamelFL}}err != nil {
		return "{{$methCamel}}", {{$methCamelFL}}err
	}
	{{$methCamelFL}}Method = id.Unmarshal(resp.GetMethodId())
{{- end }} {{/* end of rang over methods */}}
	ctx:=pcontext.CallTo(pcontext.ServerWasmContext(context.Background()),"Ready")
	if !impl.Ready(ctx){
		pcontext.Dump(ctx)
		panic("unable to start {{$svcCamel}} because it failed Ready() check")
	}
	pcontext.Dump(ctx)
	//var ok bool
	{{$svcCamelFL}}Background, _ = impl.(background.Background)
	//if !ok {
	//	print("{{$svcCamel}}Server not background\n")
	//}
	return "",nil
}

func {{$svcCamelFL}}TimedOut()  {
	print("{{$svcCamelFL}}TimedOut()\n")
}

func {{$svcCamelFL}}BlockUntilCall(canTimeout bool) (*syscallmsg.BlockUntilCallResponse,error) {
	req := &syscallmsg.BlockUntilCallRequest{CanTimeout:canTimeout}
	return syscall.BlockUntilCall(req)
}

func {{$svcCamelFL}}Print(method string, spec string, arg ...interface{}) {
	if {{$svcCamelFL}}ServerVerbose {
		part1 := fmt.Sprintf("{{$svcCamelFL}}Server:%s", method)
		part2 := fmt.Sprintf(spec, arg...)
		print(part1, part2, "\n")
	}
}

{{- /* range over methods again to do the generated refs */}}
{{- $goname:=packageToGoName .GetParent.Package}}
{{- $pkg:=toSnakeCase $goname}}
{{- $pkgFL:=toSnakeCaseFirstUpper $goname }}
{{- $svc:=toSnakeCase .GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
type Simple{{$svcCamel}} struct {
	fn func(context.Context,*Simple{{$svcCamel}}) bool
}
func NewSimple{{$svcCamel}} (fn func(context.Context, *Simple{{$svcCamel}}) bool) *Simple{{$svcCamel}} {
	return &Simple{{$svcCamel}}{
		fn: fn,
	}
}
func (s *Simple{{$svcCamel}}) Ready(ctx context.Context) bool {
	if s.fn != nil {
		return s.fn(ctx, s)
	}
	return true
}
{{- range .GetWasmMethod }}
{{- $methSnake:=toSnakeCase .WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}



//xxxgo:wasm-module {{packageToGoName $pkg}}
//xxxgo:export {{$methSnake}}
//xxxgo:linkname {{$methCamel}} {{packageToGoName $pkg}}.{{$methSnake}}
// host function: {{packageToGoName $pkg}} {{$methSnake}}_
//go:wasmimport {{packageToGoName $pkg}} {{$methSnake}}_
func {{$methCamel}}_(int32,int32) int32

// Wrapper around host function {{packageToGoName $pkg}} {{$methSnake}}_
{{- if .InputCodeNeeded }}
{{- if .OutputCodeNeeded }} 
func (s *Simple{{$svcCamel}}) {{$methCamel}}(ctx context.Context, in *{{$iParam}}) (*{{$oParam}},error) {
	out := &{{$oParam}}{}
	//err := apiwasm.WasmCallNativeInOut[*{{$iParam}}, *{{$oParam}}](in, out, {{$methCamel}}_)
{{- else }} {{/* other side of output code needed */}}
func (s *Simple{{$svcCamel}}) {{$methCamel}}(ctx context.Context, in *{{$iParam}}) {
	//err := apiwasm.WasmCallNativeIn[*{{$iParam}}, *{{$oParam}}](in, {{$methCamel}}_)
{{- end }} {{/* end of if output code needed */}}
{{- else }} {{/* other side of InputCodeNeeded */}}
func (s *Simple{{$svcCamel}}) {{$methCamel}}(ctx context.Context) (*{{$oParam}},error) {
	out := &{{$oParam}}{}
	//err := apiwasm.WasmCallNativeOut[*{{$iParam}}, *{{$oParam}}](out, {{$methCamel}}_)

{{- end }}  {{/* end of InputCodeNeeded */}}
//	if err != nil {
//		pcontext.LogFullf(ctx, pcontext.Error, pcontext.Client, "{{$methCamel}}_", "{{$methCamel}}_ failed:%v", err)
{{- if .OutputCodeNeeded }} 
//		return nil, err
//	}
	return out, nil
}
{{- else }} {{/*other side of output code needed*/}}
//	}
}
{{- end }}{{/* end of output code needed */}}


{{- end }}  {{/* end range over methods */}}

{{- end }} {{/* range over services */}}
