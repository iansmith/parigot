// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}

{{$file:=.file}}
{{$package:=.package}}

import (
	"fmt"
{{ range $j,$i := .import -}}
	{{$j -}}
{{- end}} {{/* imports */}}

	os "os"
    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
	"github.com/iansmith/parigot/g/msg/protosupport/v1"
	"github.com/iansmith/parigot/g/msg/syscall/v1"
	"github.com/iansmith/parigot/apiwasm/syscall"
	"github.com/iansmith/parigot/apiwasm/background"
	lib "github.com/iansmith/parigot/lib/go"
	
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/anypb"

)


{{- $info:=.info }}
{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}

//
// {{$svcCamel}}Server (from {{$file}})
//

type {{$svcCamel}}Server interface {
{{range .GetWasmMethod }}

{{- $genTest:=call .FuncChoice.GenMethodPossibleTest . }}
{{- if eq false $genTest }} 
	//skipping {{.WasmMethodName}}(), not in test mode
    {{- continue -}}
{{- end}}


{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- if .InputCodeNeeded }}
	{{$methCamel}}(pctx *protosupportmsg.Pctx, in proto.Message) 
{{- else }}
	{{$methCamel}}(pctx *protosupportmsg.Pctx) 
{{- end }} 
{{- if .OutputCodeNeeded -}}
    (proto.Message, error)
{{- else -}}
    error
{{- end}} {{/* end of output code needed */}}
{{- end}} {{/* end of range over methods */}}
	Ready() bool
}
{{- end}} {{/* end of range over services */}}

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $svcCamelFL:=toCamelCaseFirstLower .GetWasmServiceName }}
{{- $svcLowerNoService:=toLowerNoService .GetWasmServiceName }}

//
// {{$svcCamel}} method ids
//
{{- range .GetWasmMethod }}

{{- $genTest:=call .FuncChoice.GenMethodPossibleTest . }}
{{- if eq false $genTest }} 
	//skipping {{.}}, not in test mode
    {{- continue}} 
{{- end}}

{{- $methCamelFL:=toCamelCaseFirstLower .WasmMethodName}}
var {{$methCamelFL}}Method lib.Id
{{- end }} {{/* range over methods */}}


var {{$svcCamelFL}}ServerVerbose = true
var {{$svcCamelFL}}Background background.Background

func Run{{$svcCamel}}(impl {{$svcCamel}}Server) {
	// register all methods
	method, err := {{$svcCamelFL}}Bind(impl)
	if err != nil {
		panic("failed to register method successfully: " + method + ":" + err.Error())
	}
	// loop on handling calls
	for {
		//
		// wait for notification
		//
		resp := {{$svcCamelFL}}BlockUntilCall({{$svcCamelFL}}Background!=nil)
		if err != nil {
			// error is likely local to this process
			{{$svcCamelFL}}Print("RUN:primary for loop ", "Unable to dispatch method call: %v", err)
			continue
		}
		if resp.TimedOut{
			if {{$svcCamelFL}}Background==nil {
				continue
			}
			{{$svcCamelFL}}Background.Background()
			continue
		}
		//{{$svcCamelFL}}Print("RUN: primary for loop ", "block completed, got two values:pctx size %d, param size %d",
		//	proto.Size(resp.GetPctx()), proto.Size(resp.GetParam()))
		//
		// incoming values, pctx and params
		//
		mid := lib.Unmarshal(resp.GetMethod())
		cid := lib.Unmarshal(resp.GetCall())

		//
		// pick the method
		//
		var marshalError, execError error
		var out proto.Message
		switch {
{{- range .GetWasmMethod}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false true .}}

{{- $genTest:=call .FuncChoice.GenMethodPossibleTest . }}
{{- if eq false $genTest }} 
	//skipping {{.}}, not in test mode
    {{- continue}} 
{{- end}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $methCamelFL:=toCamelCaseFirstLower .WasmMethodName}}
		case mid.Equal({{$methCamelFL}}Method):
{{- if .InputCodeNeeded}}
			req := &{{$inParam}}{}
			marshalError = resp.GetParam().UnmarshalTo(req)
			if marshalError != nil {
				break
			}
{{- else}}
            // no input for this method
{{- end}}
{{- if .OutputCodeNeeded}}

{{- if .InputCodeNeeded}}
			out, execError = impl.{{$methCamel}}(resp.GetPctx(),req)
{{- else }}
			out, execError = impl.{{$methCamel}}(resp.GetPctx())
{{- end }} {{/* end of input code needed for the call of the implementation */}}

{{- else}}
{{/* no need for checking input code needed here, because if that were false, 
you would have a method with no input or output, which is checked elsewhere */}}
            execError = impl.{{$methCamel}}(resp.GetPctx(), req)
{{- end}}
			if execError != nil {
				break
			}
{{- end}} {{/*end of ranging over methods for the switch */}}
        }
		//
		// could be error, could be everything is cool
		a:=&anypb.Any{}
		err=a.MarshalFrom(out) 
		if err!=nil {
			marshalError=fmt.Errorf("error converting response for return value")
		}
		eid:=lib.NoError[*protosupportmsg.KernelErrorId]()
		if execError.Error()!="" {
			eid=lib.NewKernelError(lib.KernelExecError)
		}
		retreq:=&syscallmsg.ReturnValueRequest{
			Call: lib.Marshal[protosupportmsg.CallId](cid),
			Method: lib.Marshal[protosupportmsg.MethodId](mid),
			Result: a,
			Pctx:resp.GetPctx(),
			MarshalError: marshalError.Error(),
			ExecError: execError.Error(),
			// XXX this error setup needs to be fixed properly
			ExecErrorId: lib.Marshal[protosupportmsg.BaseId](eid),
		}
		retresp:=syscall.ReturnValue(retreq)
		if retresp.ExitAfterUse {
			os.Exit(2)
		}
		// about to loop again
	}
	// wont reach here
}


func {{$svcCamelFL}}Bind(impl {{$svcCamel}}Server) (string, error) {
{{- range .GetWasmMethod}}

{{- $genTest:=call .FuncChoice.GenMethodPossibleTest . }}
{{- if eq false $genTest }} 
	//skipping {{.WasmMethodName}}(), not in test mode
    {{- continue}} 
{{- end}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $methCamelFL:=toCamelCaseFirstLower .WasmMethodName}}
{{ $dir :=call .FuncChoice.BindDirection .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
	resp, {{$methCamelFL}}err := lib.BindMethod{{$dir}}(&syscallmsg.BindMethodRequest{
		ProtoPackage: "{{.ProtoPackage}}",
		Service:      "{{$svcCamel}}",
		Method:       "{{$methCamel}}",
	}, impl.{{$methCamel}})
	if {{$methCamelFL}}err != nil {
		return "{{$methCamel}}", {{$methCamelFL}}err
	}
	{{$methCamelFL}}Method = lib.Unmarshal(resp.GetMethodId())
{{- end }} {{/* end of rang over methods */}}
	if !impl.Ready(){
		panic("unable to start {{$svcCamel}} because it failed Ready() check")
	}
	//var ok bool
	{{$svcCamelFL}}Background, _ = impl.(background.Background)
	//if !ok {
	//	print("{{$svcCamel}}Server not background\n")
	//}
	return "",nil
}


func {{$svcCamelFL}}TimedOut()  {
	print("{{$svcCamelFL}}TimedOut()\n")
}

func {{$svcCamelFL}}BlockUntilCall(canTimeout bool) *syscallmsg.BlockUntilCallResponse {
	req := &syscallmsg.BlockUntilCallRequest{CanTimeout:canTimeout}
	resp:=syscall.BlockUntilCall(req)
	return resp
}

func {{$svcCamelFL}}Print(method string, spec string, arg ...interface{}) {
	if {{$svcCamelFL}}ServerVerbose {
		part1 := fmt.Sprintf("{{$svcCamelFL}}Server:%s", method)
		part2 := fmt.Sprintf(spec, arg...)
		print(part1, part2, "\n")
	}
}
{{- end }} {{/* range over services */}}
