// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file.Name}}

package {{ LastSegmentOfPackage .file.GetPackage }}

import (
	"fmt"
{{ range $j,$i := .import -}}
	{{$j -}}
{{- end}} {{/* imports */}}

    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
	"github.com/iansmith/parigot/g/msg/protosupport/v1"
	"github.com/iansmith/parigot/g/msg/syscall/v1"
	"github.com/iansmith/parigot/api_impl/syscall"
	lib "github.com/iansmith/parigot/lib/go"
	
	"google.golang.org/protobuf/proto"
	
)


{{- $info:=.info }}
{{- range .info.Service }}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}

//
// {{$svcCamel}}Server
//

type {{$svcCamel}}Server interface {
{{range .GetWasmMethod }}

{{- $genTest:=call .FuncChoice.GenMethodPossibleTest . }}
{{- if eq false $genTest }} 
	//skipping {{.WasmMethodName}}(), not in test mode
    {{- continue}}
{{- end}}


{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- if .InputCodeNeeded }}
	{{$methCamel}}(pctx *protosupportmsg.Pctx, in proto.Message) 
{{- else }}
	{{$methCamel}}(pctx *protosupportmsg.Pctx) 
{{- end }} 
{{- if .OutputCodeNeeded -}}
    (proto.Message, error)
{{- else -}}
    error
{{- end}} {{/* end of output code needed */}}
{{- end}} {{/* end of range over methods */}}
	Ready() bool
}
{{- end}} {{/* end of range over services */}}

{{- range .info.Service }}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $svcCamelFL:=toCamelCaseFirstLower .GetWasmServiceName }}
{{- $svcLowerNoService:=toLowerNoService .GetWasmServiceName }}

//
// {{$svcCamel}} method ids
//
{{- range .GetWasmMethod }}

{{- $genTest:=call .FuncChoice.GenMethodPossibleTest . }}
{{- if eq false $genTest }} 
	//skipping {{.}}, not in test mode
    {{- continue}} 
{{- end}}

{{- $methCamelFL:=toCamelCaseFirstLower .WasmMethodName}}
var {{$methCamelFL}}Method lib.Id
{{- end }} {{/* range over methods */}}


var {{$svcCamelFL}}ServerVerbose = false
var {{$svcCamelFL}}Call = syscall.NewCallImpl()

func Run(impl {{$svcCamel}}Server) {
	// register all methods
	method, err := {{$svcCamelFL}}Bind(impl)
	if err != nil {
		panic("failed to register method successfully: " + method + ":" + err.Error())
	}
	// loop on handling calls
	for {
		//
		// wait for notification
		//
		resp, err := {{$svcCamelFL}}BlockUntilCall()
		if err != nil {
			// error is likely local to this process
			{{$svcCamelFL}}Print("RUN:primary for loop ", "Unable to dispatch method call: %v", err)
			continue
		}
		{{$svcCamelFL}}Print("RUN: primary for loop ", "block completed, got two values:pctx size %d, param size %d",
			proto.Size(resp.GetPctx()), proto.Size(resp.GetParam()))
		//
		// incoming values, pctx and params
		//
		mid := lib.Unmarshal(resp.GetMethod())
		cid := lib.Unmarshal(resp.GetCall())

		//
		// pick the method
		//
		var marshalError, execError error
		var out proto.Message
		switch {
{{- range .GetWasmMethod}}

{{- $genTest:=call .FuncChoice.GenMethodPossibleTest . }}
{{- if eq false $genTest }} 
	//skipping {{.}}, not in test mode
    {{- continue}} 
{{- end}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $methCamelFL:=toCamelCaseFirstLower .WasmMethodName}}
		case mid.Equal({{$methCamelFL}}Method):
{{- if .InputCodeNeeded}}
			req := &{{$svcLowerNoService}}msg.{{$methCamel}}Request{}
			marshalError = resp.GetParam().UnmarshalTo(req)
			if marshalError != nil {
				break
			}
{{- else}}
            // no input for this method
{{- end}}
{{- if .OutputCodeNeeded}}

{{- if .InputCodeNeeded}}
			out, execError = impl.{{$methCamel}}(resp.GetPctx(),req)
{{- else }}
			out, execError = impl.{{$methCamel}}(resp.GetPctx())
{{- end }} {{/* end of input code needed for the call of the implementation */}}

{{- else}}
{{/* no need for checking input code needed here, because if that were false, 
you would have a method with no input or output, which is checked elsewhere */}}
            execError = impl.{{$methCamel}}(resp.GetPctx(), req)
{{- end}}
			if execError != nil {
				break
			}
{{- end}} {{/*end of ranging over methods for the switch */}}
        }
		//
		// could be error, could be everything is cool, send to lib to figure it out
		//
		lib.ReturnValueEncode({{$svcCamelFL}}Call, cid, mid, marshalError, execError, out, resp.GetPctx())
		// about to loop again
	}
	// wont reach here
}


func {{$svcCamelFL}}Bind(impl {{$svcCamel}}Server) (string, error) {
{{- range .GetWasmMethod}}

{{- $genTest:=call .FuncChoice.GenMethodPossibleTest . }}
{{- if eq false $genTest }} 
	//skipping {{.WasmMethodName}}(), not in test mode
    {{- continue}} 
{{- end}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $methCamelFL:=toCamelCaseFirstLower .WasmMethodName}}
{{ $dir :=call .FuncChoice.BindDirection .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
	resp, {{$methCamelFL}}err := {{$svcCamelFL}}Call.BindMethod{{$dir}}(&syscallmsg.BindMethodRequest{
		ProtoPackage: "{{.ProtoPackage}}",
		Service:      "{{$svcCamel}}",
		Method:       "{{$methCamel}}",
	}, impl.{{$methCamel}})
	if {{$methCamelFL}}err != nil {
		return "{{$methCamel}}", {{$methCamelFL}}err
	}
	{{$methCamelFL}}Method = lib.Unmarshal(resp.GetMethodId())
{{- end }} {{/* end of rang over methods */}}
	if !impl.Ready(){
		panic("unable to start {{$svcCamel}} because it failed Ready() check")
	}
	return "",nil
}

func {{$svcCamelFL}}BlockUntilCall() (*syscallmsg.BlockUntilCallResponse, error) {

	req := &syscallmsg.BlockUntilCallRequest{}
	resp, err := {{$svcCamelFL}}Call.BlockUntilCall(req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func {{$svcCamelFL}}Print(method string, spec string, arg ...interface{}) {
	if {{$svcCamelFL}}ServerVerbose {
		part1 := fmt.Sprintf("{{$svcCamelFL}}Server:%s", method)
		part2 := fmt.Sprintf(spec, arg...)
		print(part1, part2, "\n")
	}
}
{{- end }} {{/* range over services */}}
