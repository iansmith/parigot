// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}

{{$file:=.file}}
{{$package:=.package}}

import (
	"context"
	"io"
	"os"
	"sync"
    "unsafe"

{{ range $j,$i := .import -}}
	{{$j -}}
{{- end}} {{/* imports */}}

    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
	//"github.com/iansmith/parigot/g/msg/protosupport/v1"
	//"github.com/iansmith/parigot/g/msg/syscall/v1"
	//"github.com/iansmith/parigot/apiwasm/syscall"
	//"github.com/iansmith/parigot/apiwasm/background"
	"github.com/iansmith/parigot/apishared/id"
	"github.com/iansmith/parigot/apiwasm"  
	//lib "github.com/iansmith/parigot/lib/go"  
	pcontext "github.com/iansmith/parigot/context"
	
	//"google.golang.org/protobuf/proto"
	//"google.golang.org/protobuf/types/known/anypb"

)
var _ =  unsafe.Sizeof([]byte{})
{{- $info:=.info }}
{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}
var {{$svcCamel}}fsName = "/parigotvirt"

//
// {{$svcCamel}}Server (from {{$file}})
//

type {{$svcCamel}}Server interface {
{{range .GetWasmMethod }}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}

// {{$methCamel}} {{.InputCodeNeeded}} {{.OutputCodeNeeded}}
{{- if .InputCodeNeeded }}
	{{$methCamel}}(ctx context.Context,in *{{$iParam}}) 
{{- else }}
	{{$methCamel}}(ctx context.Context) 
{{- end }} 
{{- if .OutputCodeNeeded -}}
    (*{{$oParam}}, {{$errId}})
{{- else -}}
    {{$errId}}
{{- end}} {{/* end of output code needed */}}
{{- end}} {{/* end of range over methods */}}
	Ready(ctx context.Context) bool
}
{{- end}} {{/* end of range over services */}}

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $svcCamelFL:=toCamelCaseFirstLower .GetWasmServiceName }}
{{- $svcLowerNoService:=toLowerNoService .GetWasmServiceName }}

func Run{{$svcCamel}}(ctx context.Context, impl {{$svcCamel}}Server) {
	// wait until all the go routines are done
	var wg sync.WaitGroup
	err:={{$svcCamelFL}}Bind(ctx,impl,&wg)
	if err!=nil {
		pcontext.Errorf(ctx,"error returned from {{$svcCamel}}Bind:%v", err)
		return
	}
	wg.Wait()			
}


func {{$svcCamelFL}}Bind(ctx context.Context,impl {{$svcCamel}}Server, wg *sync.WaitGroup)  error {
	var fp io.Reader
	var err error
	var errId id.ErrIdResponse

{{- range .GetWasmMethod}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}


{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $methCamelFL:=toCamelCaseFirstLower .WasmMethodName}}
{{ $dir :=call .FuncChoice.BindDirection .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}

//
// {{.ProtoPackage}}.{{$methCamel}}
//
{{- if eq $dir "Both" }}
	fp, err=os.OpenFile("{{.ProtoPackage}}.{{$methCamel}}",os.O_CREATE | os.O_RDWR, 0600)
{{- else }} {{/* else of InOut */}}
{{- if eq $dir "Out" }}
	fp, err=os.OpenFile("{{.ProtoPackage}}.{{$methCamel}}",os.O_CREATE | os.O_WRONLY, 0200)
{{- else }} {{/* else of "Out */}}
	fp, err=os.OpenFile("{{.ProtoPackage}}.{{$methCamel}}",os.O_CREATE | os.O_RDONLY, 0400)
{{- end }} {{/* end of Out */}}
{{- end }} {{/* end of Both */}}
	if err!=nil {
		return  err
	}
{{- if eq $dir "Both" }}
	go func(c context.Context, rd io.Reader, wr io.Writer, impl {{$svcCamel}}Server, wg *sync.WaitGroup) {
		wg.Add(1)
		//
		// input and output
		//

		for {
			pcontext.Dump(c) // from last iteration
			var msg {{$iParam}}
			bpi := apiwasm.NewBytePipeIn[*{{$iParam}}](ctx, rd)
			bpo := apiwasm.NewBytePipeOut[*{{$oParam}}](ctx, wr)

			errIdResult:=id.KernelErrIdNoErr.Raw() // just to create an empty space
			err =bpi.ReadProto(&msg,&errIdResult)
			if err!=nil {
				if err==apiwasm.ErrSignalExit{
					break
				}
				pcontext.Fatalf(c,"error in '{{.ProtoPackage}}.{{$methCamel}}' reading next message: %v",err)
				break
			}
			if errIdResult.IsError() {
				pcontext.Errorf(c,"error id received (%s),not calling '{{.ProtoPackage}}.{{$methCamel}}'",errIdResult.String())
				continue
			}
			pcontext.Infof(c,"Read in a new request of type: %s","{{$iParam}}")
			var resp *{{$oParam}}
			resp, errId = impl.{{$methCamel}}(c, &msg)
			if errId.IsError() {
				pcontext.Errorf(c,"Error returned from {{$methCamel}}: %v",errId.Short())				
				if err:=bpo.WriteProto(nil,errId.Raw()); err!=nil {
					pcontext.Errorf(c,"Error writing errId response in {{$methCamel}}: %v",err)
				}
				continue
			}
			if err:=bpo.WriteProto(resp,errId.Raw()); err!=nil {
				pcontext.Errorf(c,"Error writing proto response in {{$methCamel}}: %v",err)
				continue
			}
		}
		wg.Wait()
		pcontext.Errorf(c,"service {{$svc}} has had all go routines stop")
		pcontext.Dump(c)
	}(ctx,fp,fp.(io.Writer),impl,wg)
{{- else }} {{/* else of Both */}}
{{- if eq $dir "In" }}
	//
	// input only
	//

	go func(c context.Context, rd io.Reader, wr io.Writer, impl {{$svcCamel}}Server, wg *sync.WaitGroup) {
		wg.Add(1)
		for {
			pcontext.Dump(c) // from last iteration
			var msg {{$iParam}}
			bpi := apiwasm.NewBytePipeIn[*{{$iParam}}](ctx, rd)
			bpo := apiwasm.NewBytePipeOut[*{{$oParam}}](ctx, wr)

			errIdResult:=id.KernelErrIdNoErr.Raw() // just to create an empty space
			err =bpi.ReadProto(&msg,&errIdResult)
			if err!=nil {
				if err==apiwasm.ErrSignalExit{
					break
				}
				pcontext.Fatalf(c,"error in '{{.ProtoPackage}}.{{$methCamel}}' reading next message: %v",err)
				break
			}
			if errIdResult.IsError() {
				pcontext.Errorf(c,"error id received (%s),not calling '{{.ProtoPackage}}.{{$methCamel}}'",errIdResult.String())
				continue
			}
			pcontext.Infof(c,"Read in a new request of type: %s","{{$iParam}}")
			errId = impl.{{$methCamel}}(c, &msg)
			if errId.IsError() {
				pcontext.Errorf(c,"Error returned from {{$methCamel}}: %v",errId.Short())				
				if err:=bpo.WriteProto(nil,errId.Raw()); err!=nil {
					pcontext.Errorf(c,"Error writing errId response in {{$methCamel}}: %v",err)
				}
				continue
			}
		}
		wg.Wait()
		pcontext.Errorf(c,"service {{$svc}} has had all go routines stop")
		pcontext.Dump(c)
	}(ctx,fp,fp.(io.Writer),impl,wg)
{{- else }} {{/* else of "In */}}
	go func(c context.Context,wr io.Writer, impl {{$svcCamel}}Server, wg *sync.WaitGroup) {
		wg.Add(1)
		//
		// output only
		//

		for {
			pcontext.Dump(c) // from last iteration
			bpo := apiwasm.NewBytePipeOut[*{{$oParam}}](ctx, wr)
			var resp *{{$oParam}}
			resp, errId = impl.{{$methCamel}}(c)
			if errId.IsError() {
				pcontext.Errorf(c,"Error returned from {{$methCamel}}: %v",errId.Short())				
				if err:=bpo.WriteProto(nil,errId.Raw()); err!=nil {
					pcontext.Errorf(c,"Error writing errId response in {{$methCamel}}: %v",err)
				}
				continue
			}
			if err:=bpo.WriteProto(resp,errId.Raw()); err!=nil {
				pcontext.Errorf(c,"Error writing proto response in {{$methCamel}}: %v",err)
				continue
			}
		}
		wg.Wait()
		pcontext.Errorf(c,"service {{$svc}} has had all go routines stop, giving up")
		pcontext.Dump(c)
	}(ctx,fp.(io.Writer),impl,wg)
{{- end }} {{/* end of In */}}
{{- end }} {{/* end of InOut */}}

{{- end }} {{/* end of range over methods */}}
	pcontext.Dump(ctx)
	return nil
}

{{- /* range over methods again to do the generated refs */}}
{{- $goname:=packageToGoName .GetParent.Package}}
{{- $pkg:=toSnakeCase $goname}}
{{- $pkgFL:=toSnakeCaseFirstUpper $goname }}
{{- $svc:=toSnakeCase .GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}


type Wrap{{$svcCamel}} struct {
	ctx context.Context
	readyFunc func(context.Context,*Simple{{$svcCamel}}) bool
}
func NewSimple{{$svcCamel}} (ctx context.Context, fn func(context.Context,*Simple{{$svcCamel}})bool) *Simple{{$svcCamel}} {
	return &Simple{{$svcCamel}}{
		ctx: ctx,
		readyFunc: fn,
	}
}
{{- range .GetWasmMethod }}
{{- $methSnake:=toSnakeCase .WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}

//go:wasmimport {{packageToGoName $pkg}} {{$methSnake}}_
func {{$methCamel}}_(int32,int32) int32

// Wrapper around host function {{packageToGoName $pkg}} {{$methSnake}}_
{{- if .InputCodeNeeded }}
{{- if .OutputCodeNeeded }} 
func (s *Simple{{$svcCamel}}) {{$methCamel}}(ctx context.Context, in *{{$iParam}}) (*{{$oParam}},{{$errId}}) {
	out := &{{$oParam}}{}
	//err := apiwasm.WasmCallNativeInOut[*{{$iParam}}, *{{$oParam}}](in, out, {{$methCamel}}_)
{{- else }} {{/* other side of output code needed */}}
func (s *Simple{{$svcCamel}}) {{$methCamel}}(ctx context.Context, in *{{$iParam}}) {{$errId}} {
	//err := apiwasm.WasmCallNativeIn[*{{$iParam}}, *{{$oParam}}](in, {{$methCamel}}_)
{{- end }} {{/* end of if output code needed */}}
{{- else }} {{/* other side of InputCodeNeeded */}}
func (s *Simple{{$svcCamel}}) {{$methCamel}}(ctx context.Context) (*{{$oParam}},{{$errId}}) {
	out := &{{$oParam}}{}
	//err := apiwasm.WasmCallNativeOut[*{{$iParam}}, *{{$oParam}}](out, {{$methCamel}}_)
{{- end }}  {{/* end of InputCodeNeeded */}}
//	if err != nil {
//		pcontext.LogFullf(ctx, pcontext.Error, pcontext.Client, "{{$methCamel}}_", "{{$methCamel}}_ failed:%v", err)
{{- if .OutputCodeNeeded }} 
//		return nil, {{$errId}}NoErr
//	}
	return out, {{$errId}}NoErr
}
{{- else }} {{/*other side of output code needed*/}}
//	}
}
{{- end }}{{/* end of output code needed */}}


{{- end }}  {{/* end range over methods */}}
func (s *Simple{{$svcCamel}}) Ready(ctx context.Context) bool {
	if s.readyFunc!=nil {
		return s.readyFunc(ctx,s)
	}
	return true
}

{{- end }} {{/* range over services */}}
