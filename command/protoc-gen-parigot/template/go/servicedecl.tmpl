//go:build wasip1 

// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}
{{ $file:=.file}}
{{ $package:=.package}}
import(
    "context"

{{- range $j,$i := .import }}
{{ if ne $j "" }}
    {{$j}}
{{ end }}
{{- end}} {{/* imports */}}
{{- $info:=.info }}

    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
    lib "github.com/iansmith/parigot/lib/go"  
    pcontext "github.com/iansmith/parigot/context"  
    "github.com/iansmith/parigot/apishared/id"  
    syscall "github.com/iansmith/parigot/g/syscall/v1" 
    syscallguest "github.com/iansmith/parigot/apiwasm/syscall" 
)   

{{ $needServiceDifferentiation:=true }}
{{ $svcLen := len .service }}
{{- if eq $svcLen 1 }}
{{- $needServiceDifferentiation = false}}
{{- end}}

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId}}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $svcDiff:=""}}
{{if $needServiceDifferentiation}}
{{- $svcDiff = $svcCamel }}
{{end}}

//
// {{$svcCamel}} from {{$file}}
//
//service interface
type {{$svcCamel}} interface {
{{- range .GetWasmMethod}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $iParam:=.InputParam.CGType.String $package}}
{{- $oParam:=.OutputParam.CGType.String $package}}
{{- if .InputCodeNeeded }}
    {{$svcDiff}}{{$methCamel}}(ctx context.Context,in *{{$iParam}}) 
{{- else }} 
    {{$svcDiff}}{{$methCamel}}(ctx context.Context) 
{{- end -}} 
{{- if .OutputCodeNeeded -}}
    (*{{$oParam}}, {{$errId}}) 
{{- else -}}
    {{$errId}}
{{- end -}} {{/* end of output code needed for declaration */}}
{{- end }} {{/* end of range over methods */}}
}
//client interface
type Client{{$svcDiff}} interface {
{{- range .GetWasmMethod}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $iParam:=.InputParam.CGType.String $package}}
{{- $oParam:=.OutputParam.CGType.String $package}}
{{- if .InputCodeNeeded }}
    {{$svcDiff}}{{$methCamel}}(ctx context.Context,in *{{$iParam}}) 
{{- else }} 
    {{$svcDiff}}{{$methCamel}}(ctx context.Context) 
{{- end -}} 
    *Future{{$svcDiff}}{{$methCamel}}
{{- end }} {{/* end of range over methods */}}

}
{{- end}} {{/* closes service, the interface stuff*/}}

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=.GetWasmServiceName }}
{{- $svcCamelFL:=toCamelCaseFirstLower .GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}
{{- $svcDiff:=""}}
{{- $svcDiffFL:=""}}
{{if $needServiceDifferentiation}}
{{- $svcDiff = $svcCamel }}
{{- $svcDiffFL = $svcCamelFL }}
{{end}}
type Client{{$svcDiff}}_ struct {
    *lib.ClientSideService
}


// Locate finds a reference to the client interface of {{$svc}}.  
func Locate{{$svcDiff}}(ctx context.Context,sid id.ServiceId) (Client{{$svcDiff}},syscall.KernelErr) {
    cs, kerr:=lib.LocateDynamic(ctx, "{{.ProtoPackage}}","{{$svc}}", sid)
    if kerr!=syscall.KernelErr_NoError{
        return nil, kerr
    }
    return &Client{{$svcDiff}}_{
        ClientSideService: cs,
    },syscall.KernelErr_NoError
}

func MustLocate{{$svcDiff}}(ctx context.Context, sid id.ServiceId) Client{{$svcDiff}} {
    result, err:=Locate{{$svcDiff}}(ctx, sid)
    name:=syscall.KernelErr_name[int32(err)]
    normal:="unable to locate {{.ProtoPackage}}.{{$svc}}:"+name
    if err!=0 {
        pcontext.Debugf(ctx,"kernel error was  %s",name)
        if err == syscall.KernelErr_NotRequired {
            pcontext.Errorf(ctx,"service was located, but it was not required")
            panic("locate attempted on a service that was not required")
        }
        panic(normal)
    }
    return result
}

func Register{{$svcDiff}}(ctx context.Context) (id.ServiceId, syscall.KernelErr){
    req := &syscall.RegisterRequest{}
	fqs := &syscall.FullyQualifiedService{
		PackagePath: "{{.ProtoPackage}}",
		Service:     "{{$svc}}",
	}
	req.Fqs = fqs
    req.IsClient = false

	resp, err := syscallguest.Register(req)
    if err!=syscall.KernelErr_NoError{
        return id.ServiceIdZeroValue(), err
    }
    sid:=id.UnmarshalServiceId(resp.Id)
    if sid.IsZeroOrEmptyValue() {
        panic("received bad service Id from register")
    }

    return sid,syscall.KernelErr_NoError
}
func MustRegister{{$svcDiff}}(ctx context.Context) id.ServiceId {
    sid, err:=Register{{$svcDiff}}(ctx)
    if err!=syscall.KernelErr_NoError {
        pcontext.Fatalf(ctx,"unable to register %s.%s","{{.ProtoPackage}}","{{$svc}}")
        panic("unable to register "+"{{$svc}}")
    }
    return sid
}

func MustRequire{{$svcDiff}}(ctx context.Context, sid id.ServiceId) {
    _, err:=lib.Require1("{{.ProtoPackage}}","{{$svc}}",sid)
    if err!=syscall.KernelErr_NoError {
        if err==syscall.KernelErr_DependencyCycle{
            pcontext.Errorf(ctx,"unable to require %s.%s because it creates a dependcy loop: %s","{{.ProtoPackage}}","{{$svc}}",syscall.KernelErr_name[int32(err)])
            panic("require {{.ProtoPackage}}.{{$svc}} creates a dependency loop")
        }
        pcontext.Errorf(ctx,"unable to require %s.%s:%s","{{.ProtoPackage}}","{{$svc}}",syscall.KernelErr_name[int32(err)])
        panic("not able to require {{.ProtoPackage}}.{{$svc}}:"+syscall.KernelErr_name[int32(err)])
    }
}

func MustExport{{$svcDiff}}(ctx context.Context) {
    _, err:=lib.Export1("{{.ProtoPackage}}","{{$svc}}")
    if err!=syscall.KernelErr_NoError{
        pcontext.Fatalf(ctx, "unable to export %s.%s","{{.ProtoPackage}}","{{$svc}}")
        panic("not able to export {{.ProtoPackage}}.{{$svc}}:"+syscall.KernelErr_name[int32(err)])
    }
}

func WaitSatisfied{{$svcDiff}}(ctx context.Context, sid id.ServiceId, impl Server{{$svcDiff}}) (*lib.ServiceMethodMap,syscall.KernelErr) {
	smmap, err:={{$svcDiffFL}}bind(ctx,sid, impl)
	if err!=0{
		return  nil,syscall.KernelErr(err)
	}

    s:=sid.Marshal()
	syscallguest.Launch(&syscall.LaunchRequest{ServiceId:s })

    return smmap,syscall.KernelErr_NoError
}

func MustWaitSatisfied{{$svcDiff}}(ctx context.Context, sid id.ServiceId, impl Server{{$svcDiff}}) *lib.ServiceMethodMap {
    smmap,err:=WaitSatisfied{{$svcDiff}}(ctx,sid,impl)
    if err!=syscall.KernelErr_NoError {
        panic("Unable to call WaitSatisfied successfully: "+syscall.KernelErr_name[int32(err)])
    }
    return smmap
}

{{range .GetWasmMethod}}

{{- $meth:=.WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inbound:=call .FuncChoice.Inbound .InputCodeNeeded .OutputCodeNeeded false false . }}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParamDecl:=call .FuncChoice.OutParamDecl .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $dispatchResult:=call .FuncChoice.DispatchResult .InputCodeNeeded .OutputCodeNeeded false false .}}

//
// method: {{$svcCamel}}.{{$methCamel}}  ({{$svcDiff}})
//

type Future{{$svcDiff}}{{$methCamel}} struct {
    *lib.Future
}

{{- if .OutputCodeNeeded}}
func (f *Future{{$svcDiff}}{{$methCamel}})Success(sfn func ({{$outParam}})) {
    f.Future = lib.NewFuture[{{$outParam}},{{$errId}}](sfn,nil)
} 
{{- end }} {{/* end of output code needed*/}}

func (f *Future{{$svcDiff}}{{$methCamel}})Failure(ffn func ({{$errId}})) {
{{- if .OutputCodeNeeded}}
    f.Future = lib.NewFuture[{{$outParam}},{{$errId}}](nil,ffn)
{{- else }}
    f.Future = lib.NewFuture[any,{{$errId}}](nil,ffn)
{{- end }} {{/* end of output code needed*/}}
}

{{- if .OutputCodeNeeded}}
func Future1{{$svcDiff}}{{$methCamel}}Success[T any](fn func({{$outParam}}, T),t T) func({{$outParam}}) {
    return func(e {{$outParam}}){
        fn(e,t)
    }
}
func Future2{{$svcDiff}}{{$methCamel}}Success[T any,U any](fn func({{$outParam}}, T, U),t T, u U) func({{$outParam}}) {
    return func(e {{$outParam}}){
        fn(e,t,u)
    }
}
func Future3{{$svcDiff}}{{$methCamel}}Success[T any,U any,V any](fn func({{$outParam}}, T, U, V), t T, u U, v V) func({{$outParam}}) {
    return func(e {{$outParam}}){
        fn(e,t,u,v)
    }
}
{{- end }} {{/*output code needed */}}

func Future1{{$svcDiff}}{{$methCamel}}Failure[T any](fn func({{$errId}}, T),t T) func({{$errId}}) {
    return func(e {{$errId}}){
        fn(e,t)
    }
}
func Future2{{$svcDiff}}{{$methCamel}}Failure[T any,U any](fn func({{$errId}}, T, U),t T, u U) func({{$errId}}) {
    return func(e {{$errId}}){
        fn(e,t,u)
    }
}
func Future3{{$svcDiff}}{{$methCamel}}Failure[T any,U any,V any](fn func({{$errId}}, T, U, V), t T, u U, v V) func({{$errId}}) {
    return func(e {{$errId}}){
        fn(e,t,u,v)
    }
}

func NewFuture{{$svcDiff}}{{$methCamel}}() *Future{{$svcDiff}}{{$methCamel}} {
    f:= &Future{{$svcDiff}}{{$methCamel}}{
{{- if .OutputCodeNeeded }}
        Future: lib.NewFuture[{{$outParam}},{{$errId}}](nil,nil),
    }
{{- else }}
        Future: lib.NewFuture[any,{{$errId}}](nil,nil),
    }
{{- end }} {{/* output code needed */}}
    return f    
}

func NewFuture{{$svcDiff}}{{$methCamel}}Error(e {{$errId}}) *Future{{$svcDiff}}{{$methCamel}} {
    f:=&Future{{$svcDiff}}{{$methCamel}}{
        Future: lib.NewFuture[any,{{$errId}}](nil,nil),
    }
    f.Future.CompleteCall(nil,int32(e))
    return f
}

{{- if .OutputCodeNeeded}}
func NewFuture{{$svcDiff}}{{$methCamel}}Value(x {{$outParam}}) *Future{{$svcDiff}}{{$methCamel}} {
    f:=&Future{{$svcDiff}}{{$methCamel}}{
        Future: lib.NewFuture[{{$outParam}},int32](nil,nil),
    }
    f.Future.CompleteCall(x,0)
    return f
}
{{- end }} {{/* end of output code needed */}}

{{- if .InputCodeNeeded }}
func (i *Client{{$svcDiff}}_) {{$svcDiff}}{{$methCamel}}(ctx context.Context, in {{$inParam}}) *Future{{$svcDiff}}{{$methCamel}} {
{{- else }}
func (i *Client{{$svcDiff}}_) {{$svcDiff}}{{$methCamel}}(ctx context.Context) *Future{{$svcDiff}}{{$methCamel}} {
{{- end }} {{/* end of input needed */}}
    mid, ok := i.ClientSideService.MethodIdByName("{{.WasmMethodName}}")
    if!ok {
        return NewFuture{{$svcDiff}}{{$methCamel}}Error({{$errId}}(1))
    }
{{- if .InputCodeNeeded }}
    cid,kerr:= i.ClientSideService.Dispatch(mid,{{$inbound}})
{{- else }}
    cid,kerr:= i.ClientSideService.Dispatch(mid,nil)
{{- end }} {{/* end of input needed */}}
    if kerr!=syscall.KernelErr_NoError{
        return NewFuture{{$svcDiff}}{{$methCamel}}Error({{$errId}}(1))
     }
    f:=NewFuture{{$svcDiff}}{{$methCamel}}()
    lib.AddMatchingFuture(cid,f.Future)
    return f
}
{{- end}} {{/*ranging over methods*/}}
{{- end}} {{/*ranging over services*/}}
