//go:build wasip1 

// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}
{{ $file:=.file}}
{{ $package:=.package}}
import(
    "context"

{{- range $j,$i := .import }}
{{ if ne $j "" }}
    {{$j}}
{{ end }}
{{- end}} {{/* imports */}}
{{- $info:=.info }}

    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
    lib "github.com/iansmith/parigot/lib/go"  
    "github.com/iansmith/parigot/lib/go/future"  
    "github.com/iansmith/parigot/lib/go/client"  
    pcontext "github.com/iansmith/parigot/context"  
    "github.com/iansmith/parigot/apishared/id"  
    syscall "github.com/iansmith/parigot/g/syscall/v1" 
    syscallguest "github.com/iansmith/parigot/apiwasm/syscall" 

    "google.golang.org/protobuf/types/known/anypb"

)   

{{ $needServiceDifferentiation:=true }}
{{ $svcLen := len .service }}
{{- if eq $svcLen 1 }}
{{- $needServiceDifferentiation = false}}
{{- end}} {{/* end of need differentiation check */}}

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId}}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $svcDiff := ""}}
{{if $needServiceDifferentiation}}
{{- $svcDiff = $svcCamel }}
{{end}} {{/*end of service iter */}}

//
// {{$svcCamel}} from {{$file}}
//
//service interface
type {{$svcCamel}} interface {
{{- range .GetWasmMethod}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $iParam:=.InputParam.CGType.String $package}}
{{- $oParam:=.OutputParam.CGType.String $package}}
{{- if .InputCodeNeeded }}
    {{$svcDiff}}{{$methCamel}}(ctx context.Context,in *{{$iParam}}) 
{{- else }} 
    {{$svcDiff}}{{$methCamel}}(ctx context.Context) 
{{- end -}}  {{/* end of input needed */}}
    *Future{{$svcDiff}}{{$methCamel}}
{{- end }} {{/* end of range over methods */}}
}

//client interface
type Client{{$svcDiff}} interface {
{{- range .GetWasmMethod}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $iParam:=.InputParam.CGType.String $package}}
{{- $oParam:=.OutputParam.CGType.String $package}}
{{- if .InputCodeNeeded }}
    {{$svcDiff}}{{$methCamel}}(ctx context.Context,in *{{$iParam}}) *Future{{$svcDiff}}{{$methCamel}}
{{- else }} 
    {{$svcDiff}}{{$methCamel}}(ctx context.Context) *Future{{$svcDiff}}{{$methCamel}}
{{- end -}} 
{{- end }} {{/* end of range over methods */}}
}

{{- end}} {{/* closes service, the interface stuff*/}}

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=.GetWasmServiceName }}
{{- $svcCamelFL:=toCamelCaseFirstLower .GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}
{{- $svcDiff:=""}}
{{- $svcDiffFL:=""}}
{{if $needServiceDifferentiation}}
{{- $svcDiff = $svcCamel }}
{{- $svcDiffFL = $svcCamelFL }}
{{end}}
type Client{{$svcDiff}}_ struct {
    *client.BaseService
}


// Locate finds a reference to the client interface of {{$svc}}.  
func Locate{{$svcDiff}}(ctx context.Context,sid id.ServiceId) (Client{{$svcDiff}},syscall.KernelErr) {
    cs, kerr:=client.LocateDynamic(ctx, "{{.ProtoPackage}}","{{$svc}}", sid)
    if kerr!=syscall.KernelErr_NoError{
        return nil, kerr
    }
    return &Client{{$svcDiff}}_{
        BaseService: cs,
    },syscall.KernelErr_NoError
}

func MustLocate{{$svcDiff}}(ctx context.Context, sid id.ServiceId) Client{{$svcDiff}} {
    result, err:=Locate{{$svcDiff}}(ctx, sid)
    name:=syscall.KernelErr_name[int32(err)]
    normal:="unable to locate {{.ProtoPackage}}.{{$svc}}:"+name
    if err!=0 {
        pcontext.Debugf(ctx,"kernel error was  %s",name)
        if err == syscall.KernelErr_NotRequired {
            pcontext.Errorf(ctx,"service was located, but it was not required")
            panic("locate attempted on a service that was not required")
        }
        panic(normal)
    }
    return result
}

func Register{{$svcDiff}}(ctx context.Context) (id.ServiceId, syscall.KernelErr){
    req := &syscall.RegisterRequest{}
	fqs := &syscall.FullyQualifiedService{
		PackagePath: "{{.ProtoPackage}}",
		Service:     "{{$svc}}",
	}
	req.Fqs = fqs
    req.IsClient = false

	resp, err := syscallguest.Register(req)
    if err!=syscall.KernelErr_NoError{
        return id.ServiceIdZeroValue(), err
    }
    sid:=id.UnmarshalServiceId(resp.Id)
    if sid.IsZeroOrEmptyValue() {
        panic("received bad service Id from register")
    }

    return sid,syscall.KernelErr_NoError
}
func MustRegister{{$svcDiff}}(ctx context.Context) id.ServiceId {
    sid, err:=Register{{$svcDiff}}(ctx)
    if err!=syscall.KernelErr_NoError {
        pcontext.Fatalf(ctx,"unable to register %s.%s","{{.ProtoPackage}}","{{$svc}}")
        panic("unable to register "+"{{$svc}}")
    }
    return sid
}

func MustRequire{{$svcDiff}}(ctx context.Context, sid id.ServiceId) {
    _, err:=lib.Require1("{{.ProtoPackage}}","{{$svc}}",sid)
    if err!=syscall.KernelErr_NoError {
        if err==syscall.KernelErr_DependencyCycle{
            pcontext.Errorf(ctx,"unable to require %s.%s because it creates a dependcy loop: %s","{{.ProtoPackage}}","{{$svc}}",syscall.KernelErr_name[int32(err)])
            panic("require {{.ProtoPackage}}.{{$svc}} creates a dependency loop")
        }
        pcontext.Errorf(ctx,"unable to require %s.%s:%s","{{.ProtoPackage}}","{{$svc}}",syscall.KernelErr_name[int32(err)])
        panic("not able to require {{.ProtoPackage}}.{{$svc}}:"+syscall.KernelErr_name[int32(err)])
    }
}

func MustExport{{$svcDiff}}(ctx context.Context) {
    _, err:=lib.Export1("{{.ProtoPackage}}","{{$svc}}")
    if err!=syscall.KernelErr_NoError{
        pcontext.Fatalf(ctx, "unable to export %s.%s","{{.ProtoPackage}}","{{$svc}}")
        panic("not able to export {{.ProtoPackage}}.{{$svc}}:"+syscall.KernelErr_name[int32(err)])
    }
}

func WaitSatisfied{{$svcDiff}}(ctx context.Context, sid id.ServiceId, impl Server{{$svcDiff}}) (*lib.ServiceMethodMap,syscall.KernelErr) {
	smmap, err:={{$svcDiffFL}}bind(ctx,sid, impl)
	if err!=0{
		return  nil,syscall.KernelErr(err)
	}

    s:=sid.Marshal()
	syscallguest.Launch(&syscall.LaunchRequest{ServiceId:s })

    return smmap,syscall.KernelErr_NoError
}

func MustWaitSatisfied{{$svcDiff}}(ctx context.Context, sid id.ServiceId, impl Server{{$svcDiff}}) *lib.ServiceMethodMap {
    smmap,err:=WaitSatisfied{{$svcDiff}}(ctx,sid,impl)
    if err!=syscall.KernelErr_NoError {
        panic("Unable to call WaitSatisfied successfully: "+syscall.KernelErr_name[int32(err)])
    }
    return smmap
}

{{range .GetWasmMethod}}

{{- $meth:=.WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inbound:=call .FuncChoice.Inbound .InputCodeNeeded .OutputCodeNeeded false false . }}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParamDecl:=call .FuncChoice.OutParamDecl .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $dispatchResult:=call .FuncChoice.DispatchResult .InputCodeNeeded .OutputCodeNeeded false false .}}

//
// method: {{$svcCamel}}.{{$methCamel}}  ({{$svcDiff}})
//

{{- if .OutputCodeNeeded }}
type Future{{$svcDiff}}{{$methCamel}} struct {
    method *future.Method[{{$outParam}},{{$errId}}]
}
{{- else}}
type Future{{$svcDiff}}{{$methCamel}} struct {
    base *future.Base[{{$errId}}]
}
{{- end }} {{/*end of output code needed */}}

// This is the same API for output needed or not because of the Completer interface.
func (f * Future{{$svcDiff}}{{$methCamel}}) CompleteMethod(a *anypb.Any, e int32) {
{{- if .OutputCodeNeeded }}
    result:= &{{$outParamDecl}}
    err:=a.UnmarshalTo(result)
    if err!=nil {
        panic("unable to unmarshal data for use in a future being completed")
    }
    f.method.CompleteMethod(result,{{$errId}}(e))
{{- else }}
    f.base.Set({{$errId}}(e))
{{- end }}
}

{{- if .OutputCodeNeeded}}
func (f *Future{{$svcDiff}}{{$methCamel}})Success(sfn func ({{$outParam}})) {
    f.method.Success(sfn)
} 
{{- end }} {{/* end of output code needed*/}}

func (f *Future{{$svcDiff}}{{$methCamel}})Failure(ffn func ({{$errId}})) {
{{- if .OutputCodeNeeded}}
    f.method.Failure(ffn)
{{- else }}
    f.base.Handle(ffn)
{{- end }} {{/* end of output code needed*/}}
}

{{- if .OutputCodeNeeded }}
func NewFuture{{$svcDiff}}{{$methCamel}}() *Future{{$svcDiff}}{{$methCamel}} {
    f:=&Future{{$svcDiff}}{{$methCamel}}{
        method: future.NewMethod[{{$outParam}},{{$errId}}](nil,nil),
    }
{{- else }}
func NewFuture{{$svcDiff}}{{$methCamel}}() *Future{{$svcDiff}}{{$methCamel}} {
    f:=&Future{{$svcDiff}}{{$methCamel}}{
        base: future.NewBase[{{$errId}}](),
    }
{{- end}}
    return f
}

{{- if .InputCodeNeeded }}
func (i *Client{{$svcDiff}}_) {{$svcDiff}}{{$methCamel}}(ctx context.Context, in {{$inParam}}) *Future{{$svcDiff}}{{$methCamel}} {
{{- else }}
func (i *Client{{$svcDiff}}_) {{$svcDiff}}{{$methCamel}}(ctx context.Context) *Future{{$svcDiff}}{{$methCamel}} {
{{- end }} {{/* end of input needed */}}
    mid, ok := i.BaseService.MethodIdByName("{{.WasmMethodName}}")
    if !ok {
        f:=NewFuture{{$svcDiff}}{{$methCamel}}()
        f.CompleteMethod(nil,1)/*dispatch error*/
    }
{{- if .InputCodeNeeded }}
    cid,kerr:= i.BaseService.Dispatch(mid,{{$inbound}})
{{- else }}
    cid,kerr:= i.BaseService.Dispatch(mid,nil)
{{- end }} {{/* end of input needed */}}
    f:=NewFuture{{$svcDiff}}{{$methCamel}}()
    if kerr!=syscall.KernelErr_NoError{
        f.CompleteMethod(nil, 1)/*dispatch error*/
        return f
     }
    lib.MatchCompleter(cid,f)
    return f
}
{{- end}} {{/*ranging over methods*/}}
{{- end}} {{/*ranging over services*/}}
