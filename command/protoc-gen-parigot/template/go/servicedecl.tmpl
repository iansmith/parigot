package {{ LastSegmentOfPackage .file.GetPackage }}
import(
{{- range $j,$i := .imports }}
    "{{$j}}"
{{- end}} {{/* imports */}}
)
{{- $info:=.info }}
{{- range .info.Service }}
{{- if .NoKernelOption}}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
//
// {{$svcCamel}}
//
type {{$svcCamel}} interface {
{{- range .GetWasmMethod}}
{{- $methodRet:=call .FuncChoice.MethodRet .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput false . }}
{{- $methParamDecl:=call .FuncChoice.MethodParamDecl .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
    {{.WasmMethodName}}({{$methParamDecl}}) {{$methodRet}}
{{- end }}
}
{{- end }}{{/* closes no kernel option */}}
{{- end}} {{/* closes top service, the interface stuff*/}}

{{- range .info.Service }}
{{- if .NoKernelOption}}
{{ $svc:=.GetWasmServiceName }}
{{ $svcCamel:=.GetWasmServiceName }}
type {{$svcCamel}}Client struct {
    *lib.ClientSideService
}

func Locate{{$svc}}() (*{{$svcCamel}}Client,error) {
    var resp kernel.LocateResponse
    req:=&kernel.LocateRequest{
        PackageName:"{{.ProtoPackage}}",
        ServiceName: "{{$svc}}",
    }
    err:=lib.Locate(req,&resp)
    if err!=nil {
        return nil, err
    }
    locateErr:=lib.FromLocateErrorId(resp.GetErrorId())
    if locateErr.IsError(){
        return nil, lib.NewPerrorFromId("semantic error in locate call:", locateErr)
    }
    service:=lib.FromServiceId(resp.GetServiceId())
    cs:=lib.NewClientSideService(service)
    return &{{$svcCamel}}Client{
        ClientSideService: cs,
    },nil
}

{{- range .GetWasmMethod}}

{{- $meth:=.WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $bits:=call .FuncChoice.Bits .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput }}
{{- $needsFillIn:=call .FuncChoice.NeedsFillIn .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput }}
{{- $needsFillOut:=call .FuncChoice.NeedsFillOut .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput }}
{{- $needsPullApart:=call .FuncChoice.NeedsPullApart .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput }}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $inbound:=call .FuncChoice.Inbound .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput . }}
{{- $outbound:=call .FuncChoice.Outbound .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput . }}
{{- $methParamDecl:=call .FuncChoice.MethodParamDecl .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}

{{/*
{{- $methCall:=call .FuncChoice.MethodCall .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $inputToSend:=call .FuncChoice.InputToSend .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $outLocal:=call .FuncChoice.OutLocal .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $retValue:=call .FuncChoice.RetValue .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $methodRet:=call .FuncChoice.MethodRet .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput false . }}
{{- $retError:=call .FuncChoice.RetError .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput . }}
*/}}

func (i *{{$svcCamel}}Client) {{$methCamel}}({{$methParamDecl}}) error {

{{- if $needsFillIn}}
    req:=&{{$inParam}}{}  // build the structure: {{$inParam}}
{{- range .InputFields}}
    req.{{toCamelCase .GetName}}={{.GetWasmFieldName}}
{{- end}}{{/* range input fields */}}
{{- else }} {{/* other side of needs fill in */}}
    {{ $inbound }}
{{- end}}{{/*needs fill*/}}

    resp:=&kernel.DispatchResponse{}
    err:= i.Dispatch("{{.WasmMethodName}}",req,resp)
    if err!=nil {
       return err
    }
    dispErr:=lib.FromDispatchErrorId(resp.GetErrorId())
    if dispErr.IsError() {
        return lib.NewPerrorFromId("semantic error in dispatch call:", dispErr)
    }

{{- if .OutputCodeNeeded }}

{{- if $needsFillOut}}
        out:={{$outParam}}
{{- end}} {{/* needs fill out */}}

    err = proto.Unmarshal(resp.OutBlob,out)
    if err!=nil {
        panic("unmarshal failed for type {{$outParam}}")
    }

{{- if $needsFillOut}} //take apart response structure: {{$outParam}}
{{- range .OutputFields}}
    *{{.Name}}={{.Field}}
{{- end}}{{/* range output fields */}}
{{- end}}{{/*needs fill*/}}
    return nil

{{- else }} {{/* other side of output code needed */}}
    return nil
{{- end }} {{/* output code needed */}}
}
{{- end }} {{/*ranging over methods*/}}
{{- end }} {{/* no kernel option */}}
{{- end}} {{/*ranging over services*/}}


func init() {

{{- range .info.Service }}
{{- if .NoKernelOption }}
    req{{.GetWasmServiceName}}:=&kernel.RegisterRequest{
        ProtoPackage: "{{.ProtoPackage}}",
        Service:      "{{.GetWasmServiceName}}",
    }
    resp{{.GetWasmServiceName}}:=kernel.RegisterResponse{}
    if lib.Register(req{{.GetWasmServiceName}},&resp{{.GetWasmServiceName}})!=nil {
        panic("unable to register service "+"{{.GetWasmServiceName}}")
    }
    reg{{.GetWasmServiceName}}Err:=lib.FromRegisterErrorId(resp{{.GetWasmServiceName}}.GetErrorId())
    if reg{{.GetWasmServiceName}}Err.IsError() {
        panic(fmt.Sprintf("semantic error trying to register {{.GetWasmServiceName}}: %s",
            reg{{.GetWasmServiceName}}Err))
    }
{{- end }} {{/* if no kernel */}}
{{- end }}
}
