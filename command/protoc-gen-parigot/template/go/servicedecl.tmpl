// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}
{{ $file:=.file}}
import(
    "context"

{{- range $j,$i := .import }}
    {{$j}}
{{- end}} {{/* imports */}}
{{- $info:=.info }}

    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
    lib "github.com/iansmith/parigot/lib/go"  
    syscallmsg "github.com/iansmith/parigot/g/msg/syscall/v1"  //syscallmsg
    "github.com/iansmith/parigot/apiwasm/syscall" 


{{/* this special case for log.Log kinda stinks */}}
{{- $needLog:=true}}
{{- range .service }}
    {{- if eq "LogService" .GetWasmServiceName }}
        // found the log service 
        {{- $needLog = false }}
    {{- end }}
{{- end}}
)   

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
//
// {{$svcCamel}} from {{$file}}
//
type {{$svcCamel}} interface {
{{- range .GetWasmMethod}}

{{- $genTest:=call .FuncChoice.GenMethodPossibleTest . }}
{{- if eq false $genTest }}
    // skipping {{.}}, not in test mode
    {{- continue }}
{{- end}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}
{{- if .InputCodeNeeded }}
    {{$methCamel}}(ctx context.Context,in *{{$iParam}}) 
{{- else }} 
    {{$methCamel}}(ctx context.Context) 
{{- end -}} 
{{- if .OutputCodeNeeded -}}
    (*{{$oParam}}, error) // xxxx
{{- else -}}
    error
{{- end -}} {{/* end of output code needed for declaration */}}
{{- end }} {{/* end of range over methods */}}
}

// Client Side Interface (has no context.Context)
type {{$svcCamel}}Client interface {
{{- range .GetWasmMethod}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}
{{- if .InputCodeNeeded }}
    {{$methCamel}}(in *{{$iParam}}) 
{{- else }} 
    {{$methCamel}}() 
{{- end -}} 
{{- if .OutputCodeNeeded -}}
    (*{{$oParam}}, error) // xxxx
{{- else -}}
    error
{{- end -}} {{/* end of output code needed for declaration */}}
{{- end }} {{/* end of range over methods */}}
}

{{- end}} {{/* closes service, the interface stuff*/}}

{{- range .service }}
{{- if .NoKernelOption}}
{{ $svc:=.GetWasmServiceName }}
{{ $svcCamel:=.GetWasmServiceName }}

type {{$svcCamel}}Client_ struct {
    *lib.ClientSideService
}
var required{{$svc}} bool

// Locate finds a reference to the client interface of {{$svc}}.  
func Locate{{$svc}}(ctx context.Context) ({{$svcCamel}}Client,error) {
	req := &syscallmsg.LocateRequest{
        PackageName:"{{.ProtoPackage}}",
        ServiceName: "{{$svc}}",
	}

    resp:=syscall.Locate(req)
    sid:=resp.GetServiceId()
    if resp.GetServiceId()==nil {
        panic("service id is nil, can't create ClientSideService")
    }
    id:=lib.Unmarshal(sid)
    if lib.IdRepresentsError(id.High(),id.Low()) {
        return nil, lib.NewPerrorFromId("failed to unmarshal service id",id)
    }
    service:=lib.Unmarshal(resp.GetServiceId())
    cs := lib.NewClientSideService(ctx, service, "{{$svc}}Client")
    
    return &{{$svc}}Client_{
        ClientSideService: cs,
    }, nil
}

func Locate{{$svc}}OrPanic(ctx context.Context) {{$svcCamel}}Client {
    if !required{{$svc}} {
        panic("call of Locate{{$svc}}OrPanic without previous call to Require{{$svc}}OrPanic")
    }

    result, err:=Locate{{$svc}}(ctx)

    if err!=nil {
        panic("unable to locate {{.ProtoPackage}}.{{$svc}}:"+err.Error())
    }
    return result
}

func Require{{$svc}}OrPanic(ctx context.Context) {
    _, err:=lib.Require1("{{.ProtoPackage}}","{{$svc}}")
    if err!=nil {
        panic("not able to require {{.ProtoPackage}}.{{$svc}}:"+err.Error())
    }
    required{{$svc}}=true
}

func Export{{$svc}}OrPanic() {
    _, err:=lib.Export1("{{.ProtoPackage}}","{{$svc}}")
    if err!=nil {
        panic("not able to export {{.ProtoPackage}}.{{$svc}}:"+err.Error())
    }
}
func Wait{{$svc}}OrPanic() {
	_ = syscall.Run(&syscallmsg.RunRequest{Wait: true})

}

{{range .GetWasmMethod}}

{{- $meth:=.WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inbound:=call .FuncChoice.Inbound .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput . }}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $outParamDecl:=call .FuncChoice.OutParamDecl .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $dispatchResult:=call .FuncChoice.DispatchResult .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}

{{- $genTest:=call .FuncChoice.GenMethodPossibleTest . }}
{{- if eq false $genTest }}
    // skipping {{.}}, not in test mode
    {{- continue }}
{{- end}}

{{- if .InputCodeNeeded -}}
func (i *{{$svcCamel}}Client_) {{$methCamel}}(in {{$inParam}}) 
{{- else -}}
func (i *{{$svcCamel}}Client_) {{$methCamel}}() 
{{- end -}}
{{- if .OutputCodeNeeded -}}
    ({{$outParam}}, error) {
{{- else -}}
    error {
{{- end -}} {{/* end of output code needed for declaration */}}

{{- if .OutputCodeNeeded }}
    out:=&{{$outParamDecl}}
    {{$dispatchResult}}, err:= i.ClientSideService.Dispatch("{{.WasmMethodName}}",{{$inbound}})
{{- else }} {{/* other side of output code needed */}}
    _, err:= i.ClientSideService.Dispatch("{{.WasmMethodName}}",{{$inbound}})
{{ end }} {{/* end of output code needed for dispatch call */}}

    if err!=nil {
{{- if .OutputCodeNeeded }}
        return nil, err
    }
{{- else }}
        return err
    }
{{ end }} {{/* end of output code needed for return */}}

{{- if .OutputCodeNeeded }}
    err = resp.Result.UnmarshalTo(out)
    if err!=nil {
        return nil,lib.NewPerrorFromError("failed to unmarshal result (generated code):",err)
    }
    return out,nil
{{- else }} {{/* other side of output code needed */}}
    return nil
{{- end }} {{/* output code needed */}}
}
{{end}} {{/*ranging over methods*/}}
{{- end }} {{/* no kernel option */}}
{{- end}} {{/*ranging over services*/}}

