//go:build wasip1 

// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}
{{ $file:=.file}}
import(
    "context"

{{- range $j,$i := .import }}
    {{$j}}
{{- end}} {{/* imports */}}
{{- $info:=.info }}

    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
    lib "github.com/iansmith/parigot/lib/go"  
    pcontext "github.com/iansmith/parigot/context"  
    "github.com/iansmith/parigot/apishared/id"  
    syscallmsg "github.com/iansmith/parigot/g/msg/syscall/v1"  //syscallmsg
    "github.com/iansmith/parigot/apiwasm/syscall" 


{{/* this special case for log.Log kinda stinks */}}
{{- $needLog:=true}}
{{- range .service }}
    {{- if eq "LogService" .GetWasmServiceName }}
        // found the log service 
        {{- $needLog = false }}
    {{- end }}
{{- end}}
)   

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId}}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
//
// {{$svcCamel}} from {{$file}}
//
type {{$svcCamel}} interface {
{{- range .GetWasmMethod}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}
{{- if .InputCodeNeeded }}
    {{$methCamel}}(ctx context.Context,in *{{$iParam}}) 
{{- else }} 
    {{$methCamel}}(ctx context.Context) 
{{- end -}} 
{{- if .OutputCodeNeeded -}}
    (*{{$oParam}}, {{$errId}}) 
{{- else -}}
    {{$errId}}
{{- end -}} {{/* end of output code needed for declaration */}}
{{- end }} {{/* end of range over methods */}}
}
{{- end}} {{/* closes service, the interface stuff*/}}

{{- range .service }}
{{- if .NoKernelOption}}
{{ $svc:=.GetWasmServiceName }}
{{ $svcCamel:=.GetWasmServiceName }}
{{ $errId:=.GetWasmServiceErrId }}

type {{$svcCamel}}Client {{$svcCamel}}
type {{$svcCamel}}Client_ struct {
    *lib.ClientSideService
}

// Locate finds a reference to the client interface of {{$svc}}.  
func Locate{{$svc}}(ctx context.Context,sid id.ServiceId) ({{$svcCamel}}Client,id.KernelErrId) {
	req := &syscallmsg.LocateRequest{
        PackageName:"{{.ProtoPackage}}",
        ServiceName: "{{$svc}}",
        CalledBy: sid.Marshal(),
	}

    resp,errId:=syscall.Locate(req)
    print("locate ","{{.ProtoPackage}} ","{{$svc}}"," sid ",sid.String()," result ",resp," error ",errId.String(),"\n")
    if errId.IsError() { 
        pcontext.Errorf(ctx,"UnmarshalServiceId failed: %v",errId.Short())
        return nil, errId
    }
    serviceId:=id.MustUnmarshalServiceId(resp.GetServiceId())

    cs := lib.NewClientSideService(ctx, serviceId, "{{$svc}}Client")
    return &{{$svc}}Client_{
        ClientSideService: cs,
    },id.KernelErrIdNoErr
}

func MustLocate{{$svc}}(ctx context.Context, sid id.ServiceId) {{$svcCamel}}Client {

    result, err:=Locate{{$svc}}(ctx, sid)

    normal:="unable to locate {{.ProtoPackage}}.{{$svc}}:"+err.Short()

    if err.IsError() {
        pcontext.Debugf(ctx,"error code is %d",err.ErrorCode())
        if err.ErrorCode() == 28 {
            pcontext.Errorf(ctx,"service was located, but it was not required")
            panic("locate attempted on a service that was not required")
        }
        panic(normal)
    }
    return result
}

func Register{{$svc}}(ctx context.Context) (id.ServiceId, id.KernelErrId){
    req := &syscallmsg.RegisterRequest{}
	fqs := &syscallmsg.FullyQualifiedService{
		PackagePath: "{{.ProtoPackage}}",
		Service:     "{{$svc}}",
	}
	req.Fqs = fqs
    req.IsClient = false

	resp, err := syscall.Register(req)
    if err.IsError() {
        return id.ZeroValueServiceId(), err
    }
    sid, idErr:=id.UnmarshalServiceId(resp.Id)
    if idErr.IsError() {
        return id.ZeroValueServiceId(),	id.NewKernelErrId(id.KernelErrIdUnmarshalError)
    }
    return sid,id.KernelErrIdNoErr
}
func MustRegister{{$svc}}(ctx context.Context) id.ServiceId {
    sid, err:=Register{{$svc}}(ctx)
    if err.IsError() {
        pcontext.Fatalf(ctx,"unable to register %s.%s","{{.ProtoPackage}}","{{$svc}}")
        panic("unable to register "+"{{$svc}}")
    }
    return sid
}

func MustRequire{{$svc}}(ctx context.Context, sid id.ServiceId) {
    _, err:=lib.Require1("{{.ProtoPackage}}","{{$svc}}",sid)
    if err.IsError() {
        if err.ErrorCode()==11 {
            pcontext.Errorf(ctx,"unable to require %s.%s because it creates a dependcy loop: %s","{{.ProtoPackage}}","{{$svc}}",err.String())
            panic("nequire {{.ProtoPackage}}.{{$svc}} creates a dependency loop")
        }
        pcontext.Errorf(ctx,"unable to require %s.%s:%s","{{.ProtoPackage}}","{{$svc}}",err.String())
        panic("not able to require {{.ProtoPackage}}.{{$svc}}:"+err.Short())
    }
}

func MustExport{{$svc}}(ctx context.Context) {
    _, err:=lib.Export1("{{.ProtoPackage}}","{{$svc}}")
    if err.IsError() {
        pcontext.Fatalf(ctx, "unable to export %s.%s","{{.ProtoPackage}}","{{$svc}}")
        panic("not able to export {{.ProtoPackage}}.{{$svc}}:"+err.Short())
    }
}
func MustWaitSatisfied{{$svc}}(sid id.ServiceId) {
    s:=sid.Marshal()
	syscall.Run(&syscallmsg.RunRequest{Wait: true, ServiceId:s })

}

{{range .GetWasmMethod}}

{{- $meth:=.WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inbound:=call .FuncChoice.Inbound .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput . }}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $outParamDecl:=call .FuncChoice.OutParamDecl .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $dispatchResult:=call .FuncChoice.DispatchResult .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}


{{- if .InputCodeNeeded -}}
func (i *{{$svcCamel}}Client_) {{$methCamel}}(ctx context.Context, in {{$inParam}}) 
{{- else -}}
// ouch {{.InputCodeNeeded}} {{.OutputCodeNeeded}}
func (i *{{$svcCamel}}Client_) {{$methCamel}}(ctx context.Context) 
{{- end -}}
{{- if .OutputCodeNeeded -}}
    ({{$outParam}}, {{$errId}}) {
{{- else -}}
    {{$errId}} {
{{- end -}} {{/* end of output code needed for declaration */}}

{{- if .OutputCodeNeeded }}
    out:=&{{$outParamDecl}}
    {{$dispatchResult}}, err:= i.ClientSideService.Dispatch("{{.WasmMethodName}}",{{$inbound}})
{{- else }} {{/* other side of output code needed */}}
    _, err:= i.ClientSideService.Dispatch("{{.WasmMethodName}}",{{$inbound}})
{{ end }} {{/* end of output code needed for dispatch call */}}

    if err.IsError(){
{{- if .OutputCodeNeeded }}
        pcontext.Errorf(ctx,"dispatch syscall failed: %s",err.Short())
        return nil, New{{$errId}}({{$errId}}DispatchError)
    }
{{- else }}
        pcontext.Errorf(ctx,"dispatch syscall failed: %s",err.Short())
        return  New{{$errId}}({{$errId}}DispatchError)
    }
{{ end }} {{/* end of output code needed for return */}}
{{- if .OutputCodeNeeded }}
    unmarsh := resp.Result.UnmarshalTo(out)
    if unmarsh!=nil {
        return nil,New{{$errId}}({{$errId}}UnmarshalError)
    }
    return out,{{$errId}}NoErr
{{- else }} {{/* other side of output code needed */}}
    return {{$errId}}NoErr
{{- end }} {{/* output code needed */}}
}
{{end}} {{/*ranging over methods*/}}
{{- end }} {{/* no kernel option */}}
{{- end}} {{/*ranging over services*/}}

