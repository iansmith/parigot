//go:build wasip1 

// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}
{{ $file:=.file}}
{{ $package:=.package}}
import(
    "context"

{{- range $j,$i := .import }}
{{ if ne $j "" }}
    {{$j}}
{{ end }}
{{- end}} {{/* imports */}}
{{- $info:=.info }}

    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
    lib "github.com/iansmith/parigot/lib/go"  
    pcontext "github.com/iansmith/parigot/context"  
    "github.com/iansmith/parigot/apishared/id"  
    syscall "github.com/iansmith/parigot/g/syscall/v1" 
    syscallguest "github.com/iansmith/parigot/apiwasm/syscall" 
    "github.com/iansmith/parigot/apiwasm" 

    "google.golang.org/protobuf/proto"
)   

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId}}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}

//
// {{$svcCamel}} from {{$file}}
//
type {{$svcCamel}} interface {
{{- range .GetWasmMethod}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $iParam:=.InputParam.CGType.String $package}}
{{- $oParam:=.OutputParam.CGType.String $package}}
{{- if .InputCodeNeeded }}
    {{$methCamel}}(ctx context.Context,in *{{$iParam}}) 
{{- else }} 
    {{$methCamel}}(ctx context.Context) 
{{- end -}} 
{{- if .OutputCodeNeeded -}}
    (*{{$oParam}}, {{$errId}}) 
{{- else -}}
    {{$errId}}
{{- end -}} {{/* end of output code needed for declaration */}}
{{- end }} {{/* end of range over methods */}}
}
type Client{{$svcCamel}} interface {
{{- range .GetWasmMethod}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $iParam:=.InputParam.CGType.String $package}}
{{- $oParam:=.OutputParam.CGType.String $package}}
{{- if .InputCodeNeeded }}
    {{$methCamel}}(ctx context.Context,in *{{$iParam}}) 
{{- else }} 
    {{$methCamel}}(ctx context.Context) 
{{- end -}} 
{{- if .OutputCodeNeeded -}}
    lib.Promise[*{{$oParam}}, {{$errId}}]
{{- else -}}
    lib.Promise[any,{{$errId}}]
{{- end -}} {{/* end of output code needed for declaration */}}
{{- end }} {{/* end of range over methods */}}

}

{{- end}} {{/* closes service, the interface stuff*/}}

{{- range .service }}
{{ $svc:=.GetWasmServiceName }}
{{ $svcCamel:=.GetWasmServiceName }}
{{ $errId:=.GetWasmServiceErrId }}
{{- $svcCamelFL:=toCamelCaseFirstLower .GetWasmServiceName }}

type Client{{$svcCamel}}_ struct {
    *lib.ClientSideService
}
func (c * Client{{$svcCamel}}_) Dispatch(name string, param proto.Message) (*syscall.DispatchResponse, syscall.KernelErr) {
    mid:=c.ClientSideService.ServiceMethodMap().MethodNameToId(c.ClientSideService.ServiceId(),name)
    if  mid.IsZeroValue() {
        return nil,syscall.KernelErr_NotFound
    }
    cid, kerr:= c.ClientSideService.Dispatch(mid,param)
    if kerr!=syscall.KernelErr_NoError{
        return nil, kerr
    }
    resp:=&syscall.DispatchResponse{
        CallId:cid.Marshal(),
    }
    return resp, syscall.KernelErr_NoError
}


// Locate finds a reference to the client interface of {{$svc}}.  
func Locate{{$svcCamel}}(ctx context.Context,sid id.ServiceId) (Client{{$svcCamel}},syscall.KernelErr) {
    cs, kerr:=lib.LocateDynamic(ctx, "{{.ProtoPackage}}","{{$svc}}", sid)
    if kerr!=syscall.KernelErr_NoError{
        return nil, kerr
    }
    return &Client{{$svcCamel}}_{
        ClientSideService: cs,
    },syscall.KernelErr_NoError
}

func MustLocate{{$svc}}(ctx context.Context, sid id.ServiceId) Client{{$svcCamel}} {
    result, err:=Locate{{$svc}}(ctx, sid)
    name:=syscall.KernelErr_name[int32(err)]
    normal:="unable to locate {{.ProtoPackage}}.{{$svc}}:"+name
    if err!=0 {
        pcontext.Debugf(ctx,"kernel error was  %s",name)
        if err == syscall.KernelErr_NotRequired {
            pcontext.Errorf(ctx,"service was located, but it was not required")
            panic("locate attempted on a service that was not required")
        }
        panic(normal)
    }
    return result
}

func Register{{$svcCamel}}(ctx context.Context) (id.ServiceId, syscall.KernelErr){
    req := &syscall.RegisterRequest{}
	fqs := &syscall.FullyQualifiedService{
		PackagePath: "{{.ProtoPackage}}",
		Service:     "{{$svc}}",
	}
	req.Fqs = fqs
    req.IsClient = false

	resp, err := syscallguest.Register(req)
    if err!=syscall.KernelErr_NoError{
        return id.ServiceIdZeroValue(), err
    }
    sid:=id.UnmarshalServiceId(resp.Id)
    if sid.IsZeroOrEmptyValue() {
        panic("received bad service Id from register")
    }

    return sid,syscall.KernelErr_NoError
}
func MustRegister{{$svcCamel}}(ctx context.Context) id.ServiceId {
    sid, err:=Register{{$svc}}(ctx)
    if err!=syscall.KernelErr_NoError {
        pcontext.Fatalf(ctx,"unable to register %s.%s","{{.ProtoPackage}}","{{$svc}}")
        panic("unable to register "+"{{$svc}}")
    }
    return sid
}

func MustRequire{{$svc}}(ctx context.Context, sid id.ServiceId) {
    _, err:=lib.Require1("{{.ProtoPackage}}","{{$svc}}",sid)
    if err!=syscall.KernelErr_NoError {
        if err==syscall.KernelErr_DependencyCycle{
            pcontext.Errorf(ctx,"unable to require %s.%s because it creates a dependcy loop: %s","{{.ProtoPackage}}","{{$svc}}",syscall.KernelErr_name[int32(err)])
            panic("require {{.ProtoPackage}}.{{$svc}} creates a dependency loop")
        }
        pcontext.Errorf(ctx,"unable to require %s.%s:%s","{{.ProtoPackage}}","{{$svc}}",syscall.KernelErr_name[int32(err)])
        panic("not able to require {{.ProtoPackage}}.{{$svc}}:"+syscall.KernelErr_name[int32(err)])
    }
}

func MustExport{{$svc}}(ctx context.Context) {
    _, err:=lib.Export1("{{.ProtoPackage}}","{{$svc}}")
    if err!=syscall.KernelErr_NoError{
        pcontext.Fatalf(ctx, "unable to export %s.%s","{{.ProtoPackage}}","{{$svc}}")
        panic("not able to export {{.ProtoPackage}}.{{$svc}}:"+syscall.KernelErr_name[int32(err)])
    }
}

func WaitSatisfied{{$svc}}(ctx context.Context, sid id.ServiceId, impl Server{{$svcCamel}}) (*apiwasm.ServiceMethodMap,syscall.KernelErr) {
	smmap, err:={{$svcCamelFL}}Bind(ctx,sid, impl)
	if err!=0{
		return  nil,syscall.KernelErr(err)
	}

    s:=sid.Marshal()
	syscallguest.Launch(&syscall.LaunchRequest{ServiceId:s })

    return smmap,syscall.KernelErr_NoError
}

func MustWaitSatisfied{{$svc}}(ctx context.Context, sid id.ServiceId, impl Server{{$svcCamel}}) *apiwasm.ServiceMethodMap {
    smmap,err:=WaitSatisfied{{$svc}}(ctx,sid,impl)
    if err!=syscall.KernelErr_NoError {
        panic("Unable to call WaitSatisfied successfully: "+syscall.KernelErr_name[int32(err)])
    }
    return smmap
}

{{range .GetWasmMethod}}

{{- $meth:=.WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inbound:=call .FuncChoice.Inbound .InputCodeNeeded .OutputCodeNeeded false false . }}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParamDecl:=call .FuncChoice.OutParamDecl .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $dispatchResult:=call .FuncChoice.DispatchResult .InputCodeNeeded .OutputCodeNeeded false false .}}


{{- if and .InputCodeNeeded .OutputCodeNeeded  -}}
// both
func (i *Client{{$svcCamel}}_) {{$methCamel}}(ctx context.Context, in {{$inParam}}) lib.Promise[{{$outParam}},{{$errId}}]{
    raw, err:= i.Dispatch("{{.WasmMethodName}}",{{$inbound}})
    if err!=syscall.KernelErr_NoError{
        return lib.Promise[{{$outParam}},{{$errId}}]{}, err
    }
    cid:=id.UnmarshalCallId(raw.GetCallId())
    return lib.NewPromiseFromProto[{{$outParam}},{{$errId}}](i.ClientSideService,cid)

{{- else }} {{/* else for both */}}
{{- if .InputCodeNeeded }}
// in
func (i *Client{{$svcCamel}}_) {{$methCamel}}(ctx context.Context,in {{$inParam}}) lib.Promise[any,{{$errId}}] {
    raw, err:= i.Dispatch("{{.WasmMethodName}}",{{$inbound}})
    if err!=syscall.KernelErr_NoError{
        return lib.PromiseOnlyError[{{$errId}}]{}, err
    }
    cid:=id.UnmarshalCallId(raw.GetCallId())
    p:=lib.NewPromiseErrOnly[any,{{$errId}}]()
{{- else }}
// out
func (i *Client{{$svcCamel}}_) {{$methCamel}}(ctx context.Context)  lib.Promise[{{$outParam}},{{$errId}}] {
    raw, err:= i.Dispatch("{{.WasmMethodName}}")
    if err!=syscall.KernelErr_NoError{
        return lib.Promise[{{$outParam}},{{$errId}}], err
    }
    cid:=id.UnmarshalCallId(raw.GetCallId())
    return lib.NewPromiseFromProto[{{$outParam}},{{$errId}}](i.ClientSideService,cid)
{{- end -}} {{/*end of need input plus else */}}
{{- end -}} {{/*end of need both */}}
}
{{end}} {{/*ranging over methods*/}}
{{- end}} {{/*ranging over services*/}}
