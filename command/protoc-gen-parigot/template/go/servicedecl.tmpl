// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}
{{ $file:=.file}}
import(
    "context"

{{- range $j,$i := .import }}
    {{$j}}
{{- end}} {{/* imports */}}
{{- $info:=.info }}

    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
    lib "github.com/iansmith/parigot/lib/go"  
    pcontext "github.com/iansmith/parigot/context"  
    "github.com/iansmith/parigot/apishared/id"  
    syscallmsg "github.com/iansmith/parigot/g/msg/syscall/v1"  //syscallmsg
    "github.com/iansmith/parigot/apiwasm/syscall" 


{{/* this special case for log.Log kinda stinks */}}
{{- $needLog:=true}}
{{- range .service }}
    {{- if eq "LogService" .GetWasmServiceName }}
        // found the log service 
        {{- $needLog = false }}
    {{- end }}
{{- end}}
)   

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId}}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
//
// {{$svcCamel}} from {{$file}}
//
type {{$svcCamel}} interface {
{{- range .GetWasmMethod}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}
{{- if .InputCodeNeeded }}
    {{$methCamel}}(ctx context.Context,in *{{$iParam}}) 
{{- else }} 
    {{$methCamel}}(ctx context.Context) 
{{- end -}} 
{{- if .OutputCodeNeeded -}}
    (*{{$oParam}}, {{$errId}}) 
{{- else -}}
    {{$errId}}
{{- end -}} {{/* end of output code needed for declaration */}}
{{- end }} {{/* end of range over methods */}}
}

// Client Side Interface
type {{$svcCamel}}Client interface {
{{- range .GetWasmMethod}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $iParam:=.InputParam.CGType.StringNotInProto}}
{{- $oParam:=.OutputParam.CGType.StringNotInProto}}
{{- if .InputCodeNeeded }}
    {{$methCamel}}(ctx context.Context, in *{{$iParam}}) 
{{- else }} 
    {{$methCamel}}(ctx context.Context) 
{{- end -}} 
{{- if .OutputCodeNeeded -}}
    (*{{$oParam}}, {{$errId}})
{{- else -}}
    {{$errId}}
{{- end -}} {{/* end of output code needed for declaration */}}
{{- end }} {{/* end of range over methods */}}
}

{{- end}} {{/* closes service, the interface stuff*/}}

{{- range .service }}
{{- if .NoKernelOption}}
{{ $svc:=.GetWasmServiceName }}
{{ $svcCamel:=.GetWasmServiceName }}
{{ $errId:=.GetWasmServiceErrId }}

type {{$svcCamel}}Client_ struct {
    *lib.ClientSideService
}
var required{{$svc}} bool

// Locate finds a reference to the client interface of {{$svc}}.  
func Locate{{$svc}}(ctx context.Context) ({{$svcCamel}}Client,{{$errId}}) {
	req := &syscallmsg.LocateRequest{
        PackageName:"{{.ProtoPackage}}",
        ServiceName: "{{$svc}}",
	}

    resp,errId:=syscall.Locate(req)
    if errId.IsError() { 
        return nil, New{{$errId}}({{$errId}}Code(1))
    }
    serviceId, idErr:=id.UnmarshalServiceId(resp.GetServiceId())
    if idErr.IsError() {
        pcontext.Errorf(ctx,"UnmarshalServiceId failed: %v",idErr.Short())
        return nil, New{{$errId}}({{$errId}}Code(2))
    }    
    cs := lib.NewClientSideService(ctx, serviceId, "{{$svc}}Client")
    return &{{$svc}}Client_{
        ClientSideService: cs,
    },{{$errId}}NoErr
}

func Locate{{$svc}}OrPanic(ctx context.Context) {{$svcCamel}}Client {
    if !required{{$svc}} {
        panic("call of Locate{{$svc}}OrPanic without previous call to Require{{$svc}}OrPanic")
    }

    result, err:=Locate{{$svc}}(ctx)

    if err.IsError() {
        panic("unable to locate {{.ProtoPackage}}.{{$svc}}:"+err.Short())
    }
    return result
}

func Require{{$svc}}OrPanic(ctx context.Context) {
    _, err:=lib.Require1("{{.ProtoPackage}}","{{$svc}}")
    if err.IsError() {
        panic("not able to require {{.ProtoPackage}}.{{$svc}}:"+err.Short())
    }
    required{{$svc}}=true
}

func Export{{$svc}}OrPanic() {
    _, err:=lib.Export1("{{.ProtoPackage}}","{{$svc}}")
    if err.IsError() {
        panic("not able to export {{.ProtoPackage}}.{{$svc}}:"+err.Short())
    }
}
func Wait{{$svc}}OrPanic() {
	syscall.Run(&syscallmsg.RunRequest{Wait: true})

}

{{range .GetWasmMethod}}

{{- $meth:=.WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inbound:=call .FuncChoice.Inbound .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput . }}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $outParamDecl:=call .FuncChoice.OutParamDecl .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}
{{- $dispatchResult:=call .FuncChoice.DispatchResult .InputCodeNeeded .OutputCodeNeeded .PullParameters .PullOutput .}}


{{- if .InputCodeNeeded -}}
func (i *{{$svcCamel}}Client_) {{$methCamel}}(ctx context.Context, in {{$inParam}}) 
{{- else -}}
func (i *{{$svcCamel}}Client_) {{$methCamel}}(ctx context.Context) 
{{- end -}}
{{- if .OutputCodeNeeded -}}
    ({{$outParam}}, {{$errId}}) {
{{- else -}}
    {{$errId}} {
{{- end -}} {{/* end of output code needed for declaration */}}

{{- if .OutputCodeNeeded }}
    out:=&{{$outParamDecl}}
    {{$dispatchResult}}, err:= i.ClientSideService.Dispatch("{{.WasmMethodName}}",{{$inbound}})
{{- else }} {{/* other side of output code needed */}}
    _, err:= i.ClientSideService.Dispatch("{{.WasmMethodName}}",{{$inbound}})
{{ end }} {{/* end of output code needed for dispatch call */}}

    if err.IsError(){
{{- if .OutputCodeNeeded }}
        pcontext.Errorf(ctx,"dispatch syscall failed: %s",err.Short())
        return nil, New{{$errId}}({{$errId}}DispatchError)
    }
{{- else }}
        pcontext.Errorf(ctx,"dispatch syscall failed: %s",err.Short())
        return  New{{$errId}}({{$errId}}DispatchError)
    }
{{ end }} {{/* end of output code needed for return */}}
{{- if .OutputCodeNeeded }}
    unmarsh := resp.Result.UnmarshalTo(out)
    if unmarsh!=nil {
        return nil,New{{$errId}}({{$errId}}UnmarshalError)
    }
    return out,{{$errId}}NoErr
{{- else }} {{/* other side of output code needed */}}
    return {{$errId}}NoErr
{{- end }} {{/* output code needed */}}
}
{{end}} {{/*ranging over methods*/}}
{{- end }} {{/* no kernel option */}}
{{- end}} {{/*ranging over services*/}}

