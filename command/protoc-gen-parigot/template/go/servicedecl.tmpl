//go:build wasip1 

// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}
{{ $file:=.file}}
{{ $package:=.package}}
import(
    "context"

{{- range $j,$i := .import }}
{{ if ne $j "" }}
    {{$j}}
{{ end }}
{{- end}} {{/* imports */}}
{{- $info:=.info }}

    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
    lib "github.com/iansmith/parigot/lib/go"  
    pcontext "github.com/iansmith/parigot/context"  
    "github.com/iansmith/parigot/apishared/id"  
    syscall "github.com/iansmith/parigot/g/syscall/v1" 
    syscallguest "github.com/iansmith/parigot/apiwasm/syscall" 


{{/* this special case for log.Log kinda stinks */}}
{{- $needLog:=true}}
{{- range .service }}
    {{- if eq "LogService" .GetWasmServiceName }}
        // found the log service 
        {{- $needLog = false }}
    {{- end }}
{{- end}}
)   

{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId}}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
//
// {{$svcCamel}} from {{$file}}
//
type {{$svcCamel}} interface {
{{- range .GetWasmMethod}}

{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $iParam:=.InputParam.CGType.String $package}}
{{- $oParam:=.OutputParam.CGType.String $package}}
{{- if .InputCodeNeeded }}
    {{$methCamel}}(ctx context.Context,in *{{$iParam}}) 
{{- else }} 
    {{$methCamel}}(ctx context.Context) 
{{- end -}} 
{{- if .OutputCodeNeeded -}}
    (*{{$oParam}}, {{$errId}}) 
{{- else -}}
    {{$errId}}
{{- end -}} {{/* end of output code needed for declaration */}}
{{- end }} {{/* end of range over methods */}}
}
{{- end}} {{/* closes service, the interface stuff*/}}

{{- range .service }}
{{ $svc:=.GetWasmServiceName }}
{{ $svcCamel:=.GetWasmServiceName }}
{{ $errId:=.GetWasmServiceErrId }}

type {{$svcCamel}}Client {{$svcCamel}}
type {{$svcCamel}}Client_ struct {
    *lib.ClientSideService
}

// Locate finds a reference to the client interface of {{$svc}}.  
func Locate{{$svc}}(ctx context.Context,sid id.ServiceId) ({{$svcCamel}}Client,syscall.KernelErr) {
	req := &syscall.LocateRequest{
        PackageName:"{{.ProtoPackage}}",
        ServiceName: "{{$svc}}",
        CalledBy: sid.Marshal(),
	}

    resp,errId:=syscallguest.Locate(req)
    if errId!=syscall.KernelErr_NoError{
        pcontext.Errorf(ctx,"UnmarshalServiceId failed: %s",syscall.KernelErr_name[int32(errId)])
        return nil, errId
    }
    serviceId:=id.UnmarshalServiceId(resp.GetServiceId())

    cs := lib.NewClientSideService(ctx, serviceId, "{{$svc}}Client")
    return &{{$svc}}Client_{
        ClientSideService: cs,
    },syscall.KernelErr_NoError
}

func MustLocate{{$svc}}(ctx context.Context, sid id.ServiceId) {{$svcCamel}}Client {

    result, err:=Locate{{$svc}}(ctx, sid)

    name:=syscall.KernelErr_name[int32(err)]
    normal:="unable to locate {{.ProtoPackage}}.{{$svc}}:"+name
    if err!=0 {
        pcontext.Debugf(ctx,"kernel error was  %s",name)
        if err == syscall.KernelErr_NotRequired {
            pcontext.Errorf(ctx,"service was located, but it was not required")
            panic("locate attempted on a service that was not required")
        }
        panic(normal)
    }
    return result
}

func Register{{$svc}}(ctx context.Context) (id.ServiceId, syscall.KernelErr){
    req := &syscall.RegisterRequest{}
	fqs := &syscall.FullyQualifiedService{
		PackagePath: "{{.ProtoPackage}}",
		Service:     "{{$svc}}",
	}
	req.Fqs = fqs
    req.IsClient = false

	resp, err := syscallguest.Register(req)
    if err!=0 {
        return id.ServiceIdZeroValue(), err
    }
    sid:=id.UnmarshalServiceId(resp.Id)
    return sid,syscall.KernelErr_NoError
}
func MustRegister{{$svc}}(ctx context.Context) id.ServiceId {
    sid, err:=Register{{$svc}}(ctx)
    if err!=syscall.KernelErr_NoError {
        pcontext.Fatalf(ctx,"unable to register %s.%s","{{.ProtoPackage}}","{{$svc}}")
        panic("unable to register "+"{{$svc}}")
    }
    return sid
}

func MustRequire{{$svc}}(ctx context.Context, sid id.ServiceId) {
    _, err:=lib.Require1("{{.ProtoPackage}}","{{$svc}}",sid)
    if err!=syscall.KernelErr_NoError {
        if err==syscall.KernelErr_DependencyCycle{
            pcontext.Errorf(ctx,"unable to require %s.%s because it creates a dependcy loop: %s","{{.ProtoPackage}}","{{$svc}}",syscall.KernelErr_name[int32(err)])
            panic("require {{.ProtoPackage}}.{{$svc}} creates a dependency loop")
        }
        pcontext.Errorf(ctx,"unable to require %s.%s:%s","{{.ProtoPackage}}","{{$svc}}",syscall.KernelErr_name[int32(err)])
        panic("not able to require {{.ProtoPackage}}.{{$svc}}:"+syscall.KernelErr_name[int32(err)])
    }
}

func MustExport{{$svc}}(ctx context.Context) {
    _, err:=lib.Export1("{{.ProtoPackage}}","{{$svc}}")
    if err!=syscall.KernelErr_NoError{
        pcontext.Fatalf(ctx, "unable to export %s.%s","{{.ProtoPackage}}","{{$svc}}")
        panic("not able to export {{.ProtoPackage}}.{{$svc}}:"+syscall.KernelErr_name[int32(err)])
    }
}
func MustWaitSatisfied{{$svc}}(sid id.ServiceId) {
    s:=sid.Marshal()
	syscallguest.Run(&syscall.RunRequest{Wait: true, ServiceId:s })

}

{{range .GetWasmMethod}}

{{- $meth:=.WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inbound:=call .FuncChoice.Inbound .InputCodeNeeded .OutputCodeNeeded false false . }}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParamDecl:=call .FuncChoice.OutParamDecl .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $dispatchResult:=call .FuncChoice.DispatchResult .InputCodeNeeded .OutputCodeNeeded false false .}}


{{- if .InputCodeNeeded -}}
func (i *{{$svcCamel}}Client_) {{$methCamel}}(ctx context.Context, in {{$inParam}}) 
{{- else -}}
// ouch {{.InputCodeNeeded}} {{.OutputCodeNeeded}}
func (i *{{$svcCamel}}Client_) {{$methCamel}}(ctx context.Context) 
{{- end -}}
{{- if .OutputCodeNeeded -}}
    ({{$outParam}}, {{$errId}}) {
{{- else -}}
    {{$errId}} {
{{- end -}} {{/* end of output code needed for declaration */}}

{{- if .OutputCodeNeeded }}
    out:=&{{$outParamDecl}}
    {{$dispatchResult}}, err:= i.ClientSideService.Dispatch("{{.WasmMethodName}}",{{$inbound}})
{{- else }} {{/* other side of output code needed */}}
    _, err:= i.ClientSideService.Dispatch("{{.WasmMethodName}}",{{$inbound}})
{{ end }} {{/* end of output code needed for dispatch call */}}

    if int32(err)!=0{
{{- if .OutputCodeNeeded }}
        pcontext.Errorf(ctx,"dispatch syscall failed: %s",syscall.KernelErr_name[int32(err)])
        return nil,{{$errId}}_DispatchError
    }
{{- else }}
        pcontext.Errorf(ctx,"dispatch syscall failed: %s",syscall.KernelErr_name[int32(err)])
        return {{$errId}}_DispatchError
    }
{{ end }} {{/* end of output code needed for return */}}
{{- if .OutputCodeNeeded }}
    unmarsh := resp.Result.UnmarshalTo(out)
    if unmarsh!=nil {
        return nil,{{$errId}}_UnmarshalError
    }
    return out,{{$errId}}_NoError
{{- else }} {{/* other side of output code needed */}}
    return {{$errId}}_NoError
{{- end }} {{/* output code needed */}}
}
{{end}} {{/*ranging over methods*/}}
{{- end}} {{/*ranging over services*/}}
