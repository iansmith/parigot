//go:build wasip1 

// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: {{.file}}

package {{ .package }}
{{ $file:=.file}}
{{ $package:=.package}}
import(
    "context"

{{- range $j,$i := .import }}
{{ if ne $j "" }}
    {{$j}}
{{ end }} {{/* if not empty import */}}
{{- end}} {{/* imports */}}
{{- $info:=.info }}

    "github.com/iansmith/parigot/lib/go/future"  
    "github.com/iansmith/parigot/lib/go/client"  
    "github.com/iansmith/parigot/api/shared/id"
    "google.golang.org/protobuf/proto"
    syscallguest "github.com/iansmith/parigot/api/guest/syscall" 
    syscall "github.com/iansmith/parigot/g/syscall/v1" 
    "github.com/iansmith/parigot/lib/go"  
    "google.golang.org/protobuf/types/known/anypb"
{{if .noMethodAtAll}}
{{else}}
{{end}}{{/* no methods at all */}}
)   

{{- $needServiceDifferentiation:=true }}
{{- $svcLen := len .service }}
{{- if eq $svcLen 1 }}
{{- $needServiceDifferentiation = false}}
{{- end}} {{/* end of need differentiation check */}}
{{- range .service }}
{{- $svc:=.GetWasmServiceName }}
{{- $svcCamel:=toCamelCase .GetWasmServiceName }}
{{- $svcDiff:=""}}
{{- $svcCamelFL:=toCamelCaseFirstLower .GetWasmServiceName }}
{{- $errId:=.GetWasmServiceErrId }}
{{- $svcDiffFL:=""}}
{{- if $needServiceDifferentiation}}
{{- $svcDiff = $svcCamel }}
{{- $svcDiffFL = $svcCamelFL }}
{{- end}} {{/* end of need differentiation */}}
//
// {{$svcCamel}} from {{$file}}
//
//service interface
{{- $protoPkg:=.GetParent.GetPackage }}
type {{$svcCamel}} interface {
{{- range .GetWasmMethod}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $iParam:=.InputParam.CGType.String $protoPkg}}
{{- $oParam:=.OutputParam.CGType.String $protoPkg}}
{{- if .InputCodeNeeded }}
    {{$svcDiff}}{{$methCamel}}(ctx context.Context,in *{{$iParam}}) *Future{{$svcDiff}}{{$methCamel}}
{{- else }} 
    {{$svcDiff}}{{$methCamel}}(ctx context.Context) *Future{{$svcDiff}}{{$methCamel}}
{{- end }}  {{/* end of input needed */}}
{{- end }} {{/* end of range over methods */}}
    Ready(context.Context,id.ServiceId) *future.Base[bool]
}

type Client{{$svcDiff}} interface {
{{- range .GetWasmMethod}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $iParam:=.InputParam.CGType.String $protoPkg}}
{{- $oParam:=.OutputParam.CGType.String $protoPkg}}
{{- if .InputCodeNeeded }}
    {{$svcDiff}}{{$methCamel}}(ctx context.Context,in *{{$iParam}}) *Future{{$svcDiff}}{{$methCamel}}
{{- else }} 
    {{$svcDiff}}{{$methCamel}}(ctx context.Context) *Future{{$svcDiff}}{{$methCamel}}
{{- end }}  {{/* end of input needed */}}
{{- end }} {{/* end of range over methods */}}
}

// Client{{$svcDiff}} difference from {{$svcCamel}}: Ready() 
type Client{{$svcDiff}}_ struct {
    *client.BaseService
}
// Check that Client_ is a Client.
var _ = Client{{$svcDiff}}(&Client{{$svcDiff}}_{})

{{- range .GetWasmMethod}}
{{- $meth:=.WasmMethodName}}
{{- $methCamel:=toCamelCase .WasmMethodName}}
{{- $inbound:=call .FuncChoice.Inbound .InputCodeNeeded .OutputCodeNeeded false false . }}
{{- $inParam:=call .FuncChoice.InputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $inParamDecl:=call .FuncChoice.InParamDecl .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParam:=call .FuncChoice.OutputParam .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $outParamDecl:=call .FuncChoice.OutParamDecl .InputCodeNeeded .OutputCodeNeeded false false .}}
{{- $dispatchResult:=call .FuncChoice.DispatchResult .InputCodeNeeded .OutputCodeNeeded false false .}}

//
// method: {{$svcCamel}}.{{$methCamel}} 
//

{{- if .OutputCodeNeeded }}
type Future{{$svcDiff}}{{$methCamel}} struct {
    Method *future.Method[{{$outParam}},{{$errId}}]
}
{{- else}}
type Future{{$svcDiff}}{{$methCamel}} struct {
    Base *future.Base[{{$errId}}]
}
{{- end }} {{/*end of output code needed */}}

// This is the same API for output needed or not because of the Completer interface.
// Note that the return value refers to the process of the setup/teardown, not the
// execution of the user level code.
func (f * Future{{$svcDiff}}{{$methCamel}}) CompleteMethod(ctx context.Context,a proto.Message, e int32, orig id.HostId) syscall.KernelErr{
{{- if .OutputCodeNeeded }}
    out:=&{{$outParamDecl}}
    if a!=nil {
        tmp, ok:=a.({{$outParam}})
        if !ok {
            cvt:=a.(*anypb.Any)
            if cvt!=nil {
                if err:=cvt.UnmarshalTo(out); err!=nil {
                    return syscall.KernelErr_UnmarshalFailed
                }
            }
        } else {
            proto.Merge(out,tmp)
        }
    }
    f.Method.CompleteMethod(ctx,out,{{$errId}}(e))
{{- else }}
    f.Base.Set({{$errId}}(e))
{{- end }} {{/* end output needed */}}
    return syscall.KernelErr_NoError

}

{{- if .OutputCodeNeeded}}
func (f *Future{{$svcDiff}}{{$methCamel}})Success(sfn func (proto.Message)) {
    x:=func(m {{$outParam}}){
        sfn(m)
    }
    f.Method.Success(x)
}
{{- else }} 
func (f *Future{{$svcDiff}}{{$methCamel}})Success(sfn func (proto.Message)) {
    // no way for this to be called
}
{{- end }} {{/* end of output code needed*/}}

func (f *Future{{$svcDiff}}{{$methCamel}})VerifyRejectPresent() {
{{- if .OutputCodeNeeded}}
    f.Method.VerifyRejectPresent()
{{ end }} {{/* end of verify, do nothing if no output */}}
}

func (f *Future{{$svcDiff}}{{$methCamel}})Failure(ffn func (int32)) {
{{- if .OutputCodeNeeded}}
    x:=func(err {{$errId}}) {
        ffn(int32(err))
    }
    f.Method.Failure(x)
{{- else }}
    x:=func(err {{$errId}}) {
        ffn(int32(err))
    }
    f.Base.Handle(x)
{{- end }} {{/* end of output code needed*/}}
}

func (f *Future{{$svcDiff}}{{$methCamel}})Completed() bool  {
{{- if .OutputCodeNeeded }}
    return f.Method.Completed()
{{- else }}
    return f.Base.Completed()
{{- end }}

}
func (f *Future{{$svcDiff}}{{$methCamel}})Cancel()   {
{{- if .OutputCodeNeeded }}
    f.Method.Cancel()
{{- else }}
    f.Base.Cancel()
{{- end }}
}


{{- if .OutputCodeNeeded }}
func NewFuture{{$svcDiff}}{{$methCamel}}() *Future{{$svcDiff}}{{$methCamel}} {
    f:=&Future{{$svcDiff}}{{$methCamel}}{
        Method: future.NewMethod[{{$outParam}},{{$errId}}](nil,nil),
    }
{{- else }}
func NewFuture{{$svcDiff}}{{$methCamel}}() *Future{{$svcDiff}}{{$methCamel}} {
    f:=&Future{{$svcDiff}}{{$methCamel}}{
        Base: future.NewBase[{{$errId}}](),
    }
{{- end}} {{/*end of output needed */}}
    return f
}

{{- if .InputCodeNeeded }}
func (i *Client{{$svcDiff}}_) {{$svcDiff}}{{$methCamel}}(ctx context.Context, in {{$inParam}}) *Future{{$svcDiff}}{{$methCamel}} {
{{- else }}
func (i *Client{{$svcDiff}}_) {{$svcDiff}}{{$methCamel}}(ctx context.Context) *Future{{$svcDiff}}{{$methCamel}} {
{{- end }} {{/* end of input needed */}}
    mid, ok := i.BaseService.MethodIdByName("{{.WasmMethodName}}")
    if !ok {
        f:=NewFuture{{$svcDiff}}{{$methCamel}}()
        f.CompleteMethod(ctx,nil,1,syscallguest.CurrentHostId())/*dispatch error*/
    }
{{- if .InputCodeNeeded }}
    targetHid,cid,kerr:= i.BaseService.Dispatch(ctx,mid,{{$inbound}})
{{- else }}
    targetHid,cid,kerr:= i.BaseService.Dispatch(ctx,mid,nil)
{{- end }} {{/* end of input needed */}}
    f:=NewFuture{{$svcDiff}}{{$methCamel}}()
    if kerr!=syscall.KernelErr_NoError{
        f.CompleteMethod(ctx,nil, 1,syscallguest.CurrentHostId())/*dispatch error*/
        return f
     }

    ctx, t:=lib.CurrentTime(ctx)
    source:=syscallguest.CurrentHostId()
    syscallguest.MatchCompleter(ctx,t,source,targetHid,cid,f)
    return f
}
{{- end}} {{/*ranging over methods*/}}
{{- end}} {{/*ranging over services*/}}
