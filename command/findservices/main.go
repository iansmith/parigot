package main

import (
	"bufio"
	"bytes"
	"embed"
	_ "embed"
	"flag"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	structure "github.com/iansmith/parigot/command/toml"
)

//go:embed template/*
var templateFS embed.FS

type SearchResult struct {
	Root          string                            // where did we start searching
	ProjectsFound map[string]*structure.ProjectDecl // converts path to project marker to ProjectDecl
}

var dumpFoundTree = flag.Bool("d", false, "dump a tree of the results found")
var codeGen = flag.Bool("g", true, "suppress code gen")

func main() {

	flag.Parse()
	if flag.NArg() == 0 || flag.NArg() > 1 {
		log.Fatal("you need to pass in one directory to search recursively for .p.toml files")
	}
	result := searchForProjects(flag.Arg(0))
	if *dumpFoundTree {
		var buf bytes.Buffer
		buf.WriteString(flag.Arg(0) + "\n")
		for markerFile, project := range result.ProjectsFound {
			buf.WriteString("  Marker:" + markerFile + "\n")
			buf.WriteString("  GoModule:" + project.GoModule + "\n")
			for tomlFile, tomlConfig := range project.ServicesFound {
				buf.WriteString("    " + tomlConfig.Name + "(found in:" + tomlFile + ")\n")
				buf.WriteString("    WasmServiceName:" + tomlConfig.WasmServiceName + "\n")
				buf.WriteString("    GoPackage:" + tomlConfig.GoPackage + "\n")
				buf.WriteString("    ProtoFile:" + tomlConfig.ProtoFile + "\n")
				buf.WriteString("    TargetDir:" + tomlConfig.TargetDir + "\n")
				for _, method := range tomlConfig.Method {
					buf.WriteString("      " + method.Name + "\n")
					buf.WriteString("      Input:" + method.Input + "\n")
					buf.WriteString("      Output:" + method.Output + "\n")
				}
			}
		}
		log.Printf("result:\n%s", buf.String())
	}
	if *codeGen {
		generateCode(result)
	}
}

func searchForProjects(path string) *SearchResult {
	s, err := os.Stat(path)
	if err != nil && !os.IsExist(err) {
		log.Fatalf("command line argument %s does not exist", path)
	}
	if err != nil {
		log.Fatalf("cannot open %s: %v", path, err)
	}

	if !s.IsDir() {
		log.Fatalf("command line argument %s is not a directory", path)
	}

	result := &SearchResult{
		Root:          path,
		ProjectsFound: make(map[string]*structure.ProjectDecl),
	}

	projectMarkerFiles := searchAndCollect("", "",
		path, func(s string) bool { return s == "go.mod" })
	for _, marker := range projectMarkerFiles {
		project := &structure.ProjectDecl{
			MarkerFile:    marker,
			Dir:           filepath.Dir(marker),
			GoModule:      parseModFileForModuleLine(marker, path),
			ServicesFound: make(map[string]*structure.ServiceDecl),
		}
		result.ProjectsFound[marker] = project
		// find the toml files generated by our protoc plugin
		tomlFiles := searchAndCollect("", "",
			project.Dir, func(s string) bool { return strings.HasSuffix(s, ".p.toml") })
		for _, tomlFile := range tomlFiles {
			parseTomlFile(tomlFile, project)
		}
	}
	return result
}

func searchAndCollect(searchMsg string, foundMsg string, current string, pred func(fn string) bool) []string {
	collectedFiles := []string{}
	dirent, err := os.ReadDir(current)
	if err != nil {
		log.Fatalf("failed reading directory [%v] %s:%v", current == "", current, err)
	}
	if searchMsg != "" {
		log.Printf("%s:%s", searchMsg, current)
	}
	for _, ent := range dirent {
		if !ent.IsDir() && !pred(ent.Name()) {
			continue
		}
		if !ent.IsDir() {
			collectedFiles = append(collectedFiles, filepath.Join(current, ent.Name()))
			if foundMsg != "" {
				log.Printf("--- %s:%s", foundMsg, ent.Name())
			}
			continue
		}
		childFiles := searchAndCollect(searchMsg, foundMsg, filepath.Join(current, ent.Name()), pred)
		collectedFiles = append(collectedFiles, childFiles...)
	}
	return collectedFiles
}
func parseModFileForModuleLine(filename string, start string) string {
	fp, err := os.Open(filename)
	if err != nil {
		log.Fatalf("opening %s:%v", filename, err)
	}
	b, err := io.ReadAll(fp)
	if err != nil {
		log.Fatalf("reading %s:%v", filename, err)
	}
	s := string(b)
	scanner := bufio.NewScanner(strings.NewReader(s))
	moduleName := ""
	// optionally, resize scanner's capacity for lines over 64K, see next example
	for scanner.Scan() {
		l := scanner.Text()
		if strings.Contains(l, "module") {
			smaller := strings.Replace(l, "module", "", 1)
			smallest := strings.TrimSpace(smaller)
			if len(smallest) == 0 {
				log.Fatalf("unable to understand line in module file '%s'", l)
			}
			moduleName = smallest
			break
		}
	}
	if moduleName == "" {
		log.Fatalf("Unable to parse module file %s", filepath.Join(start, filename))
	}
	return moduleName
}

func parseTomlFile(tomlPath string, project *structure.ProjectDecl) {
	conf := structure.ParseTomlFile(tomlPath, project)
	//xxx ugh, awful, we should be getting this from the protogen world in protoc-gen-parigot
	last := strings.LastIndex(tomlPath, string(os.PathSeparator))
	if last == -1 {
		log.Fatalf("unable to understand your setup, because toml file found to be %s, not in a generated directory", tomlPath)
	}
	for _, tomlDecl := range conf.Service {
		targetDir := tomlPath[:last]
		tomlDecl.TargetDir = targetDir
		//tomlDecl.TargetDir = targetDir
		project.ServicesFound[tomlPath] = &tomlDecl
	}
}
