package main

import (
	"bufio"
	"bytes"
	"embed"
	_ "embed"
	"flag"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/BurntSushi/toml"
)

//go:embed template/*
var templateFS embed.FS

type SearchResult struct {
	Root          string                  // where did we start searching
	ProjectsFound map[string]*ProjectDesc // converts path to project marker to ProjectDesc
}

type ProjectDesc struct {
	Dir           string               // path to the dir containing go.mod for go projects
	MarkerFile    string               // path to the go.mod indicating project root
	GoModule      string               // name of the module inside the module file
	ServicesFound map[string]*TomlDecl // converts a path to toml file into its contents
}

type TomlDecl struct {
	Name            string // service name
	ProtoFile       string // path to the proto file
	TomlFile        string // path of the toml file we generated
	WasmServiceName string // optional comment on the service name
	GoPackage       string // listed as "go_package" in the proto file
	TargetDir       string // where to place generated output, this is the directory with the p.toml
}
type TomlConfig struct {
	Parigot map[string]TomlDecl
}

var dumpFoundTree = flag.Bool("d", false, "dump a tree of the results found")

func main() {

	flag.Parse()
	if flag.NArg() == 0 || flag.NArg() > 1 {
		log.Fatal("you need to pass in one directory to search recursively for .p.toml files")
	}
	result := searchForProjects(flag.Arg(0))
	if *dumpFoundTree {
		var buf bytes.Buffer
		buf.WriteString(flag.Arg(0) + "\n")
		for markerFile, project := range result.ProjectsFound {
			buf.WriteString("  Marker:" + markerFile + "\n")
			buf.WriteString("  GoModule:" + project.GoModule + "\n")
			for tomlFile, tomlConfig := range project.ServicesFound {
				buf.WriteString("    " + tomlConfig.Name + "(found in:" + tomlFile + ")\n")
				buf.WriteString("    WasmServiceName:" + tomlConfig.WasmServiceName + "\n")
				buf.WriteString("    GoPackage:" + tomlConfig.GoPackage + "\n")
				buf.WriteString("    ProtoFile:" + tomlConfig.ProtoFile + "\n")
				buf.WriteString("    TargetDir:" + tomlConfig.TargetDir + "\n")
			}
		}
		log.Printf("result:\n%s", buf.String())
	}
	generateCode(result)
}

func searchForProjects(path string) *SearchResult {
	s, err := os.Stat(path)
	if err != nil && !os.IsExist(err) {
		log.Fatalf("command line argument %s does not exist", path)
	}
	if err != nil {
		log.Fatalf("cannot open %s: %v", path, err)
	}

	if !s.IsDir() {
		log.Fatalf("command line argument %s is not a directory", path)
	}

	result := &SearchResult{
		Root:          path,
		ProjectsFound: make(map[string]*ProjectDesc),
	}

	projectMarkerFiles := searchAndCollect("", "",
		path, func(s string) bool { return s == "go.mod" })
	for _, marker := range projectMarkerFiles {
		project := &ProjectDesc{
			MarkerFile:    marker,
			Dir:           filepath.Dir(marker),
			GoModule:      parseModFileForModuleLine(marker),
			ServicesFound: make(map[string]*TomlDecl),
		}
		result.ProjectsFound[marker] = project
		// find the toml files generated by our protoc plugin
		tomlFiles := searchAndCollect("", "",
			project.Dir, func(s string) bool { return strings.HasSuffix(s, ".p.toml") })
		for _, tomlFile := range tomlFiles {
			parseTomlFile(tomlFile, project)
		}
	}
	return result
}

func searchAndCollect(searchMsg string, foundMsg string, current string, pred func(fn string) bool) []string {
	collectedFiles := []string{}
	dirent, err := os.ReadDir(current)
	if err != nil {
		log.Fatalf("failed reading directory [%v] %s:%v", current == "", current, err)
	}
	if searchMsg != "" {
		log.Printf("%s:%s", searchMsg, current)
	}
	for _, ent := range dirent {
		if !ent.IsDir() && !pred(ent.Name()) {
			continue
		}
		if !ent.IsDir() {
			collectedFiles = append(collectedFiles, filepath.Join(current, ent.Name()))
			if foundMsg != "" {
				log.Printf("--- %s:%s", foundMsg, ent.Name())
			}
			continue
		}
		childFiles := searchAndCollect(searchMsg, foundMsg, filepath.Join(current, ent.Name()), pred)
		collectedFiles = append(collectedFiles, childFiles...)
	}
	return collectedFiles
}
func parseModFileForModuleLine(filename string) string {
	fp, err := os.Open(filename)
	if err != nil {
		log.Fatalf("opening %s:%v", filename, err)
	}
	b, err := io.ReadAll(fp)
	if err != nil {
		log.Fatalf("reading %s:%v", filename, err)
	}
	s := string(b)
	scanner := bufio.NewScanner(strings.NewReader(s))
	moduleName := ""
	// optionally, resize scanner's capacity for lines over 64K, see next example
	for scanner.Scan() {
		l := scanner.Text()
		if strings.Contains(l, "module") {
			smaller := strings.Replace(l, "module", "", 1)
			smallest := strings.TrimSpace(smaller)
			if len(smallest) == 0 {
				log.Fatalf("unable to understand line in module file '%s'", l)
			}
			moduleName = smallest
			break
		}
	}
	if moduleName == "" {
		log.Fatal("Unable to parse module file %s", filename)
	}
	return moduleName
}

func parseTomlFile(tomlPath string, project *ProjectDesc) {
	fp, err := os.Open(tomlPath)
	if err != nil {
		log.Fatalf("unable to open %s:%v", tomlPath, err)
	}
	defer fp.Close()
	b, err := io.ReadAll(fp)
	if err != nil {
		log.Fatalf("unable to read %s:%v", tomlPath, err)
	}
	dec := toml.NewDecoder(strings.NewReader(string(b)))
	var conf TomlConfig
	_, err = dec.Decode(&conf)
	if err != nil {
		log.Fatalf("unable to understand toml file %s:%v", tomlPath, err)
	}
	//xxx ugh, awful, we should be getting this from the protogen world in protoc-gen-parigot
	last := strings.LastIndex(tomlPath, string(os.PathSeparator))
	if last == -1 {
		log.Fatalf("unable to understand your setup, because toml file found to be %s, not in a generated directory", tomlPath)
	}
	targetDir := tomlPath[:last]
	for _, tomlDecl := range conf.Parigot {
		tomlDecl.TargetDir = targetDir
		project.ServicesFound[tomlPath] = &tomlDecl
	}
}

func generateCode(result *SearchResult) {
	tmpl := template.Must(template.ParseFS(templateFS, "template/*.tmpl"))
	err := tmpl.ExecuteTemplate(os.Stdout, "servicedecls.tmpl", "foo")
	if err != nil {
		log.Fatalf("unable to execute template: ")
	}
}
