//go:build wasip1 

// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: file/v1/file.proto

package file


import(
    "context" 

    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
    lib "github.com/iansmith/parigot/lib/go"  
    "github.com/iansmith/parigot/lib/go/future"  
    "github.com/iansmith/parigot/lib/go/client"  
    "github.com/iansmith/parigot/api/shared/id"
    syscall "github.com/iansmith/parigot/g/syscall/v1" 

    "google.golang.org/protobuf/proto"


)  
//
// File from file/v1/file.proto
//
//service interface
type File interface {
    Open(ctx context.Context,in *OpenRequest) *FutureOpen  
    Create(ctx context.Context,in *CreateRequest) *FutureCreate  
    Close(ctx context.Context,in *CloseRequest) *FutureClose  
    LoadTestData(ctx context.Context,in *LoadTestDataRequest) *FutureLoadTestData  
    Read(ctx context.Context,in *ReadRequest) *FutureRead  
    Write(ctx context.Context,in *WriteRequest) *FutureWrite  
    Delete(ctx context.Context,in *DeleteRequest) *FutureDelete   
    Ready(context.Context,id.ServiceId) *future.Base[bool]
}

type Client interface {
    Open(ctx context.Context,in *OpenRequest) *FutureOpen  
    Create(ctx context.Context,in *CreateRequest) *FutureCreate  
    Close(ctx context.Context,in *CloseRequest) *FutureClose  
    LoadTestData(ctx context.Context,in *LoadTestDataRequest) *FutureLoadTestData  
    Read(ctx context.Context,in *ReadRequest) *FutureRead  
    Write(ctx context.Context,in *WriteRequest) *FutureWrite  
    Delete(ctx context.Context,in *DeleteRequest) *FutureDelete   
}

// Client difference from File: Ready() 
type Client_ struct {
    *client.BaseService
}
// Check that Client_ is a Client.
var _ = Client(&Client_{})

//
// method: File.Open 
//
type FutureOpen struct {
    Method *future.Method[*OpenResponse,FileErr]
} 

// This is the same API for output needed or not because of the Completer interface.
func (f * FutureOpen) CompleteMethod(ctx context.Context,a proto.Message, e int32) {
    result:= a.(*OpenResponse)
    f.Method.CompleteMethod(ctx,result,FileErr(e)) 
}
func (f *FutureOpen)Success(sfn func (proto.Message)) {
    x:=func(m *OpenResponse){
        sfn(m)
    }
    f.Method.Success(x)
} 

func (f *FutureOpen)Failure(ffn func (int32)) {
    x:=func(err FileErr) {
        ffn(int32(err))
    }
    f.Method.Failure(x) 
}
func NewFutureOpen() *FutureOpen {
    f:=&FutureOpen{
        Method: future.NewMethod[*OpenResponse,FileErr](nil,nil),
    } 
    return f
}
func (i *Client_) Open(ctx context.Context, in *OpenRequest) *FutureOpen { 
    mid, ok := i.BaseService.MethodIdByName("Open")
    if !ok {
        f:=NewFutureOpen()
        f.CompleteMethod(ctx,nil,1)/*dispatch error*/
    }
    cid,kerr:= i.BaseService.Dispatch(mid,in) 
    f:=NewFutureOpen()
    if kerr!=syscall.KernelErr_NoError{
        f.CompleteMethod(ctx,nil, 1)/*dispatch error*/
        return f
     }
    lib.MatchCompleter(cid,f)
    return f
}

//
// method: File.Create 
//
type FutureCreate struct {
    Method *future.Method[*CreateResponse,FileErr]
} 

// This is the same API for output needed or not because of the Completer interface.
func (f * FutureCreate) CompleteMethod(ctx context.Context,a proto.Message, e int32) {
    result:= a.(*CreateResponse)
    f.Method.CompleteMethod(ctx,result,FileErr(e)) 
}
func (f *FutureCreate)Success(sfn func (proto.Message)) {
    x:=func(m *CreateResponse){
        sfn(m)
    }
    f.Method.Success(x)
} 

func (f *FutureCreate)Failure(ffn func (int32)) {
    x:=func(err FileErr) {
        ffn(int32(err))
    }
    f.Method.Failure(x) 
}
func NewFutureCreate() *FutureCreate {
    f:=&FutureCreate{
        Method: future.NewMethod[*CreateResponse,FileErr](nil,nil),
    } 
    return f
}
func (i *Client_) Create(ctx context.Context, in *CreateRequest) *FutureCreate { 
    mid, ok := i.BaseService.MethodIdByName("Create")
    if !ok {
        f:=NewFutureCreate()
        f.CompleteMethod(ctx,nil,1)/*dispatch error*/
    }
    cid,kerr:= i.BaseService.Dispatch(mid,in) 
    f:=NewFutureCreate()
    if kerr!=syscall.KernelErr_NoError{
        f.CompleteMethod(ctx,nil, 1)/*dispatch error*/
        return f
     }
    lib.MatchCompleter(cid,f)
    return f
}

//
// method: File.Close 
//
type FutureClose struct {
    Method *future.Method[*CloseResponse,FileErr]
} 

// This is the same API for output needed or not because of the Completer interface.
func (f * FutureClose) CompleteMethod(ctx context.Context,a proto.Message, e int32) {
    result:= a.(*CloseResponse)
    f.Method.CompleteMethod(ctx,result,FileErr(e)) 
}
func (f *FutureClose)Success(sfn func (proto.Message)) {
    x:=func(m *CloseResponse){
        sfn(m)
    }
    f.Method.Success(x)
} 

func (f *FutureClose)Failure(ffn func (int32)) {
    x:=func(err FileErr) {
        ffn(int32(err))
    }
    f.Method.Failure(x) 
}
func NewFutureClose() *FutureClose {
    f:=&FutureClose{
        Method: future.NewMethod[*CloseResponse,FileErr](nil,nil),
    } 
    return f
}
func (i *Client_) Close(ctx context.Context, in *CloseRequest) *FutureClose { 
    mid, ok := i.BaseService.MethodIdByName("Close")
    if !ok {
        f:=NewFutureClose()
        f.CompleteMethod(ctx,nil,1)/*dispatch error*/
    }
    cid,kerr:= i.BaseService.Dispatch(mid,in) 
    f:=NewFutureClose()
    if kerr!=syscall.KernelErr_NoError{
        f.CompleteMethod(ctx,nil, 1)/*dispatch error*/
        return f
     }
    lib.MatchCompleter(cid,f)
    return f
}

//
// method: File.LoadTestData 
//
type FutureLoadTestData struct {
    Method *future.Method[*LoadTestDataResponse,FileErr]
} 

// This is the same API for output needed or not because of the Completer interface.
func (f * FutureLoadTestData) CompleteMethod(ctx context.Context,a proto.Message, e int32) {
    result:= a.(*LoadTestDataResponse)
    f.Method.CompleteMethod(ctx,result,FileErr(e)) 
}
func (f *FutureLoadTestData)Success(sfn func (proto.Message)) {
    x:=func(m *LoadTestDataResponse){
        sfn(m)
    }
    f.Method.Success(x)
} 

func (f *FutureLoadTestData)Failure(ffn func (int32)) {
    x:=func(err FileErr) {
        ffn(int32(err))
    }
    f.Method.Failure(x) 
}
func NewFutureLoadTestData() *FutureLoadTestData {
    f:=&FutureLoadTestData{
        Method: future.NewMethod[*LoadTestDataResponse,FileErr](nil,nil),
    } 
    return f
}
func (i *Client_) LoadTestData(ctx context.Context, in *LoadTestDataRequest) *FutureLoadTestData { 
    mid, ok := i.BaseService.MethodIdByName("LoadTestData")
    if !ok {
        f:=NewFutureLoadTestData()
        f.CompleteMethod(ctx,nil,1)/*dispatch error*/
    }
    cid,kerr:= i.BaseService.Dispatch(mid,in) 
    f:=NewFutureLoadTestData()
    if kerr!=syscall.KernelErr_NoError{
        f.CompleteMethod(ctx,nil, 1)/*dispatch error*/
        return f
     }
    lib.MatchCompleter(cid,f)
    return f
}

//
// method: File.Read 
//
type FutureRead struct {
    Method *future.Method[*ReadResponse,FileErr]
} 

// This is the same API for output needed or not because of the Completer interface.
func (f * FutureRead) CompleteMethod(ctx context.Context,a proto.Message, e int32) {
    result:= a.(*ReadResponse)
    f.Method.CompleteMethod(ctx,result,FileErr(e)) 
}
func (f *FutureRead)Success(sfn func (proto.Message)) {
    x:=func(m *ReadResponse){
        sfn(m)
    }
    f.Method.Success(x)
} 

func (f *FutureRead)Failure(ffn func (int32)) {
    x:=func(err FileErr) {
        ffn(int32(err))
    }
    f.Method.Failure(x) 
}
func NewFutureRead() *FutureRead {
    f:=&FutureRead{
        Method: future.NewMethod[*ReadResponse,FileErr](nil,nil),
    } 
    return f
}
func (i *Client_) Read(ctx context.Context, in *ReadRequest) *FutureRead { 
    mid, ok := i.BaseService.MethodIdByName("Read")
    if !ok {
        f:=NewFutureRead()
        f.CompleteMethod(ctx,nil,1)/*dispatch error*/
    }
    cid,kerr:= i.BaseService.Dispatch(mid,in) 
    f:=NewFutureRead()
    if kerr!=syscall.KernelErr_NoError{
        f.CompleteMethod(ctx,nil, 1)/*dispatch error*/
        return f
     }
    lib.MatchCompleter(cid,f)
    return f
}

//
// method: File.Write 
//
type FutureWrite struct {
    Method *future.Method[*WriteResponse,FileErr]
} 

// This is the same API for output needed or not because of the Completer interface.
func (f * FutureWrite) CompleteMethod(ctx context.Context,a proto.Message, e int32) {
    result:= a.(*WriteResponse)
    f.Method.CompleteMethod(ctx,result,FileErr(e)) 
}
func (f *FutureWrite)Success(sfn func (proto.Message)) {
    x:=func(m *WriteResponse){
        sfn(m)
    }
    f.Method.Success(x)
} 

func (f *FutureWrite)Failure(ffn func (int32)) {
    x:=func(err FileErr) {
        ffn(int32(err))
    }
    f.Method.Failure(x) 
}
func NewFutureWrite() *FutureWrite {
    f:=&FutureWrite{
        Method: future.NewMethod[*WriteResponse,FileErr](nil,nil),
    } 
    return f
}
func (i *Client_) Write(ctx context.Context, in *WriteRequest) *FutureWrite { 
    mid, ok := i.BaseService.MethodIdByName("Write")
    if !ok {
        f:=NewFutureWrite()
        f.CompleteMethod(ctx,nil,1)/*dispatch error*/
    }
    cid,kerr:= i.BaseService.Dispatch(mid,in) 
    f:=NewFutureWrite()
    if kerr!=syscall.KernelErr_NoError{
        f.CompleteMethod(ctx,nil, 1)/*dispatch error*/
        return f
     }
    lib.MatchCompleter(cid,f)
    return f
}

//
// method: File.Delete 
//
type FutureDelete struct {
    Method *future.Method[*DeleteResponse,FileErr]
} 

// This is the same API for output needed or not because of the Completer interface.
func (f * FutureDelete) CompleteMethod(ctx context.Context,a proto.Message, e int32) {
    result:= a.(*DeleteResponse)
    f.Method.CompleteMethod(ctx,result,FileErr(e)) 
}
func (f *FutureDelete)Success(sfn func (proto.Message)) {
    x:=func(m *DeleteResponse){
        sfn(m)
    }
    f.Method.Success(x)
} 

func (f *FutureDelete)Failure(ffn func (int32)) {
    x:=func(err FileErr) {
        ffn(int32(err))
    }
    f.Method.Failure(x) 
}
func NewFutureDelete() *FutureDelete {
    f:=&FutureDelete{
        Method: future.NewMethod[*DeleteResponse,FileErr](nil,nil),
    } 
    return f
}
func (i *Client_) Delete(ctx context.Context, in *DeleteRequest) *FutureDelete { 
    mid, ok := i.BaseService.MethodIdByName("Delete")
    if !ok {
        f:=NewFutureDelete()
        f.CompleteMethod(ctx,nil,1)/*dispatch error*/
    }
    cid,kerr:= i.BaseService.Dispatch(mid,in) 
    f:=NewFutureDelete()
    if kerr!=syscall.KernelErr_NoError{
        f.CompleteMethod(ctx,nil, 1)/*dispatch error*/
        return f
     }
    lib.MatchCompleter(cid,f)
    return f
}  
