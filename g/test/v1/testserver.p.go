//go:build wasip1 

// Code generated by protoc-gen-parigot. DO NOT EDIT.
// source: test/v1/test.proto

package test




import (
	"context"
    "unsafe" 
    // this set of imports is _unrelated_ to the particulars of what the .proto imported... those are above
	syscallguest "github.com/iansmith/parigot/api/guest/syscall"  
	pcontext "github.com/iansmith/parigot/context"
	lib "github.com/iansmith/parigot/lib/go"
	"github.com/iansmith/parigot/g/syscall/v1"
	"github.com/iansmith/parigot/api/shared/id"
	"github.com/iansmith/parigot/lib/go/future"
	"github.com/iansmith/parigot/lib/go/client"

	"google.golang.org/protobuf/types/known/anypb"
	"google.golang.org/protobuf/proto"

)
var _ =  unsafe.Sizeof([]byte{})

 
func LaunchTest(ctx context.Context, sid id.ServiceId, impl Test) *future.Base[bool] {

	defer func() {
		pcontext.Dump(ctx)
	}()

	readyResult:=future.NewBase[bool]()

	ready:=impl.Ready(ctx,sid)
	ready.Handle(func (b bool) {
		if b {
			readyResult.Set(true)			
			return
		}
		pcontext.Errorf(ctx,"Unable to start test.v1.Test, Ready returned false")
		pcontext.Dump(ctx)
		readyResult.Set(false)
	})

	return readyResult
}

func InitTest(ctx context.Context,require []lib.MustRequireFunc, impl Test) *lib.ServiceMethodMap{
	defer func() {
		if r := recover(); r != nil {
			pcontext.Infof(ctx, "InitTest: trapped a panic in the guest side: %v", r)
		}
		pcontext.Dump(ctx)
	}()

	myId := MustRegisterTest(ctx)
	MustExportTest(ctx,myId)
	if len(require)>0 {
		for _, f := range require {
			f(ctx, myId)
		}
	}
	smmap:=MustLaunchServiceTest(ctx, myId, impl)
	launchF:=LaunchTest(ctx, myId, impl)

	// kinda tricky: if this get resolved this exit occurs on the
	// call stack of the code that called Set().
	launchF.Handle(func (ready bool) {
		if !ready {
			pcontext.Errorf(ctx, "ready call on Test failed")
			lib.ExitClient(ctx, 1, myId, "unable to Launch in InitTest",
				"unable to call Exit in InitTest")
		}
	})
	return smmap
}
func RunTest(ctx context.Context,
	binding *lib.ServiceMethodMap, timeoutInMillis int32, bg lib.Backgrounder) syscall.KernelErr{
	defer func() {
		if r := recover(); r != nil {
			pcontext.Infof(ctx, "RunTest: trapped a panic in the guest side: %v", r)
		}
		pcontext.Dump(ctx)
	}()
	var kerr syscall.KernelErr
	for {
		pctx:=pcontext.CallTo(ctx,"ReadOneAndCallTest")
		kerr:=ReadOneAndCallTest(pctx, binding, timeoutInMillis)
		pcontext.Dump(pctx)
		if kerr == syscall.KernelErr_ReadOneTimeout {
			if bg==nil {
				continue
			}
			pcontext.Infof(ctx,"calling backgrounder of Test")
			bgctx:=pcontext.CallTo(ctx,"Background")
			bg.Background(bgctx)
			pcontext.Dump(bgctx)
			continue
		}
		if kerr == syscall.KernelErr_NoError {
			continue
		}
		break
	}
	pcontext.Errorf(ctx, "error while waiting for Test service calls: %s", syscall.KernelErr_name[int32(kerr)])
	return kerr
}

var TimeoutInMillisTest = int32(500)

func ReadOneAndCallTest(ctx context.Context, binding *lib.ServiceMethodMap, 
	timeoutInMillis int32) syscall.KernelErr{
	req:=syscall.ReadOneRequest{}

	// makes a copy
	for _, c := range binding.Call() {
		req.Call=append(req.Call, c)
	}

	req.TimeoutInMillis = timeoutInMillis
	req.HostId = lib.CurrentHostId().Marshal()
	resp, err:=syscallguest.ReadOne(&req)
	if err!=syscall.KernelErr_NoError {
		return err
	}
	// is timeout?
	if resp.Timeout {
		return syscall.KernelErr_ReadOneTimeout
	}

	// check for finished futures from within our address space
	lib.ExpireMethod(ctx)

	// is a promise being completed that was fulfilled somewhere else
	if r:=resp.GetResolved(); r!=nil {
		cid:=id.UnmarshalCallId(r.GetCallId())
		lib.CompleteCall(ctx, cid,r.GetResult(), r.GetResultError())
		return syscall.KernelErr_NoError
	}

	// its a method call from another address space
	sid:=id.UnmarshalServiceId(resp.GetCall().GetServiceId())
	mid:=id.UnmarshalMethodId(resp.GetCall().GetMethodId())
	cid:=id.UnmarshalCallId(resp.GetCallId())
	fn:=binding.Func(sid,mid)
	if fn==nil {
		pcontext.Errorf(ctx,"unable to find service/method pair binding: service=%s, method=%s",
			sid.Short(), mid.Short())
		return syscall.KernelErr_NotFound
	}
	// we let the invoker handle the unmarshal from anypb.Any because it
	// knows the precise type to be consumed
	fut:=fn.Invoke(ctx,resp.GetParam())
	fut.Success(func (result proto.Message){
		rvReq:=&syscall.ReturnValueRequest{}
		rvReq.CallId= cid.Marshal()
		rvReq.HostId= lib.CurrentHostId().Marshal()
		var a anypb.Any
		if err:=a.MarshalFrom(result); err!=nil {
			pcontext.Errorf(ctx, "unable to marshal result for return value request")
			return
		}
		rvReq.Result = &a
		rvReq.ResultError = 0
		syscallguest.ReturnValue(rvReq) // nowhere for return value to go
	})
	fut.Failure(func (err int32) {
		rvReq:=&syscall.ReturnValueRequest{}
		rvReq.CallId= cid.Marshal()
		rvReq.HostId= lib.CurrentHostId().Marshal()
		rvReq.ResultError = err
		syscallguest.ReturnValue(rvReq) // nowhere for return value to go
	})
	return syscall.KernelErr_NoError

}

func testbind(ctx context.Context,sid id.ServiceId, impl Test) (*lib.ServiceMethodMap, syscall.KernelErr) {
	smmap:=lib.NewServiceMethodMap()
	var mid id.MethodId
	var bindReq *syscall.BindMethodRequest
	var resp *syscall.BindMethodResponse
	var err syscall.KernelErr
//
// test.v1.Test.AddTestSuite
//

	bindReq = &syscall.BindMethodRequest{}
	bindReq.HostId = lib.CurrentHostId().Marshal()
	bindReq.ServiceId = sid.Marshal()
	bindReq.MethodName = "AddTestSuite"
	resp, err=syscallguest.BindMethod(bindReq)
	if err!=syscall.KernelErr_NoError {
		return nil, err
	}
	mid=id.UnmarshalMethodId(resp.GetMethodId())

	// completer already prepared elsewhere
	smmap.AddServiceMethod(sid,mid,"Test","TestAddTestSuite",
		GenerateTestAddTestSuiteInvoker(impl))
//
// test.v1.Test.Start
//

	bindReq = &syscall.BindMethodRequest{}
	bindReq.HostId = lib.CurrentHostId().Marshal()
	bindReq.ServiceId = sid.Marshal()
	bindReq.MethodName = "Start"
	resp, err=syscallguest.BindMethod(bindReq)
	if err!=syscall.KernelErr_NoError {
		return nil, err
	}
	mid=id.UnmarshalMethodId(resp.GetMethodId())

	// completer already prepared elsewhere
	smmap.AddServiceMethod(sid,mid,"Test","TestStart",
		GenerateTestStartInvoker(impl)) 
	pcontext.Dump(ctx)
	return smmap,syscall.KernelErr_NoError
}

// Locate finds a reference to the client interface of test.  
func LocateTest(ctx context.Context,sid id.ServiceId) (ClientTest,syscall.KernelErr) {
    cs, kerr:=client.LocateDynamic(ctx, "test.v1","test", sid)
    if kerr!=syscall.KernelErr_NoError{
        return nil, kerr
    }
    return &ClientTest_{
        BaseService: cs,
    },syscall.KernelErr_NoError
}

func MustLocateTest(ctx context.Context, sid id.ServiceId) ClientTest {
    result, err:=LocateTest(ctx, sid)
    name:=syscall.KernelErr_name[int32(err)]
    normal:="unable to locate test.v1.test:"+name
    if err!=0 {
        pcontext.Debugf(ctx,"kernel error was  %s",name)
        if err == syscall.KernelErr_NotRequired {
            pcontext.Errorf(ctx,"service was located, but it was not required")
            panic("locate attempted on a service that was not required")
        }
        panic(normal)
    }
    return result
}


func RegisterTest(ctx context.Context) (id.ServiceId, syscall.KernelErr){
    req := &syscall.RegisterRequest{}
	fqs := &syscall.FullyQualifiedService{
		PackagePath: "test.v1",
		Service:     "test",
	}
	req.Fqs = fqs
	req.HostId = lib.CurrentHostId().Marshal()

	resp, err := syscallguest.Register(req)
    if err!=syscall.KernelErr_NoError{
        return id.ServiceIdZeroValue(), err
    }
    sid:=id.UnmarshalServiceId(resp.Id)
    if sid.IsZeroOrEmptyValue() {
        panic("received bad service Id from register")
    }

    return sid,syscall.KernelErr_NoError
}
func MustRegisterTest(ctx context.Context) id.ServiceId {
    sid, err:=RegisterTest(ctx)
    if err!=syscall.KernelErr_NoError {
        pcontext.Fatalf(ctx,"unable to register %s.%s","test.v1","test")
        panic("unable to register "+"test")
    }
    return sid
}

func MustRequireTest(ctx context.Context, sid id.ServiceId) {
    _, err:=lib.Require1("test.v1","test",sid)
    if err!=syscall.KernelErr_NoError {
        if err==syscall.KernelErr_DependencyCycle{
            pcontext.Errorf(ctx,"unable to require %s.%s because it creates a dependcy loop: %s","test.v1","test",syscall.KernelErr_name[int32(err)])
            panic("require test.v1.test creates a dependency loop")
        }
        pcontext.Errorf(ctx,"unable to require %s.%s:%s","test.v1","test",syscall.KernelErr_name[int32(err)])
        panic("not able to require test.v1.test:"+syscall.KernelErr_name[int32(err)])
    }
}

func MustExportTest(ctx context.Context, sid id.ServiceId) {
    _, err:=lib.Export1("test.v1","test",sid)
    if err!=syscall.KernelErr_NoError{
        pcontext.Fatalf(ctx, "unable to export %s.%s","test.v1","test")
        panic("not able to export test.v1.test:"+syscall.KernelErr_name[int32(err)])
    }
}

func LaunchServiceTest(ctx context.Context, sid id.ServiceId, impl Test) (*lib.ServiceMethodMap,syscall.KernelErr) {
	smmap, err:=testbind(ctx,sid, impl)
	if err!=0{
		return  nil,syscall.KernelErr(err)
	}

    s:=sid.Marshal()
	syscallguest.Launch(&syscall.LaunchRequest{ServiceId:s })

    return smmap,syscall.KernelErr_NoError
}

func MustLaunchServiceTest(ctx context.Context, sid id.ServiceId, impl Test) *lib.ServiceMethodMap {
    smmap,err:=LaunchServiceTest(ctx,sid,impl)
    if err!=syscall.KernelErr_NoError {
        panic("Unable to call LaunchService successfully: "+syscall.KernelErr_name[int32(err)])
    }
    return smmap
}


// If you want to implement part of your server in host cost you should call 
// Test<methodName>Host from your server implementation. These will be optimized 
// away by the compiler if you don't use them--in other words, if you want to 
// implement everything on the guest side).
// 

//go:wasmimport test add_test_suiteTest_
func AddTestSuite_(int32,int32,int32,int32) int64
func AddTestSuiteTestHost(ctx context.Context,inPtr *AddTestSuiteRequest) *FutureTestAddTestSuite {
	outProtoPtr := (*AddTestSuiteResponse)(nil)
	defer pcontext.Dump(ctx)
	ret, raw, signal:= syscallguest.ClientSide(ctx, inPtr, outProtoPtr, AddTestSuite_)
	if signal {
		pcontext.Infof(ctx, "AddTestSuite exiting because of parigot signal")
		pcontext.Dump(ctx)
		lib.ExitClient(ctx, 1, id.NewServiceId(), "xxx warning, no implementation of unsolicited exit",
			"xxx warning, no implementation of unsolicited exit and failed trying to exit")
	}
	f:=NewFutureTestAddTestSuite()
	f.CompleteMethod(ctx,ret,raw)
	return f
} 

//go:wasmimport test startTest_
func Start_(int32,int32,int32,int32) int64
func StartTestHost(ctx context.Context,inPtr *StartRequest) *FutureTestStart {
	outProtoPtr := (*StartResponse)(nil)
	defer pcontext.Dump(ctx)
	ret, raw, signal:= syscallguest.ClientSide(ctx, inPtr, outProtoPtr, Start_)
	if signal {
		pcontext.Infof(ctx, "Start exiting because of parigot signal")
		pcontext.Dump(ctx)
		lib.ExitClient(ctx, 1, id.NewServiceId(), "xxx warning, no implementation of unsolicited exit",
			"xxx warning, no implementation of unsolicited exit and failed trying to exit")
	}
	f:=NewFutureTestStart()
	f.CompleteMethod(ctx,ret,raw)
	return f
}  

// This is interface for invocation.
type invokeTestAddTestSuite struct {
    fn func(context.Context,*AddTestSuiteRequest) *FutureTestAddTestSuite
}

func (t *invokeTestAddTestSuite) Invoke(ctx context.Context,a *anypb.Any) future.Completer {
	// xxx AddTestSuiteRequest and 'AddTestSuiteRequest{}' why empty?
    in:=&AddTestSuiteRequest{}
    err:=a.UnmarshalTo(in)
    if err!=nil {
        pcontext.Errorf(ctx,"unmarshal inside Invoke() failed: %s",err.Error())
        return nil
    }
    return t.fn(ctx,in) 

}

func GenerateTestAddTestSuiteInvoker(impl Test) future.Invoker {
	return &invokeTestAddTestSuite{fn:impl.TestAddTestSuite} 
}

// This is interface for invocation.
type invokeTestStart struct {
    fn func(context.Context,*StartRequest) *FutureTestStart
}

func (t *invokeTestStart) Invoke(ctx context.Context,a *anypb.Any) future.Completer {
	// xxx StartRequest and 'StartRequest{}' why empty?
    in:=&StartRequest{}
    err:=a.UnmarshalTo(in)
    if err!=nil {
        pcontext.Errorf(ctx,"unmarshal inside Invoke() failed: %s",err.Error())
        return nil
    }
    return t.fn(ctx,in) 

}

func GenerateTestStartInvoker(impl Test) future.Invoker {
	return &invokeTestStart{fn:impl.TestStart} 
} 

 
func LaunchMethodCallSuite(ctx context.Context, sid id.ServiceId, impl MethodCallSuite) *future.Base[bool] {

	defer func() {
		pcontext.Dump(ctx)
	}()

	readyResult:=future.NewBase[bool]()

	ready:=impl.Ready(ctx,sid)
	ready.Handle(func (b bool) {
		if b {
			readyResult.Set(true)			
			return
		}
		pcontext.Errorf(ctx,"Unable to start test.v1.MethodCallSuite, Ready returned false")
		pcontext.Dump(ctx)
		readyResult.Set(false)
	})

	return readyResult
}

func InitMethodCallSuite(ctx context.Context,require []lib.MustRequireFunc, impl MethodCallSuite) *lib.ServiceMethodMap{
	defer func() {
		if r := recover(); r != nil {
			pcontext.Infof(ctx, "InitMethodCallSuite: trapped a panic in the guest side: %v", r)
		}
		pcontext.Dump(ctx)
	}()

	myId := MustRegisterMethodCallSuite(ctx)
	MustExportMethodCallSuite(ctx,myId)
	if len(require)>0 {
		for _, f := range require {
			f(ctx, myId)
		}
	}
	smmap:=MustLaunchServiceMethodCallSuite(ctx, myId, impl)
	launchF:=LaunchMethodCallSuite(ctx, myId, impl)

	// kinda tricky: if this get resolved this exit occurs on the
	// call stack of the code that called Set().
	launchF.Handle(func (ready bool) {
		if !ready {
			pcontext.Errorf(ctx, "ready call on MethodCallSuite failed")
			lib.ExitClient(ctx, 1, myId, "unable to Launch in InitMethodCallSuite",
				"unable to call Exit in InitMethodCallSuite")
		}
	})
	return smmap
}
func RunMethodCallSuite(ctx context.Context,
	binding *lib.ServiceMethodMap, timeoutInMillis int32, bg lib.Backgrounder) syscall.KernelErr{
	defer func() {
		if r := recover(); r != nil {
			pcontext.Infof(ctx, "RunMethodCallSuite: trapped a panic in the guest side: %v", r)
		}
		pcontext.Dump(ctx)
	}()
	var kerr syscall.KernelErr
	for {
		pctx:=pcontext.CallTo(ctx,"ReadOneAndCallMethodCallSuite")
		kerr:=ReadOneAndCallMethodCallSuite(pctx, binding, timeoutInMillis)
		pcontext.Dump(pctx)
		if kerr == syscall.KernelErr_ReadOneTimeout {
			if bg==nil {
				continue
			}
			pcontext.Infof(ctx,"calling backgrounder of MethodCallSuite")
			bgctx:=pcontext.CallTo(ctx,"Background")
			bg.Background(bgctx)
			pcontext.Dump(bgctx)
			continue
		}
		if kerr == syscall.KernelErr_NoError {
			continue
		}
		break
	}
	pcontext.Errorf(ctx, "error while waiting for MethodCallSuite service calls: %s", syscall.KernelErr_name[int32(kerr)])
	return kerr
}

var TimeoutInMillisMethodCallSuite = int32(500)

func ReadOneAndCallMethodCallSuite(ctx context.Context, binding *lib.ServiceMethodMap, 
	timeoutInMillis int32) syscall.KernelErr{
	req:=syscall.ReadOneRequest{}

	// makes a copy
	for _, c := range binding.Call() {
		req.Call=append(req.Call, c)
	}

	req.TimeoutInMillis = timeoutInMillis
	req.HostId = lib.CurrentHostId().Marshal()
	resp, err:=syscallguest.ReadOne(&req)
	if err!=syscall.KernelErr_NoError {
		return err
	}
	// is timeout?
	if resp.Timeout {
		return syscall.KernelErr_ReadOneTimeout
	}

	// check for finished futures from within our address space
	lib.ExpireMethod(ctx)

	// is a promise being completed that was fulfilled somewhere else
	if r:=resp.GetResolved(); r!=nil {
		cid:=id.UnmarshalCallId(r.GetCallId())
		lib.CompleteCall(ctx, cid,r.GetResult(), r.GetResultError())
		return syscall.KernelErr_NoError
	}

	// its a method call from another address space
	sid:=id.UnmarshalServiceId(resp.GetCall().GetServiceId())
	mid:=id.UnmarshalMethodId(resp.GetCall().GetMethodId())
	cid:=id.UnmarshalCallId(resp.GetCallId())
	fn:=binding.Func(sid,mid)
	if fn==nil {
		pcontext.Errorf(ctx,"unable to find service/method pair binding: service=%s, method=%s",
			sid.Short(), mid.Short())
		return syscall.KernelErr_NotFound
	}
	// we let the invoker handle the unmarshal from anypb.Any because it
	// knows the precise type to be consumed
	fut:=fn.Invoke(ctx,resp.GetParam())
	fut.Success(func (result proto.Message){
		rvReq:=&syscall.ReturnValueRequest{}
		rvReq.CallId= cid.Marshal()
		rvReq.HostId= lib.CurrentHostId().Marshal()
		var a anypb.Any
		if err:=a.MarshalFrom(result); err!=nil {
			pcontext.Errorf(ctx, "unable to marshal result for return value request")
			return
		}
		rvReq.Result = &a
		rvReq.ResultError = 0
		syscallguest.ReturnValue(rvReq) // nowhere for return value to go
	})
	fut.Failure(func (err int32) {
		rvReq:=&syscall.ReturnValueRequest{}
		rvReq.CallId= cid.Marshal()
		rvReq.HostId= lib.CurrentHostId().Marshal()
		rvReq.ResultError = err
		syscallguest.ReturnValue(rvReq) // nowhere for return value to go
	})
	return syscall.KernelErr_NoError

}

func methodCallSuitebind(ctx context.Context,sid id.ServiceId, impl MethodCallSuite) (*lib.ServiceMethodMap, syscall.KernelErr) {
	smmap:=lib.NewServiceMethodMap()
	var mid id.MethodId
	var bindReq *syscall.BindMethodRequest
	var resp *syscall.BindMethodResponse
	var err syscall.KernelErr
//
// test.v1.MethodCallSuite.Exec
//

	bindReq = &syscall.BindMethodRequest{}
	bindReq.HostId = lib.CurrentHostId().Marshal()
	bindReq.ServiceId = sid.Marshal()
	bindReq.MethodName = "Exec"
	resp, err=syscallguest.BindMethod(bindReq)
	if err!=syscall.KernelErr_NoError {
		return nil, err
	}
	mid=id.UnmarshalMethodId(resp.GetMethodId())

	// completer already prepared elsewhere
	smmap.AddServiceMethod(sid,mid,"MethodCallSuite","MethodCallSuiteExec",
		GenerateMethodCallSuiteExecInvoker(impl))
//
// test.v1.MethodCallSuite.SuiteReport
//

	bindReq = &syscall.BindMethodRequest{}
	bindReq.HostId = lib.CurrentHostId().Marshal()
	bindReq.ServiceId = sid.Marshal()
	bindReq.MethodName = "SuiteReport"
	resp, err=syscallguest.BindMethod(bindReq)
	if err!=syscall.KernelErr_NoError {
		return nil, err
	}
	mid=id.UnmarshalMethodId(resp.GetMethodId())

	// completer already prepared elsewhere
	smmap.AddServiceMethod(sid,mid,"MethodCallSuite","MethodCallSuiteSuiteReport",
		GenerateMethodCallSuiteSuiteReportInvoker(impl)) 
	pcontext.Dump(ctx)
	return smmap,syscall.KernelErr_NoError
}

// Locate finds a reference to the client interface of method_call_suite.  
func LocateMethodCallSuite(ctx context.Context,sid id.ServiceId) (ClientMethodCallSuite,syscall.KernelErr) {
    cs, kerr:=client.LocateDynamic(ctx, "test.v1","method_call_suite", sid)
    if kerr!=syscall.KernelErr_NoError{
        return nil, kerr
    }
    return &ClientMethodCallSuite_{
        BaseService: cs,
    },syscall.KernelErr_NoError
}

func MustLocateMethodCallSuite(ctx context.Context, sid id.ServiceId) ClientMethodCallSuite {
    result, err:=LocateMethodCallSuite(ctx, sid)
    name:=syscall.KernelErr_name[int32(err)]
    normal:="unable to locate test.v1.method_call_suite:"+name
    if err!=0 {
        pcontext.Debugf(ctx,"kernel error was  %s",name)
        if err == syscall.KernelErr_NotRequired {
            pcontext.Errorf(ctx,"service was located, but it was not required")
            panic("locate attempted on a service that was not required")
        }
        panic(normal)
    }
    return result
}


func RegisterMethodCallSuite(ctx context.Context) (id.ServiceId, syscall.KernelErr){
    req := &syscall.RegisterRequest{}
	fqs := &syscall.FullyQualifiedService{
		PackagePath: "test.v1",
		Service:     "method_call_suite",
	}
	req.Fqs = fqs
	req.HostId = lib.CurrentHostId().Marshal()

	resp, err := syscallguest.Register(req)
    if err!=syscall.KernelErr_NoError{
        return id.ServiceIdZeroValue(), err
    }
    sid:=id.UnmarshalServiceId(resp.Id)
    if sid.IsZeroOrEmptyValue() {
        panic("received bad service Id from register")
    }

    return sid,syscall.KernelErr_NoError
}
func MustRegisterMethodCallSuite(ctx context.Context) id.ServiceId {
    sid, err:=RegisterMethodCallSuite(ctx)
    if err!=syscall.KernelErr_NoError {
        pcontext.Fatalf(ctx,"unable to register %s.%s","test.v1","method_call_suite")
        panic("unable to register "+"method_call_suite")
    }
    return sid
}

func MustRequireMethodCallSuite(ctx context.Context, sid id.ServiceId) {
    _, err:=lib.Require1("test.v1","method_call_suite",sid)
    if err!=syscall.KernelErr_NoError {
        if err==syscall.KernelErr_DependencyCycle{
            pcontext.Errorf(ctx,"unable to require %s.%s because it creates a dependcy loop: %s","test.v1","method_call_suite",syscall.KernelErr_name[int32(err)])
            panic("require test.v1.method_call_suite creates a dependency loop")
        }
        pcontext.Errorf(ctx,"unable to require %s.%s:%s","test.v1","method_call_suite",syscall.KernelErr_name[int32(err)])
        panic("not able to require test.v1.method_call_suite:"+syscall.KernelErr_name[int32(err)])
    }
}

func MustExportMethodCallSuite(ctx context.Context, sid id.ServiceId) {
    _, err:=lib.Export1("test.v1","method_call_suite",sid)
    if err!=syscall.KernelErr_NoError{
        pcontext.Fatalf(ctx, "unable to export %s.%s","test.v1","method_call_suite")
        panic("not able to export test.v1.method_call_suite:"+syscall.KernelErr_name[int32(err)])
    }
}

func LaunchServiceMethodCallSuite(ctx context.Context, sid id.ServiceId, impl MethodCallSuite) (*lib.ServiceMethodMap,syscall.KernelErr) {
	smmap, err:=methodCallSuitebind(ctx,sid, impl)
	if err!=0{
		return  nil,syscall.KernelErr(err)
	}

    s:=sid.Marshal()
	syscallguest.Launch(&syscall.LaunchRequest{ServiceId:s })

    return smmap,syscall.KernelErr_NoError
}

func MustLaunchServiceMethodCallSuite(ctx context.Context, sid id.ServiceId, impl MethodCallSuite) *lib.ServiceMethodMap {
    smmap,err:=LaunchServiceMethodCallSuite(ctx,sid,impl)
    if err!=syscall.KernelErr_NoError {
        panic("Unable to call LaunchService successfully: "+syscall.KernelErr_name[int32(err)])
    }
    return smmap
}


// If you want to implement part of your server in host cost you should call 
// MethodCallSuite<methodName>Host from your server implementation. These will be optimized 
// away by the compiler if you don't use them--in other words, if you want to 
// implement everything on the guest side).
// 

//go:wasmimport test execMethodCallSuite_
func Exec_(int32,int32,int32,int32) int64
func ExecMethodCallSuiteHost(ctx context.Context,inPtr *ExecRequest) *FutureMethodCallSuiteExec {
	outProtoPtr := (*ExecResponse)(nil)
	defer pcontext.Dump(ctx)
	ret, raw, signal:= syscallguest.ClientSide(ctx, inPtr, outProtoPtr, Exec_)
	if signal {
		pcontext.Infof(ctx, "Exec exiting because of parigot signal")
		pcontext.Dump(ctx)
		lib.ExitClient(ctx, 1, id.NewServiceId(), "xxx warning, no implementation of unsolicited exit",
			"xxx warning, no implementation of unsolicited exit and failed trying to exit")
	}
	f:=NewFutureMethodCallSuiteExec()
	f.CompleteMethod(ctx,ret,raw)
	return f
} 

//go:wasmimport test suite_reportMethodCallSuite_
func SuiteReport_(int32,int32,int32,int32) int64
func SuiteReportMethodCallSuiteHost(ctx context.Context,inPtr *SuiteReportRequest) *FutureMethodCallSuiteSuiteReport {
	outProtoPtr := (*SuiteReportResponse)(nil)
	defer pcontext.Dump(ctx)
	ret, raw, signal:= syscallguest.ClientSide(ctx, inPtr, outProtoPtr, SuiteReport_)
	if signal {
		pcontext.Infof(ctx, "SuiteReport exiting because of parigot signal")
		pcontext.Dump(ctx)
		lib.ExitClient(ctx, 1, id.NewServiceId(), "xxx warning, no implementation of unsolicited exit",
			"xxx warning, no implementation of unsolicited exit and failed trying to exit")
	}
	f:=NewFutureMethodCallSuiteSuiteReport()
	f.CompleteMethod(ctx,ret,raw)
	return f
}  

// This is interface for invocation.
type invokeMethodCallSuiteExec struct {
    fn func(context.Context,*ExecRequest) *FutureMethodCallSuiteExec
}

func (t *invokeMethodCallSuiteExec) Invoke(ctx context.Context,a *anypb.Any) future.Completer {
	// xxx ExecRequest and 'ExecRequest{}' why empty?
    in:=&ExecRequest{}
    err:=a.UnmarshalTo(in)
    if err!=nil {
        pcontext.Errorf(ctx,"unmarshal inside Invoke() failed: %s",err.Error())
        return nil
    }
    return t.fn(ctx,in) 

}

func GenerateMethodCallSuiteExecInvoker(impl MethodCallSuite) future.Invoker {
	return &invokeMethodCallSuiteExec{fn:impl.MethodCallSuiteExec} 
}

// This is interface for invocation.
type invokeMethodCallSuiteSuiteReport struct {
    fn func(context.Context,*SuiteReportRequest) *FutureMethodCallSuiteSuiteReport
}

func (t *invokeMethodCallSuiteSuiteReport) Invoke(ctx context.Context,a *anypb.Any) future.Completer {
	// xxx SuiteReportRequest and '' why empty?
    in:=&SuiteReportRequest{}
    err:=a.UnmarshalTo(in)
    if err!=nil {
        pcontext.Errorf(ctx,"unmarshal inside Invoke() failed: %s",err.Error())
        return nil
    }
    return t.fn(ctx,in) 

}

func GenerateMethodCallSuiteSuiteReportInvoker(impl MethodCallSuite) future.Invoker {
	return &invokeMethodCallSuiteSuiteReport{fn:impl.MethodCallSuiteSuiteReport} 
} 

 
func LaunchUnderTest(ctx context.Context, sid id.ServiceId, impl UnderTest) *future.Base[bool] {

	defer func() {
		pcontext.Dump(ctx)
	}()

	readyResult:=future.NewBase[bool]()

	ready:=impl.Ready(ctx,sid)
	ready.Handle(func (b bool) {
		if b {
			readyResult.Set(true)			
			return
		}
		pcontext.Errorf(ctx,"Unable to start test.v1.UnderTest, Ready returned false")
		pcontext.Dump(ctx)
		readyResult.Set(false)
	})

	return readyResult
}

func InitUnderTest(ctx context.Context,require []lib.MustRequireFunc, impl UnderTest) *lib.ServiceMethodMap{
	defer func() {
		if r := recover(); r != nil {
			pcontext.Infof(ctx, "InitUnderTest: trapped a panic in the guest side: %v", r)
		}
		pcontext.Dump(ctx)
	}()

	myId := MustRegisterUnderTest(ctx)
	MustExportUnderTest(ctx,myId)
	if len(require)>0 {
		for _, f := range require {
			f(ctx, myId)
		}
	}
	smmap:=MustLaunchServiceUnderTest(ctx, myId, impl)
	launchF:=LaunchUnderTest(ctx, myId, impl)

	// kinda tricky: if this get resolved this exit occurs on the
	// call stack of the code that called Set().
	launchF.Handle(func (ready bool) {
		if !ready {
			pcontext.Errorf(ctx, "ready call on UnderTest failed")
			lib.ExitClient(ctx, 1, myId, "unable to Launch in InitUnderTest",
				"unable to call Exit in InitUnderTest")
		}
	})
	return smmap
}
func RunUnderTest(ctx context.Context,
	binding *lib.ServiceMethodMap, timeoutInMillis int32, bg lib.Backgrounder) syscall.KernelErr{
	defer func() {
		if r := recover(); r != nil {
			pcontext.Infof(ctx, "RunUnderTest: trapped a panic in the guest side: %v", r)
		}
		pcontext.Dump(ctx)
	}()
	var kerr syscall.KernelErr
	for {
		pctx:=pcontext.CallTo(ctx,"ReadOneAndCallUnderTest")
		kerr:=ReadOneAndCallUnderTest(pctx, binding, timeoutInMillis)
		pcontext.Dump(pctx)
		if kerr == syscall.KernelErr_ReadOneTimeout {
			if bg==nil {
				continue
			}
			pcontext.Infof(ctx,"calling backgrounder of UnderTest")
			bgctx:=pcontext.CallTo(ctx,"Background")
			bg.Background(bgctx)
			pcontext.Dump(bgctx)
			continue
		}
		if kerr == syscall.KernelErr_NoError {
			continue
		}
		break
	}
	pcontext.Errorf(ctx, "error while waiting for UnderTest service calls: %s", syscall.KernelErr_name[int32(kerr)])
	return kerr
}

var TimeoutInMillisUnderTest = int32(500)

func ReadOneAndCallUnderTest(ctx context.Context, binding *lib.ServiceMethodMap, 
	timeoutInMillis int32) syscall.KernelErr{
	req:=syscall.ReadOneRequest{}

	// makes a copy
	for _, c := range binding.Call() {
		req.Call=append(req.Call, c)
	}

	req.TimeoutInMillis = timeoutInMillis
	req.HostId = lib.CurrentHostId().Marshal()
	resp, err:=syscallguest.ReadOne(&req)
	if err!=syscall.KernelErr_NoError {
		return err
	}
	// is timeout?
	if resp.Timeout {
		return syscall.KernelErr_ReadOneTimeout
	}

	// check for finished futures from within our address space
	lib.ExpireMethod(ctx)

	// is a promise being completed that was fulfilled somewhere else
	if r:=resp.GetResolved(); r!=nil {
		cid:=id.UnmarshalCallId(r.GetCallId())
		lib.CompleteCall(ctx, cid,r.GetResult(), r.GetResultError())
		return syscall.KernelErr_NoError
	}

	// its a method call from another address space
	sid:=id.UnmarshalServiceId(resp.GetCall().GetServiceId())
	mid:=id.UnmarshalMethodId(resp.GetCall().GetMethodId())
	cid:=id.UnmarshalCallId(resp.GetCallId())
	fn:=binding.Func(sid,mid)
	if fn==nil {
		pcontext.Errorf(ctx,"unable to find service/method pair binding: service=%s, method=%s",
			sid.Short(), mid.Short())
		return syscall.KernelErr_NotFound
	}
	// we let the invoker handle the unmarshal from anypb.Any because it
	// knows the precise type to be consumed
	fut:=fn.Invoke(ctx,resp.GetParam())
	fut.Success(func (result proto.Message){
		rvReq:=&syscall.ReturnValueRequest{}
		rvReq.CallId= cid.Marshal()
		rvReq.HostId= lib.CurrentHostId().Marshal()
		var a anypb.Any
		if err:=a.MarshalFrom(result); err!=nil {
			pcontext.Errorf(ctx, "unable to marshal result for return value request")
			return
		}
		rvReq.Result = &a
		rvReq.ResultError = 0
		syscallguest.ReturnValue(rvReq) // nowhere for return value to go
	})
	fut.Failure(func (err int32) {
		rvReq:=&syscall.ReturnValueRequest{}
		rvReq.CallId= cid.Marshal()
		rvReq.HostId= lib.CurrentHostId().Marshal()
		rvReq.ResultError = err
		syscallguest.ReturnValue(rvReq) // nowhere for return value to go
	})
	return syscall.KernelErr_NoError

}

func underTestbind(ctx context.Context,sid id.ServiceId, impl UnderTest) (*lib.ServiceMethodMap, syscall.KernelErr) {
	smmap:=lib.NewServiceMethodMap()
	var mid id.MethodId
	var bindReq *syscall.BindMethodRequest
	var resp *syscall.BindMethodResponse
	var err syscall.KernelErr
//
// test.v1.UnderTest.Exec
//

	bindReq = &syscall.BindMethodRequest{}
	bindReq.HostId = lib.CurrentHostId().Marshal()
	bindReq.ServiceId = sid.Marshal()
	bindReq.MethodName = "Exec"
	resp, err=syscallguest.BindMethod(bindReq)
	if err!=syscall.KernelErr_NoError {
		return nil, err
	}
	mid=id.UnmarshalMethodId(resp.GetMethodId())

	// completer already prepared elsewhere
	smmap.AddServiceMethod(sid,mid,"UnderTest","UnderTestExec",
		GenerateUnderTestExecInvoker(impl)) 
	pcontext.Dump(ctx)
	return smmap,syscall.KernelErr_NoError
}

// Locate finds a reference to the client interface of under_test.  
func LocateUnderTest(ctx context.Context,sid id.ServiceId) (ClientUnderTest,syscall.KernelErr) {
    cs, kerr:=client.LocateDynamic(ctx, "test.v1","under_test", sid)
    if kerr!=syscall.KernelErr_NoError{
        return nil, kerr
    }
    return &ClientUnderTest_{
        BaseService: cs,
    },syscall.KernelErr_NoError
}

func MustLocateUnderTest(ctx context.Context, sid id.ServiceId) ClientUnderTest {
    result, err:=LocateUnderTest(ctx, sid)
    name:=syscall.KernelErr_name[int32(err)]
    normal:="unable to locate test.v1.under_test:"+name
    if err!=0 {
        pcontext.Debugf(ctx,"kernel error was  %s",name)
        if err == syscall.KernelErr_NotRequired {
            pcontext.Errorf(ctx,"service was located, but it was not required")
            panic("locate attempted on a service that was not required")
        }
        panic(normal)
    }
    return result
}


func RegisterUnderTest(ctx context.Context) (id.ServiceId, syscall.KernelErr){
    req := &syscall.RegisterRequest{}
	fqs := &syscall.FullyQualifiedService{
		PackagePath: "test.v1",
		Service:     "under_test",
	}
	req.Fqs = fqs
	req.HostId = lib.CurrentHostId().Marshal()

	resp, err := syscallguest.Register(req)
    if err!=syscall.KernelErr_NoError{
        return id.ServiceIdZeroValue(), err
    }
    sid:=id.UnmarshalServiceId(resp.Id)
    if sid.IsZeroOrEmptyValue() {
        panic("received bad service Id from register")
    }

    return sid,syscall.KernelErr_NoError
}
func MustRegisterUnderTest(ctx context.Context) id.ServiceId {
    sid, err:=RegisterUnderTest(ctx)
    if err!=syscall.KernelErr_NoError {
        pcontext.Fatalf(ctx,"unable to register %s.%s","test.v1","under_test")
        panic("unable to register "+"under_test")
    }
    return sid
}

func MustRequireUnderTest(ctx context.Context, sid id.ServiceId) {
    _, err:=lib.Require1("test.v1","under_test",sid)
    if err!=syscall.KernelErr_NoError {
        if err==syscall.KernelErr_DependencyCycle{
            pcontext.Errorf(ctx,"unable to require %s.%s because it creates a dependcy loop: %s","test.v1","under_test",syscall.KernelErr_name[int32(err)])
            panic("require test.v1.under_test creates a dependency loop")
        }
        pcontext.Errorf(ctx,"unable to require %s.%s:%s","test.v1","under_test",syscall.KernelErr_name[int32(err)])
        panic("not able to require test.v1.under_test:"+syscall.KernelErr_name[int32(err)])
    }
}

func MustExportUnderTest(ctx context.Context, sid id.ServiceId) {
    _, err:=lib.Export1("test.v1","under_test",sid)
    if err!=syscall.KernelErr_NoError{
        pcontext.Fatalf(ctx, "unable to export %s.%s","test.v1","under_test")
        panic("not able to export test.v1.under_test:"+syscall.KernelErr_name[int32(err)])
    }
}

func LaunchServiceUnderTest(ctx context.Context, sid id.ServiceId, impl UnderTest) (*lib.ServiceMethodMap,syscall.KernelErr) {
	smmap, err:=underTestbind(ctx,sid, impl)
	if err!=0{
		return  nil,syscall.KernelErr(err)
	}

    s:=sid.Marshal()
	syscallguest.Launch(&syscall.LaunchRequest{ServiceId:s })

    return smmap,syscall.KernelErr_NoError
}

func MustLaunchServiceUnderTest(ctx context.Context, sid id.ServiceId, impl UnderTest) *lib.ServiceMethodMap {
    smmap,err:=LaunchServiceUnderTest(ctx,sid,impl)
    if err!=syscall.KernelErr_NoError {
        panic("Unable to call LaunchService successfully: "+syscall.KernelErr_name[int32(err)])
    }
    return smmap
}


// If you want to implement part of your server in host cost you should call 
// UnderTest<methodName>Host from your server implementation. These will be optimized 
// away by the compiler if you don't use them--in other words, if you want to 
// implement everything on the guest side).
// 

//go:wasmimport test exec_under_testUnderTest_
func ExecUnderTest_(int32,int32,int32,int32) int64
func ExecUnderTestUnderTestHost(ctx context.Context,inPtr *ExecRequest) *FutureUnderTestExec {
	outProtoPtr := (*ExecResponse)(nil)
	defer pcontext.Dump(ctx)
	ret, raw, signal:= syscallguest.ClientSide(ctx, inPtr, outProtoPtr, Exec_)
	if signal {
		pcontext.Infof(ctx, "ExecUnderTest exiting because of parigot signal")
		pcontext.Dump(ctx)
		lib.ExitClient(ctx, 1, id.NewServiceId(), "xxx warning, no implementation of unsolicited exit",
			"xxx warning, no implementation of unsolicited exit and failed trying to exit")
	}
	f:=NewFutureUnderTestExec()
	f.CompleteMethod(ctx,ret,raw)
	return f
}  

// This is interface for invocation.
type invokeUnderTestExec struct {
    fn func(context.Context,*ExecRequest) *FutureUnderTestExec
}

func (t *invokeUnderTestExec) Invoke(ctx context.Context,a *anypb.Any) future.Completer {
	// xxx ExecRequest and 'ExecRequest{}' why empty?
    in:=&ExecRequest{}
    err:=a.UnmarshalTo(in)
    if err!=nil {
        pcontext.Errorf(ctx,"unmarshal inside Invoke() failed: %s",err.Error())
        return nil
    }
    return t.fn(ctx,in) 

}

func GenerateUnderTestExecInvoker(impl UnderTest) future.Invoker {
	return &invokeUnderTestExec{fn:impl.UnderTestExec} 
}  
