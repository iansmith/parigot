package syscall

import (
	"bytes"
	"context"
	"fmt"
	"log"
	"sync"
	"time"

	"github.com/iansmith/parigot/apishared/id"
	pcontext "github.com/iansmith/parigot/context"
	syscall "github.com/iansmith/parigot/g/syscall/v1"
	"github.com/yourbasic/graph"
)

//
// startupCoordinator
//

// The default lock discipline for this type is that you should call a method
// on this type when the lock is unlocked.  The methods you can call when you
// DO have the lock are demarcated by the NoLock suffix. Any function that
// does assert the lock should make sure to release it before returning.

type startupCoordinator struct {
	sidStringToService          map[string]Service
	packageNameToServiceNameMap map[string]map[string]Service
	depGraph                    *graph.Mutable
	vertexName                  map[string]int
	lock                        *sync.Mutex
}

func newSyscallDataImpl() *startupCoordinator {
	g := graph.New(0)
	impl := &startupCoordinator{
		sidStringToService:          make(map[string]Service),
		packageNameToServiceNameMap: make(map[string]map[string]Service),
		depGraph:                    g,
		lock:                        new(sync.Mutex),
		vertexName:                  make(map[string]int),
	}
	_ = SyscallData(impl)
	return impl
}

// SetService is both the "check if the service exists" and create the service
// in one function.  If the service is found as already existing, it returns the
// service and false.  If the service is not found it is created and the service
// is returned and the value false.
func (s *startupCoordinator) SetService(ctx context.Context, package_, name string, client bool) (Service, bool) {

	svc := s.ServiceByName(ctx, package_, name)
	if svc != nil {
		return svc, false
	}
	s.lock.Lock()
	defer s.lock.Unlock()

	svcId := id.NewServiceId()
	nmap, ok := s.packageNameToServiceNameMap[package_]
	if !ok {
		nmap = make(map[string]Service)
		s.packageNameToServiceNameMap[package_] = nmap
	}

	if svcId.IsEmptyValue() || svcId.IsZeroValue() {
		print("Service Id error, bad id generated by random!\n")
	}

	result := newStartupService(package_, name, svcId, s, client)

	nmap[name] = result
	if !s.addVertex(ctx, result.String()) {
		return nil, false
	}
	s.sidStringToService[result.String()] = result
	if result != nil {
		if result.id.IsEmptyValue() || result.id.IsZeroValue() {
			pcontext.Errorf(ctx, "Service Id error, bad id returned from syscall data")
		}
	} else {
		pcontext.Errorf(ctx, "result of set service is nil?")
	}
	pcontext.Debugf(ctx, "created service via SetService: %s [%s]", result.id.Short(), result.Name())
	return result, true

}

// ServiceByName takes the full name of a service as a package and a service name
// and returns the Service that represents that name.  If the given package and
// name cannot be found it returns nil.
func (s *startupCoordinator) ServiceByName(ctx context.Context, package_, name string) Service {
	s.lock.Lock()
	defer s.lock.Unlock()
	return s.serviceByNameNoLock(ctx, package_, name)
}

// serviceByNameNoLock returns the startupService that represents the service
// id given.  The service given is the String() value of the service id.  This
// function must be called with the lock held, since it does not lock itself.
func (s *startupCoordinator) serviceByNameNoLock(ctx context.Context, package_, name string) Service {
	nameMap, ok := s.packageNameToServiceNameMap[package_]
	if !ok {
		return nil
	}
	svc, ok := nameMap[name]
	if !ok {
		return nil
	}
	return svc
}

// ServiceById is just a convenience wrapper for ServiceByIdString for folks that
// have the service id they want to convert to a startupService.
func (s *startupCoordinator) ServiceById(ctx context.Context, sid id.ServiceId) Service {
	return s.ServiceByIdString(ctx, sid.String())
}
func (s *startupCoordinator) serviceByIdStringNoLock(ctx context.Context, sid string) Service {
	svc, ok := s.sidStringToService[sid]
	if !ok {
		return nil
	}
	return svc
}

func (s *startupCoordinator) ServiceByIdString(ctx context.Context, sid string) Service {
	s.lock.Lock()
	defer s.lock.Unlock()
	return s.serviceByIdStringNoLock(ctx, sid)
}

// Export causes the service given (in the id form) to marked as exported.
// It returns nil if the service is not found, otherwise it returns the startupService
// that represents the given id.
func (s *startupCoordinator) Export(ctx context.Context, svcId id.ServiceId) Service {
	svc := s.ServiceByIdString(ctx, svcId.String())
	if svc == nil {
		return nil
	}

	pcontext.Debugf(ctx, "exporting %s%s", svc.Name(), svc.Short())
	svc.(*startupService).export()
	if svc.(*startupService).canRun(ctx) {
		// svc.(*startupService).SetStarted()
		pcontext.Debugf(ctx, "service %s [%s] exported and can run", svc.Short(), svc.Name())
	}
	// s.checkNodesInFront(ctx, svc.String())

	return svc
}

// topoSort does a topological sort of all the nodes we currently know about.
// This function asserts the lock to ensure that while the topo algorihtm is
// running no part of the graph is disturbed.  It returns what I HOPE is a copy
// of the content of the graph vertices.
func (s *startupCoordinator) topoSort(ctx context.Context) []string {
	s.lock.Lock()
	defer s.lock.Unlock()

	result, ok := graph.TopSort(s.depGraph)
	if !ok {
		panic("topolical sort could not be generated, likely it has a cycle")
	}
	name := make([]string, len(result))
	for i, v := range result {
		str, ok := reverseMap(s.vertexName, v)
		if !ok {
			panic("badly formed dependency graph, cant find vertex:" + fmt.Sprint(v))
		}
		name[len(result)-1-i] = str
	}
	for i, str := range name {
		svc := s.serviceByIdStringNoLock(ctx, str)
		log.Printf("dep %d  %s%s (running? %v)", i, svc.Name(), svc.Short(), svc.Started())
	}
	for v := 0; v < s.depGraph.Order(); v++ {
		s.depGraph.Visit(v, func(w int, c int64) (skip bool) {
			vName, bv := reverseMap(s.vertexName, v)
			wName, bw := reverseMap(s.vertexName, w)
			vSvc := s.serviceByIdStringNoLock(ctx, vName)
			wSvc := s.serviceByIdStringNoLock(ctx, wName)
			if !bv || !bw {
				log.Printf("BAD ENTRY IN THE GRAPH! %d,%d", v, w)
			}
			log.Printf("\t edge: %s -> %s", vSvc.Name(), wSvc.Name())
			return
		})
	}

	return name
}

// notifyNodesBehind walks the topologically ordered vertices, looking for any nodes
// that are predecessors of the given node and notifying them to check their status for running.
// This returns false only when the service cannot be found.
// func (s *startupCoordinator) notifyNodesBehindForReady(ctx context.Context, svcid string) bool {
// 	topo := s.topoSort(ctx)                     // locks
// 	if s.ServiceByIdString(ctx, svcid) == nil { //locks
// 		return false
// 	}
// 	for _, str := range topo {
// 		if str == svcid {
// 			pcontext.Debugf(ctx, "covered all predecessors of %s", svcid)
// 			return true
// 		}
// 		svc := s.ServiceByIdString(ctx, str)
// 		if svc == nil {
// 			pcontext.Fatalf(ctx, "internal error trying to notify nodes to check their can run status, can't find  "+str)
// 			panic("internal error trying to notify nodes to check their can run status, can't find  " + str)
// 		}
// 		svc.(*startupService).wakeUp()
// 	}
// 	panic("did not find id " + svcid + " in the list of vertices")
// }

// notify all nodes that there has been a state change in the given node
func (s *startupCoordinator) notifyAllNodes(ctx context.Context) {
	topo := s.topoSort(ctx)
	pcontext.Debugf(ctx, "topo created--- %d", len(topo))
	for i, str := range topo {
		time.Sleep(10 * time.Second)
		svc := s.ServiceByIdString(ctx, str)
		if svc == nil {
			panic("unable to find service in checkNodesBehindForRunning:" + str)
		}
		pcontext.Debugf(ctx, "\tNotify All")
		pcontext.Debugf(ctx, "\telement[%02d]:%s,%s (running?%v)", i, svc.Name(), svc.Short(), svc.Started())
		node, ok := reverseMap(s.vertexName, i)
		if !ok {
			panic("unable to find the element in the vertex map")
		}
		nodeSvc := s.ServiceByIdString(ctx, node)
		if nodeSvc == nil {
			panic("unable to find service in checkNodesBehindForRunning:" + str)
		}
		if nodeSvc.Started() {
			log.Printf("not notifying %s%s already started", nodeSvc.Name(), nodeSvc.Short())
		}
		log.Printf("sending a wakeUp to %s%s", nodeSvc.Name(), nodeSvc.Id().Short())
		nodeSvc.(*startupService).wakeUp()
	}
}

// checkNodesBehindForRunning walks the topologically ordered vertices, looking for any nodes
// that are predecessors of the given node and testing to see if they are started. If not
// we return false.  If all the predecessorys are started, then we return true.  If the
// serviceId cannot be found, we return true.
func (s *startupCoordinator) checkNodesBehindForRunning(ctx context.Context, svcid string) bool {
	print("xxx1\n")
	topo := s.topoSort(ctx)
	if s.ServiceByIdString(ctx, svcid) == nil {
		print("xxx2\n")
		return true
	}
	print("xxx3\n")
	pcontext.Debugf(ctx, "** check Nodes Behind For Running **")
	pcontext.Debugf(ctx, "topo created--- %d", len(topo))
	for i, str := range topo {
		svc := s.ServiceByIdString(ctx, str)
		if svc == nil {
			panic("unable to find service in checkNodesBehindForRunning:" + str)
		}
		pcontext.Debugf(ctx, "\telement[%02d]:%s,%s (running?%v)", i, svc.Name(), svc.Short(), svc.Started())
	}
	print("xxx4\n")

	for _, str := range topo {
		print("xxx5 " + str + "\n")
		pcontext.Debugf(ctx, "topo considering elem? %s", str)

		// this clause is LOGICALLY the one we need to use but in practice it
		// is not. because the topo sort isn't actually the tree, but just one
		// possible dependency order.  thus, its SIBLINGS might also be ready to
		// start.
		// if str == svcid {
		// 	pcontext.Debugf(ctx, "topo: found %s (check behind for ready done)", str)
		// 	continue
		// }
		svc := s.ServiceByIdString(ctx, str)
		if svc == nil {
			panic("unable to walk the dep graph looking for predeessors, a predecessor could not be found: " + str)
		}
		if svc.String() == svcid {
			print("xxx6\n")
			return true
		}
		ss := svc.(*startupService)
		print("xxx7\n")
		if ss.Exported() && ss.RunRequested() {
			print("xxx8\n")
			pcontext.Debugf(ctx, "  -- check completed %s candidate [%s] (%v)  ", svc.Short(), svc.Name(), svc.Started())
			svc.(*startupService).wakeUp()
			continue
		}
		pcontext.Debugf(ctx, "topo search failure: candidate %s%sis not ready (%v,%v,%v)", svc.Short(), svc.Name(), svc.Exported(), svc.RunRequested(), svc.Started())
		return false
	}
	panic("did not find id " + svcid + " in the list of vertices")
}

// checkNodesInFront walks the topologically ordered vertices, looking for any nodes
// that are not yet running (started) and send them the wake up message.
// This is needed when there is a state change like RunRequested or Export() in
// a service that is a predecessor ("dependency") of nodes that might need to
// reconsider their state based on the change.
// It returns false only if the svcid cannot be found.
func (s *startupCoordinator) checkNodesInFront(ctx context.Context, svcid string) bool {
	topo := s.topoSort(ctx)
	foundSelf := false
	for _, str := range topo {
		svc := s.ServiceByIdString(ctx, str)
		if svc == nil {
			return false
		}
		if svcid == svc.String() {
			foundSelf = true
			continue
		}
		if !foundSelf {
			continue
		}
		if svc.Started() {
			continue
		}
		pcontext.Infof(ctx, "notifying service %s to check its ready state", svc.Short())
		// wake em up
		svc.(*startupService).wakeUp()
	}
	return true
}

// Import adds a node in the dependency graph between src and dest.
// It returns a kerr if either the source or dest cannot be found; it
// returns a kerr if the new edge would create a cycle.
func (s *startupCoordinator) Import(ctx context.Context, src, dest id.ServiceId) syscall.KernelErr {
	serviceSource := s.ServiceByIdString(ctx, src.String())
	if serviceSource == nil {
		sid, ok := s.SetService(ctx, serviceSource.Package(), serviceSource.Name(), false)
		if ok {
			pcontext.Debugf(ctx, "xxxx --- ???? created service %s%s because of import", sid.Name(), sid.Short())
		}
	}
	serviceDest := s.ServiceByIdString(ctx, dest.String())
	if serviceDest == nil {
		return syscall.KernelErr_NotFound
	}
	pcontext.Debugf(ctx, "import: %s%s -> %s%s", serviceSource.Name(), serviceSource.Short(),
		serviceDest.Name(), dest.Short())
	srcString := serviceSource.String()
	destString := serviceDest.String()

	// graph does not lock itself
	s.lock.Lock()
	defer s.lock.Unlock()
	if !graph.Acyclic(s.depGraph) {
		panic("graph is already cyclic, some previous edge was added without checking")
	}
	ok := s.addEdge(ctx, srcString, destString)
	if !ok {
		return syscall.KernelErr_NotFound
	}
	if !graph.Acyclic(s.depGraph) {
		pcontext.Errorf(ctx, "acyclic check failed, removing %s->%s",
			src.Short(), dest.Short())
		// remove the edge so no cycles
		s.removeEdge(ctx, s.vertexName[srcString], s.vertexName[destString])
		// no need to check these again for existence, remove edge would not have worked
		srcV := s.vertexName[srcString]
		destV := s.vertexName[destString]
		path, _ := graph.ShortestPath(s.depGraph, destV, srcV)
		buf := &bytes.Buffer{}
		// discover the cycle
		for _, vertex := range path {
			n, bool := reverseMap(s.vertexName, vertex)
			if !bool {
				panic("badly formed graph in doing cycle calculation")
			}
			buf.WriteString(n + "\n")
		}
		pcontext.Debugf(ctx, "cycle:\n%s", buf.String())
		return syscall.KernelErr_DependencyCycle

	}
	s.notifyAllNodes(ctx)
	return syscall.KernelErr_NoError
}

// removeEdge is really only useful when you have introduced an edge that
// creates a cycle.
func (s *startupCoordinator) removeEdge(ctx context.Context, v, u int) {
	s.depGraph.Delete(v, u)
}
func (s *startupCoordinator) addVertex(ctx context.Context, name string) bool {
	prevOrder := s.depGraph.Order()
	newG := graph.New(prevOrder + 1)
	for v := 0; v < prevOrder; v++ {
		s.depGraph.Visit(v, func(w int, _ int64) bool {
			newG.Add(v, w)
			return false
		})
	}
	s.depGraph = newG

	_, ok := s.vertexName[name]
	if ok {
		pcontext.Errorf(ctx, "attempt to add vertext %s ignored, vertex already in graph", name)
		return true
	}
	s.vertexName[name] = prevOrder
	return true
}

// addEdge adds an edge to the dependency graph from src to dest.  This edge
// represents the idea that src cannot start until dest is started.
func (s *startupCoordinator) addEdge(ctx context.Context, src, dest string) bool {
	srcV, srcOk := s.vertexName[src]
	destV, destOk := s.vertexName[dest]
	if !srcOk || !destOk {
		text := "neither are graph vertices"
		if srcOk && !destOk {
			text = "destination not a graph vertex"
		}
		if !srcOk && destOk {
			text = "source not a graph vertex"
		}
		pcontext.Errorf(ctx, "attempt to create edge (%s,%s) rejected, %s", src, dest, text)
		return false
	}
	s.depGraph.Add(srcV, destV)
	return true
}

// Run blocks the caller on a particular service being ready to run.  Note that
// function does not assert the lock.
func (s *startupCoordinator) Run(ctx context.Context, sid id.ServiceId) syscall.KernelErr {
	service := s.ServiceById(ctx, sid)
	log.Printf("RUN %s%s", service.Name(), service.Short())
	if service == nil {
		return syscall.KernelErr_NotFound
	}
	log.Printf("Going te SERVICE RUN %s%s", service.Name(), service.Short())

	kerr := service.Run(ctx)
	if kerr != syscall.KernelErr_NoError {
		return kerr
	}
	log.Printf("OUT OF SVCRUN %s%s", service.Name(), service.Short())

	s.notifyAllNodes(ctx)

	return syscall.KernelErr_NoError
}

// PathExists returns true if there is a path from src to dest
// following dependency edges.  Not that this implies that a
// service source requiring foo, and service foo requiring bar, will
// return true for a call for PathExists(source,bar).
// This means that carefully crafted require's that know the
// depgraph of other services will work, but seems unnecessary.
func (s *startupCoordinator) PathExists(ctx context.Context, src, dest string) bool {

	// lock for the graph
	s.lock.Lock()
	defer s.lock.Unlock()
	data := DFS(s.depGraph)
	destV, ok := s.vertexName[dest]
	if !ok {
		pcontext.Errorf(ctx, "unable find vertex, %s, can't check for path existence", dest)
	}
	curr := destV
	str, _ := reverseMap(s.vertexName, curr)
	sid := s.serviceByIdStringNoLock(ctx, str)
	log.Printf("tracing edge... start at %s%s", sid.Name(), sid.Short())

	for curr != -1 {
		cand, ok := reverseMap(s.vertexName, curr)
		if !ok {
			panic("badly formed dependency graph, can't find " + fmt.Sprint(curr))
		}
		sid := s.serviceByIdStringNoLock(ctx, cand)
		log.Printf("tracing edge... %s%s", sid.Name(), sid.Short())

		if cand == src {
			return true
		}
		curr = data.Prev[curr]
	}
	pcontext.Errorf(ctx, "import but no require: %s -> %s", src, dest)
	return false
}

//
// Graph routines
//

// reverseMap is kinda sucky.  This walks the elements of the dependency
// map looking for the name of the vertex that has the vertex number i.
// The number of dependency edges should be small so keeping another map seemed
// like overkill.
func reverseMap(dep map[string]int, i int) (string, bool) {
	for k, v := range dep {
		if v == i {
			return k, true
		}
	}
	return "", false
}

func inboundEdges(g graph.Iterator, target int) []int {
	result := []int{}
	max := g.Order()
	for i := 0; i < max; i++ {
		if i == target {
			continue
		}
		g.Visit(i, func(w int, _ int64) (skip bool) {
			if w == target {
				result = append(result, i)
			}
			return
		})
	}
	return result
}
func (s *startupCoordinator) mustVertexNumToService(ctx context.Context, v int) Service {
	n, ok := reverseMap(_coord.vertexName, v)
	if !ok {
		panic("unable to find vertex name for index")
	}
	svc := s.ServiceByIdString(ctx, n)
	if svc == nil {
		panic("unable to find service by Id string")
	}
	return svc
}
func (s *startupCoordinator) mustServiceToVertexNum(ctx context.Context, svc Service) int {
	str := svc.String()
	i, ok := s.vertexName[str]
	if !ok {
		panic("unable to find vertex number for service id string")
	}
	return i
}

func (s *startupCoordinator) dependenciesStarted(ctx context.Context, v int) []int {
	fail := []int{}
	s.depGraph.Visit(v, func(w int, c int64) (skip bool) {
		cand := s.mustVertexNumToService(ctx, w)
		if !cand.Started() {
			fail = append(fail, w)
		}
		fail = append(fail, s.dependenciesStarted(ctx, s.depGraph, w)...)
		return
	})
	return fail
}

func (s *startupCoordinator) DFSDeps(ctx context.Context, sid Service) bool {
	i := s.mustServiceToVertexNum(ctx, sid)
	fail := s.dependenciesStarted(ctx, i)
	return len(fail) == 0
}

func (s *startupCoordinator) notifyIncomingNeighbors(ctx context.Context, sid Service) {
	i := s.mustServiceToVertexNum(ctx, sid)
	in := inboundEdges(s.depGraph, i)
	for _, c := range in {
		svc := s.mustVertexNumToService(ctx, c)
		svc.(*startupService).wakeUp()
	}
}
