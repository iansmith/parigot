//
// This file defines the ABI interface to the underlying container that is running
// the wasm module.  This is somewhat analogous to libc in that this file doesn't
// contain the implementation of the functions, just provides a wrapper around the
// underlying system.
//
// Note that there is actually no "service" here and no "methods" but that these are
// used to conveniently create a namespace and a set of functions.  The namespace
// and functions use snake case because these functions are exposed to the wasm
// level and that is the wasm standard.  We use functions here, not some type of
// object or dispatching system (as we do in the API) because we want to allow
// languages with simple type systems (e.g. C) to have access to these primitives
// directly.
//
// If you want to write your own toolkit against the container--your own api
// to parigot--you can build it on top of these primitives.
//
// For a given flavor (version,variant) of parigot, the intent is to keep the
// same abi for all languages, so this file documents the underlying ABI that is
// implied by each call. Languages should adapt their "definition" of the ABI
// to match this binary format.  All pointers are 32 bit pointers into linear mem.
// Below, we use the notation *int32 to mean an int32 being used as a ptr.
//
// * Larger return values are passed as a ptr in the first argument. Due to a Javascript
// issue, 64 bit return values are explicitly prohibited.
// * Strings are passed as a pointer and a length.
// * Variable width results are passed and returned as ptr,length,and capacity
// all 32 bits wide.  Effectively, this is type of result is an array of bytes
// that is capacity large and the first length bytes are in use.
//
// We use the "pull up" notion for parameter so the API that is generated for
// go matches the "intuition" about the function.  E.g. Exit(<struct of 1 int32>)
// and Exit(int32) maybe be identical at the binary level because the compiler
// may choose to pass the struct as a single int32...or it might not and use a
// pointer.  We use the "pull up" so the programmer sees the _true_ definition
// of the function, Exit(int32), rather than having the intermediary type (albeit
// required by protobuf) that could cause confusion.

syntax = "proto3";
package abi;
import "parigot.proto";
option go_package = "github.com/iansmith/parigot/g/parigot/abi;abi";
option (parigot.abi) = true;

service Abi {
  option (parigot.wasm_service_name) = "parigot_abi";
  option (parigot.no_package) = true;
  option (parigot.always_pull_up_parameters) = true;
  // f(ptr *int32,len int32) ->
  rpc OutputString(OutputStringRequest) returns(OutputStringResponse){
    option (parigot.pull_output_up) = true;
    option (parigot.wasm_method_name) = "output_string";
  }
  // f(int32) ->
  rpc Exit(ExitRequest) returns(ExitResponse) {// will die
    option (parigot.pull_output_up) = true;
    option (parigot.wasm_method_name) = "exit";
  }

  // result = (int64)
  // f(result_ptr *int32) ->
  rpc Now(NowRequest) returns(NowResponse){
    option (parigot.wasm_method_name) = "now";
  };

  // f(int64, int32) ->
  rpc SetNow(SetNowRequest) returns(SetNowResponse){
    option (parigot.pull_output_up) = true;
    option (parigot.wasm_method_name) = "set_now";
  };

  // result = (int64,int32)
  // f(result_ptr *int32,ptr *int32,len int32, ptr2 *int32, len2 int32) ->
  rpc Locate(LocateRequest) returns (LocateResponse){
    option (parigot.wasm_method_name) = "locate";
  }

  // result = (ptr int32, len int32, cap int32, code int32)
  // f(result_ptr *int32,sid int64, ptr *int32, len int32, ptr *int32, len int32, cap int32) ->
  rpc Dispatch(DispatchRequest) returns (DispatchResponse){
    option (parigot.wasm_method_name) = "dispatch";
  }

  rpc Register(RegisterRequest) returns (RegisterResponse) {
    option (parigot.wasm_method_name) = "register";
  }

  //temp
  rpc TinygoNotImplemented(TinygoNotImplementedRequest) returns (TinygoNotImplementedResponse);
  rpc JSNotImplemented(JSNotImplementedRequest) returns(JSNotImplementedResponse) {
  }
}

message TinygoNotImplementedRequest{
  string message = 1;
}
message TinygoNotImplementedResponse{}

message JSNotImplementedRequest {
  string message = 1;
}
message JSNotImplementedResponse {}

message OutputStringRequest {
  string s = 1;
}

message OutputStringResponse {}

message NowRequest {}

message NowResponse {
  int64 now = 1;
}

message ExitRequest {
  int32 code = 1;
}
message ExitResponse{}

message SetNowRequest {
  int64 now = 1;
  bool freeze_clock = 2;
}
message SetNowResponse{}

message LocateRequest {
  string packageName = 1;
  string service = 2;
}

message LocateResponse {
  int64 service_id =1;
  int64 error_code=2;
}

message DispatchRequest {
  int64 service_sid =1;
  string method=2;
  bytes blob=3;
}

message DispatchResponse {
  bytes blob = 1;
  int64 error_code=2;
}

message RegisterRequest {
  string proto_package = 1;
  string service = 2;
}

message RegisterResponse {
  int64 service_id =1;
  int32 error_code = 2;

}
