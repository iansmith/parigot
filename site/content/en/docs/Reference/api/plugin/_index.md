---
title: Plugin APIs
date: _2023-08-04
---

Plugins are used to build parigot services that are "outside" the WASM
sandbox.  These services use code running inside the __host__ to do
their work.  The documentation in this section is documentation about
the implementation of some plugins used by built-in services. These can
serve as examples of how to build your own.

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# plugin

```go
import "github.com/iansmith/parigot/api/plugin"
```

## Index

- [Variables](<#variables>)
- [func InvokeImplFromStack\[T proto.Message, U proto.Message\]\(ctx context.Context, name string, m api.Module, stack \[\]uint64, fn func\(context.Context, T, U\) int32, t T, u U\)](<#InvokeImplFromStack>)
- [func ManufactureHostContext\(ctx context.Context, funcName string\) context.Context](<#ManufactureHostContext>)
- [type ParigotInit](<#ParigotInit>)
  - [func LoadAndReturnInit\(ctx context.Context, pluginPath, pluginSymbol, \_ string\) \(ParigotInit, error\)](<#LoadAndReturnInit>)


## Variables

<a name="NoReturnedStruct"></a>

```go
var NoReturnedStruct = uint64(0)
```

<a name="InvokeImplFromStack"></a>
## func InvokeImplFromStack

```go
func InvokeImplFromStack[T proto.Message, U proto.Message](ctx context.Context, name string, m api.Module, stack []uint64, fn func(context.Context, T, U) int32, t T, u U)
```

InvokeImplFromStack is the primary interface between host code and the machinery to communicate with the guest. This function takes the parameters like an api.Module and a section of the stack provided by Wazero and then reads and writes an input and output protocol buffer to the guest memory. The name is provided here just for human error messages. This functions uses pullRequestFromStack and and pushResponseToStack to do the actual work of encoding and decoding the values to/from the guest memory.

<a name="ManufactureHostContext"></a>
## func ManufactureHostContext

```go
func ManufactureHostContext(ctx context.Context, funcName string) context.Context
```

ManufactureHostContext is a helper to return a context configured for the given function name and set the source to ServerGo.

<a name="ParigotInit"></a>
## type ParigotInit

ParigotInit is the interface that plugins must meet to be initialized. It is expected that they will use the supplied Engine in the call to Init to register Host functions.

```go
type ParigotInit interface {
    Init(ctx context.Context, e eng.Engine) bool
}
```

<a name="LoadAndReturnInit"></a>
### func LoadAndReturnInit

```go
func LoadAndReturnInit(ctx context.Context, pluginPath, pluginSymbol, _ string) (ParigotInit, error)
```

LoadAndReturnInit is a utility function for plugins that want the default implementation. This function accepts third string param \(name\) but ignores it.

# file

```go
import "github.com/iansmith/parigot/api/plugin/file"
```

## Index

- [type FilePlugin](<#FilePlugin>)
  - [func \(\*FilePlugin\) Init\(ctx context.Context, e eng.Engine\) bool](<#FilePlugin.Init>)
- [type FileStatus](<#FileStatus>)
  - [func \(fs FileStatus\) String\(\) string](<#FileStatus.String>)


<a name="FilePlugin"></a>
## type FilePlugin



```go
type FilePlugin struct{}
```

<a name="FilePlugin.Init"></a>
### func \(\*FilePlugin\) Init

```go
func (*FilePlugin) Init(ctx context.Context, e eng.Engine) bool
```



<a name="FileStatus"></a>
## type FileStatus

enum for file status

```go
type FileStatus int
```

<a name="Fs_Write"></a>

```go
const (
    Fs_Write FileStatus = iota
    Fs_Read
    Fs_Close
)
```

<a name="FileStatus.String"></a>
### func \(FileStatus\) String

```go
func (fs FileStatus) String() string
```



# queue

```go
import "github.com/iansmith/parigot/api/plugin/queue"
```

## Index

- [type CreateIdToKeyMappingParams](<#CreateIdToKeyMappingParams>)
- [type CreateMessageParams](<#CreateMessageParams>)
- [type DBTX](<#DBTX>)
- [type LocateRow](<#LocateRow>)
- [type MarkDoneParams](<#MarkDoneParams>)
- [type ParigotTestMessage](<#ParigotTestMessage>)
- [type ParigotTestQueue](<#ParigotTestQueue>)
- [type ParigotTestQueueIDToKey](<#ParigotTestQueueIDToKey>)
- [type Queries](<#Queries>)
  - [func New\(db DBTX\) \*Queries](<#New>)
  - [func \(q \*Queries\) CreateIdToKeyMapping\(ctx context.Context, arg CreateIdToKeyMappingParams\) \(ParigotTestQueueIDToKey, error\)](<#Queries.CreateIdToKeyMapping>)
  - [func \(q \*Queries\) CreateMessage\(ctx context.Context, arg CreateMessageParams\) \(ParigotTestMessage, error\)](<#Queries.CreateMessage>)
  - [func \(q \*Queries\) CreateQueue\(ctx context.Context, name string\) \(ParigotTestQueue, error\)](<#Queries.CreateQueue>)
  - [func \(q \*Queries\) DeleteQueue\(ctx context.Context, id int64\) error](<#Queries.DeleteQueue>)
  - [func \(q \*Queries\) GetQueue\(ctx context.Context, id int64\) \(ParigotTestQueue, error\)](<#Queries.GetQueue>)
  - [func \(q \*Queries\) Length\(ctx context.Context, queueKey sql.NullInt64\) \(int64, error\)](<#Queries.Length>)
  - [func \(q \*Queries\) Locate\(ctx context.Context, name string\) \(LocateRow, error\)](<#Queries.Locate>)
  - [func \(q \*Queries\) MarkDone\(ctx context.Context, arg MarkDoneParams\) error](<#Queries.MarkDone>)
  - [func \(q \*Queries\) RetrieveMessage\(ctx context.Context, arg RetrieveMessageParams\) \(\[\]ParigotTestMessage, error\)](<#Queries.RetrieveMessage>)
  - [func \(q \*Queries\) TestNameExists\(ctx context.Context, name string\) \(int64, error\)](<#Queries.TestNameExists>)
  - [func \(q \*Queries\) UpdateMessageRetrieved\(ctx context.Context, arg UpdateMessageRetrievedParams\) error](<#Queries.UpdateMessageRetrieved>)
  - [func \(q \*Queries\) WithTx\(tx \*sql.Tx\) \*Queries](<#Queries.WithTx>)
- [type QueuePlugin](<#QueuePlugin>)
  - [func \(\*QueuePlugin\) Init\(ctx context.Context, e eng.Engine\) bool](<#QueuePlugin.Init>)
- [type RetrieveMessageParams](<#RetrieveMessageParams>)
- [type UpdateMessageRetrievedParams](<#UpdateMessageRetrievedParams>)


<a name="CreateIdToKeyMappingParams"></a>
## type CreateIdToKeyMappingParams



```go
type CreateIdToKeyMappingParams struct {
    IDLow    sql.NullInt64
    IDHigh   sql.NullInt64
    QueueKey sql.NullInt64
}
```

<a name="CreateMessageParams"></a>
## type CreateMessageParams



```go
type CreateMessageParams struct {
    IDLow    sql.NullInt64
    IDHigh   sql.NullInt64
    QueueKey sql.NullInt64
    Sender   []byte
    Payload  []byte
}
```

<a name="DBTX"></a>
## type DBTX



```go
type DBTX interface {
    ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
    PrepareContext(context.Context, string) (*sql.Stmt, error)
    QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
    QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}
```

<a name="LocateRow"></a>
## type LocateRow



```go
type LocateRow struct {
    IDHigh sql.NullInt64
    IDLow  sql.NullInt64
}
```

<a name="MarkDoneParams"></a>
## type MarkDoneParams



```go
type MarkDoneParams struct {
    QueueKey sql.NullInt64
    IDLow    sql.NullInt64
    IDHigh   sql.NullInt64
}
```

<a name="ParigotTestMessage"></a>
## type ParigotTestMessage



```go
type ParigotTestMessage struct {
    IDLow         sql.NullInt64
    IDHigh        sql.NullInt64
    QueueKey      sql.NullInt64
    LastReceived  sql.NullString
    ReceivedCount sql.NullInt64
    OriginalSent  sql.NullString
    MarkedDone    sql.NullString
    Sender        []byte
    Payload       []byte
}
```

<a name="ParigotTestQueue"></a>
## type ParigotTestQueue



```go
type ParigotTestQueue struct {
    ID   int64
    Name string
}
```

<a name="ParigotTestQueueIDToKey"></a>
## type ParigotTestQueueIDToKey



```go
type ParigotTestQueueIDToKey struct {
    IDLow    sql.NullInt64
    IDHigh   sql.NullInt64
    QueueKey sql.NullInt64
}
```

<a name="Queries"></a>
## type Queries



```go
type Queries struct {
    // contains filtered or unexported fields
}
```

<a name="New"></a>
### func New

```go
func New(db DBTX) *Queries
```



<a name="Queries.CreateIdToKeyMapping"></a>
### func \(\*Queries\) CreateIdToKeyMapping

```go
func (q *Queries) CreateIdToKeyMapping(ctx context.Context, arg CreateIdToKeyMappingParams) (ParigotTestQueueIDToKey, error)
```



<a name="Queries.CreateMessage"></a>
### func \(\*Queries\) CreateMessage

```go
func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (ParigotTestMessage, error)
```



<a name="Queries.CreateQueue"></a>
### func \(\*Queries\) CreateQueue

```go
func (q *Queries) CreateQueue(ctx context.Context, name string) (ParigotTestQueue, error)
```



<a name="Queries.DeleteQueue"></a>
### func \(\*Queries\) DeleteQueue

```go
func (q *Queries) DeleteQueue(ctx context.Context, id int64) error
```



<a name="Queries.GetQueue"></a>
### func \(\*Queries\) GetQueue

```go
func (q *Queries) GetQueue(ctx context.Context, id int64) (ParigotTestQueue, error)
```



<a name="Queries.Length"></a>
### func \(\*Queries\) Length

```go
func (q *Queries) Length(ctx context.Context, queueKey sql.NullInt64) (int64, error)
```



<a name="Queries.Locate"></a>
### func \(\*Queries\) Locate

```go
func (q *Queries) Locate(ctx context.Context, name string) (LocateRow, error)
```



<a name="Queries.MarkDone"></a>
### func \(\*Queries\) MarkDone

```go
func (q *Queries) MarkDone(ctx context.Context, arg MarkDoneParams) error
```



<a name="Queries.RetrieveMessage"></a>
### func \(\*Queries\) RetrieveMessage

```go
func (q *Queries) RetrieveMessage(ctx context.Context, arg RetrieveMessageParams) ([]ParigotTestMessage, error)
```



<a name="Queries.TestNameExists"></a>
### func \(\*Queries\) TestNameExists

```go
func (q *Queries) TestNameExists(ctx context.Context, name string) (int64, error)
```



<a name="Queries.UpdateMessageRetrieved"></a>
### func \(\*Queries\) UpdateMessageRetrieved

```go
func (q *Queries) UpdateMessageRetrieved(ctx context.Context, arg UpdateMessageRetrievedParams) error
```



<a name="Queries.WithTx"></a>
### func \(\*Queries\) WithTx

```go
func (q *Queries) WithTx(tx *sql.Tx) *Queries
```



<a name="QueuePlugin"></a>
## type QueuePlugin



```go
type QueuePlugin struct{}
```

<a name="QueuePlugin.Init"></a>
### func \(\*QueuePlugin\) Init

```go
func (*QueuePlugin) Init(ctx context.Context, e eng.Engine) bool
```

This init functions points the host functions at the functions that are the ones to a short setup before calling the real implementation.

<a name="RetrieveMessageParams"></a>
## type RetrieveMessageParams



```go
type RetrieveMessageParams struct {
    IDHigh sql.NullInt64
    IDLow  sql.NullInt64
}
```

<a name="UpdateMessageRetrievedParams"></a>
## type UpdateMessageRetrievedParams



```go
type UpdateMessageRetrievedParams struct {
    QueueKey sql.NullInt64
    IDLow    sql.NullInt64
    IDHigh   sql.NullInt64
}
```

# syscall

```go
import "github.com/iansmith/parigot/api/plugin/syscall"
```

## Index

- [Variables](<#variables>)
- [type HostFinder](<#HostFinder>)
- [type OutChannel](<#OutChannel>)
- [type Service](<#Service>)
- [type SyscallData](<#SyscallData>)
- [type SyscallPlugin](<#SyscallPlugin>)
  - [func \(\*SyscallPlugin\) Init\(ctx context.Context, e eng.Engine\) bool](<#SyscallPlugin.Init>)


## Variables

<a name="ParigotInitialize"></a>

```go
var ParigotInitialize apiplugin.ParigotInit = &SyscallPlugin{}
```

<a name="HostFinder"></a>
## type HostFinder

HostFinder returns information about a host in the format used by the syscall struct. It is convention to use the fully qualified name of the service for the name.

```go
type HostFinder interface {
    // FindByName finds the correct host by the name field.
    // If the name cannot be found, it returns nil.
    FindByName(name string) *hostInfo
    // FindById finds the correct host by the id field.
    // If the id cannot be found it returns nil.
    FindById(id id.HostId) *hostInfo
    // AddHost is used to add a record to the set of hosts
    // that are know. This call will panic if either the
    // name or id is not set.
    AddHost(name string, hid id.HostId) syscall.KernelErr
}
```

<a name="OutChannel"></a>
## type OutChannel



```go
type OutChannel struct {
    // contains filtered or unexported fields
}
```

<a name="Service"></a>
## type Service

Service is the logical representation of a service. This is used internally and is not intended for external use.

```go
type Service interface {
    Id() id.ServiceId
    // Name returns a human readable name of the service.
    Name() string
    // Package returns the package name (not the proto package name)
    // of the service.
    Package() string
    // Short returns a nice-to-read version of the service's id.
    Short() string
    // String returns the full id of the service.
    String() string
    // RunRequested returns true if the service has requested
    // to run, but its dependencies are not yet satisfied. Once
    // they are met, the service can start and the Started()
    // method will return true.
    RunRequested() bool
    // Started returns true if the service has started.
    Started() bool
    // Exported returns true if some service provider has said that
    // they implement this service.
    Exported() bool
    // Export causes this service to be marked as exported, thus
    // future calls to Exported() will return true.  This should
    // called in response to the system call of the same name only.
    // The value returned is the previous value of the exported flag,
    // or false when Export() is called the first time.
    Export() bool
    // Method returns all the pairs of MethodName and MethodId
    // for a service known to the SyscallData.  You provide the
    // service to this method to know which set of pairs you want.
    Method() []*syscall.MethodBinding
    // AddMethod is called by the syscall bind method to add a
    // given name/id pair to this service.
    AddMethod(string, id.MethodId)
    //Run is badly named. This really means "block until everything
    //I need is ready."
    Run(context.Context) syscall.KernelErr
    // WakeUp can be called to have this service check to see if the
    // dependencies it has are met.  Note that this need not be called
    // from the "outside" (user code, or even syscall code) because if
    // the graph has no cycles, the calls on this method due to other
    // services finding their requirements have been met is sufficient.
    // A call on this method does not guarantee that the service will start
    // to run, only that it will _check_ to see if that is possible.
    WakeUp()
}
```

<a name="SyscallData"></a>
## type SyscallData

SyscallData is the interface used by the kernel methods \(syscallhost.go\) to get information about the status of a startup sequence.

```go
type SyscallData interface {
    // SetService puts a service into SyscallData.  This should only be
    // called once for each package_ and name pair. It returns the
    // ServiceId for the service named, creating a new one if necessary.
    // The client flag should be set to true only when the requesting
    // party is a client.  All services should pass false here.  This
    // flag effectively means that the requester (package_,name) does not
    // to export their service to be ready to run.
    // If the bool result is false, then the pair already existed and
    // we made no changes to it.
    SetService(ctx context.Context, package_, name string, client bool) (Service, bool)
    // Export finds a service by the given sid and then marks that
    // service as being exported. This function returns nil if
    // there is no such service.
    Export(ctx context.Context, svc id.ServiceId) Service
    // Import introduces a dendency between the sourge and dest
    // services. Thus,  dest must be running before source can run.
    // This function returns a kernel error in two primary cases.
    // 1. one of the src or destination could not be found.  2. The
    // newly introduced edge would create a cycle.
    Import(ctx context.Context, src, dest id.ServiceId) syscall.KernelErr
    // Launch blocks the caller until all the prerequistes have been
    // launched.  It returns false if it returned because of
    // a timeout or the service id cannot be found, otherwise true.
    Launch(context.Context, id.ServiceId) syscall.KernelErr
    // PathExists returns true if there is a sequence of dependency
    // graph vertices that eventually leads from source to target.
    PathExists(ctx context.Context, source, target string) bool
    //ServiceByName looks up a service and returns it based on the
    //values package_ and name.  If this returns nil, the service could
    //not be found.
    ServiceByName(ctx context.Context, package_, name string) Service
    //ServiceById looks up a service and returns it based on the
    //value sid.  If this returns nil, the service could
    //not be found.
    ServiceById(ctx context.Context, sid id.ServiceId) Service
    //ServiceByIdString looks up a service based on the printed representation
    //of the service id.  If the service cannot be found ServiceByIdString
    //returns nil.
    ServiceByIdString(ctx context.Context, str string) Service
}
```

<a name="SyscallPlugin"></a>
## type SyscallPlugin



```go
type SyscallPlugin struct {
}
```

<a name="SyscallPlugin.Init"></a>
### func \(\*SyscallPlugin\) Init

```go
func (*SyscallPlugin) Init(ctx context.Context, e eng.Engine) bool
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
