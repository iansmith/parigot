---
title: Guest APIs
date: _2023-08-04
---

Guest APIs are the guest side APIs (your program) of the built-in services
and parigot proper.

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# lib

```go
import "github.com/iansmith/parigot/api/guest/queue/lib"
```

## Index

- [func FindOrCreateQueue\(ctx context.Context, queueHandle queue.Client, name string\) \*future.Base\[queue.QueueId\]](<#FindOrCreateQueue>)


<a name="FindOrCreateQueue"></a>
## func FindOrCreateQueue

```go
func FindOrCreateQueue(ctx context.Context, queueHandle queue.Client, name string) *future.Base[queue.QueueId]
```

FindOrCreateQueue gets a queue by name, creating it if necessary. The return value will be the queue.QueueIdZeroValue if there was any error, which is a bit dodgy.

# syscall

```go
import "github.com/iansmith/parigot/api/guest/syscall"
```

## Index

- [func BindMethod\(in \*syscall.BindMethodRequest\) \(\*syscall.BindMethodResponse, syscall.KernelErr\)](<#BindMethod>)
- [func BindMethod\_\(int32, int32, int32, int32\) int64](<#BindMethod_>)
- [func ClientSide\[T proto.Message, U proto.Message\]\(ctx context.Context, t T, u U, fn func\(int32, int32, int32, int32\) int64\) \(outU U, outId int32, signal bool\)](<#ClientSide>)
- [func CompleteCall\(ctx context.Context, cid id.CallId, result \*anypb.Any, resultErr int32\) syscall.KernelErr](<#CompleteCall>)
- [func CurrentHostId\(\) id.HostId](<#CurrentHostId>)
- [func Dispatch\(inPtr \*syscall.DispatchRequest\) \(\*syscall.DispatchResponse, syscall.KernelErr\)](<#Dispatch>)
- [func Dispatch\_\(int32, int32, int32, int32\) int64](<#Dispatch_>)
- [func Exit\_\(int32, int32, int32, int32\) int64](<#Exit_>)
- [func ExpireMethod\(ctx context.Context\)](<#ExpireMethod>)
- [func Export\(inPtr \*syscall.ExportRequest\) \(\*syscall.ExportResponse, syscall.KernelErr\)](<#Export>)
- [func Export\_\(int32, int32, int32, int32\) int64](<#Export_>)
- [func Launch\_\(int32, int32, int32, int32\) int64](<#Launch_>)
- [func Locate\(inPtr \*syscall.LocateRequest\) \(\*syscall.LocateResponse, syscall.KernelErr\)](<#Locate>)
- [func Locate\_\(int32, int32, int32, int32\) int64](<#Locate_>)
- [func ManufactureGuestContext\(fn string\) context.Context](<#ManufactureGuestContext>)
- [func MatchCompleter\(cid id.CallId, comp future.Completer\)](<#MatchCompleter>)
- [func MustBindMethodName\(in \*syscall.BindMethodRequest\) id.MethodId](<#MustBindMethodName>)
- [func NewExitCompleter\(f \*ExitFuture\) future.Completer](<#NewExitCompleter>)
- [func NewLaunchCompleter\(f \*LaunchFuture\) future.Completer](<#NewLaunchCompleter>)
- [func ReadOne\(in \*syscall.ReadOneRequest\) \(\*syscall.ReadOneResponse, syscall.KernelErr\)](<#ReadOne>)
- [func ReadOne\_\(int32, int32, int32, int32\) int64](<#ReadOne_>)
- [func Register\(inPtr \*syscall.RegisterRequest\) \(\*syscall.RegisterResponse, syscall.KernelErr\)](<#Register>)
- [func Register\_\(int32, int32, int32, int32\) int64](<#Register_>)
- [func Require\(inPtr \*syscall.RequireRequest\) \(\*syscall.RequireResponse, syscall.KernelErr\)](<#Require>)
- [func Require\_\(int32, int32, int32, int32\) int64](<#Require_>)
- [func ReturnValue\(in \*syscall.ReturnValueRequest\) syscall.KernelErr](<#ReturnValue>)
- [func ReturnValue\_\(int32, int32, int32, int32\) int64](<#ReturnValue_>)
- [func SynchronousExit\(in \*syscall.SynchronousExitRequest\) \(\*syscall.SynchronousExitResponse, syscall.KernelErr\)](<#SynchronousExit>)
- [func SynchronousExit\_\(int32, int32, int32, int32\) int64](<#SynchronousExit_>)
- [type ExitCompleter](<#ExitCompleter>)
  - [func \(l \*ExitCompleter\) CompleteMethod\(ctx context.Context, a proto.Message, e int32\) syscall.KernelErr](<#ExitCompleter.CompleteMethod>)
  - [func \(l \*ExitCompleter\) Failure\(failFunc func\(int32\)\)](<#ExitCompleter.Failure>)
  - [func \(l \*ExitCompleter\) Success\(succFunc func\(proto.Message\)\)](<#ExitCompleter.Success>)
- [type ExitFuture](<#ExitFuture>)
  - [func Exit\(exitReq \*syscall.ExitRequest\) \*ExitFuture](<#Exit>)
  - [func NewExitFuture\(\) \*ExitFuture](<#NewExitFuture>)
  - [func \(l \*ExitFuture\) CompleteMethod\(ctx context.Context, lr \*syscall.ExitResponse, err syscall.KernelErr\)](<#ExitFuture.CompleteMethod>)
  - [func \(l \*ExitFuture\) Failure\(fn func\(syscall.KernelErr\)\)](<#ExitFuture.Failure>)
  - [func \(l \*ExitFuture\) Success\(fn func\(\*syscall.ExitResponse\)\)](<#ExitFuture.Success>)
- [type LaunchCompleter](<#LaunchCompleter>)
  - [func \(l \*LaunchCompleter\) CompleteMethod\(ctx context.Context, a proto.Message, e int32\) syscall.KernelErr](<#LaunchCompleter.CompleteMethod>)
  - [func \(l \*LaunchCompleter\) Failure\(failFunc func\(int32\)\)](<#LaunchCompleter.Failure>)
  - [func \(l \*LaunchCompleter\) Success\(succFunc func\(proto.Message\)\)](<#LaunchCompleter.Success>)
- [type LaunchFuture](<#LaunchFuture>)
  - [func Launch\(inPtr \*syscall.LaunchRequest\) \*LaunchFuture](<#Launch>)
  - [func NewLaunchFuture\(\) \*LaunchFuture](<#NewLaunchFuture>)
  - [func \(l \*LaunchFuture\) CompleteMethod\(ctx context.Context, lr \*syscall.LaunchResponse, err syscall.KernelErr\)](<#LaunchFuture.CompleteMethod>)
  - [func \(l \*LaunchFuture\) Completed\(\) bool](<#LaunchFuture.Completed>)
  - [func \(l \*LaunchFuture\) Failure\(fn func\(syscall.KernelErr\)\)](<#LaunchFuture.Failure>)
  - [func \(l \*LaunchFuture\) Success\(fn func\(\*syscall.LaunchResponse\)\)](<#LaunchFuture.Success>)


<a name="BindMethod"></a>
## func BindMethod

```go
func BindMethod(in *syscall.BindMethodRequest) (*syscall.BindMethodResponse, syscall.KernelErr)
```



<a name="BindMethod_"></a>
## func BindMethod\_

```go
func BindMethod_(int32, int32, int32, int32) int64
```

BindMethod is the way that a particular service gets associated with a given method id. This is normally not needed by user code because the generated code for any service will call this automatically.

func BindMethod\(\*syscall.BindMethodRequest\) \*syscall.BindMethodResponse

<a name="ClientSide"></a>
## func ClientSide

```go
func ClientSide[T proto.Message, U proto.Message](ctx context.Context, t T, u U, fn func(int32, int32, int32, int32) int64) (outU U, outId int32, signal bool)
```

ClientSide does the marshalling and unmarshalling needed to read the T given, write the U given, and return the KernelErrId properly. It does these manipulations so you can call a lower level function that is implemented by the host. The final bool is a meta indicator about if we detected a crash and the client side of the program should exit.

<a name="CompleteCall"></a>
## func CompleteCall

```go
func CompleteCall(ctx context.Context, cid id.CallId, result *anypb.Any, resultErr int32) syscall.KernelErr
```

CompleteCall is called from the ReadOneAndCall handler to cause a prior dispatch call to be completed. The matching is done based on the cid.

<a name="CurrentHostId"></a>
## func CurrentHostId

```go
func CurrentHostId() id.HostId
```



<a name="Dispatch"></a>
## func Dispatch

```go
func Dispatch(inPtr *syscall.DispatchRequest) (*syscall.DispatchResponse, syscall.KernelErr)
```



<a name="Dispatch_"></a>
## func Dispatch\_

```go
func Dispatch_(int32, int32, int32, int32) int64
```

Dispatch is the primary means that a caller can send an RPC message. If you are in local development mode, this call is handled by the kernel itself, otherwise it implies a remote procedure call. This method checks the returned response for errors. If there are errors inside the result they are pulled out and returned in the error parameter. Thus if the error parameter is nil, the Dispatch\(\) occurred successfully. This is code that runs on the WASM side.

<a name="Exit_"></a>
## func Exit\_

```go
func Exit_(int32, int32, int32, int32) int64
```

Exit is called from the WASM side to cause the WASM program, or all the WASM programs, to exit. The future the future is called when the exit is recognized, but it is not called when the actual shutdown occurs. The future given here is called when the Exit\(\) itself as has been completed. For something run just before the program stops, use AtExit.

<a name="ExpireMethod"></a>
## func ExpireMethod

```go
func ExpireMethod(ctx context.Context)
```

ExpireMethod\(\) checks the internal list of guest side futures that have no call id associated with them. These futures come about when a implementation of a server function returns a future that is not completed. This future likely exists because the implementation of the server function called another service and the result of the server function thus cannot be calculated immediately. When the call is completed, the Success or Failure functions will be called on the original future. This function exists to maintain a list so that we can expire and cancel futures that have waiting longer than the timeout time.

<a name="Export"></a>
## func Export

```go
func Export(inPtr *syscall.ExportRequest) (*syscall.ExportResponse, syscall.KernelErr)
```



<a name="Export_"></a>
## func Export\_

```go
func Export_(int32, int32, int32, int32) int64
```

Export is a declaration that a service implements a particular interface. This is not needed by most user code that will use queue.ExportQueueServiceOrPanic\(\) to export itself as the queue service.

<a name="Launch_"></a>
## func Launch\_

```go
func Launch_(int32, int32, int32, int32) int64
```

Run is starts a service \(or a guest application\) running. Note that this may not return immediately and may fail entirely. For most user code this is not used because user code usually uses file.MustFileServiceRun\(\) to block service File until it is cleared to run.

<a name="Locate"></a>
## func Locate

```go
func Locate(inPtr *syscall.LocateRequest) (*syscall.LocateResponse, syscall.KernelErr)
```



<a name="Locate_"></a>
## func Locate\_

```go
func Locate_(int32, int32, int32, int32) int64
```

Locate is the means of aquiring a handle to a particular service. Most users will not want this interface, but rather will use the auto generated method LocateFooOrPanic\(\) for getting an initial handle the Foo service.

func Locate\(\*syscall.LocateRequest\) \*syscall.LocateResponse

<a name="ManufactureGuestContext"></a>
## func ManufactureGuestContext

```go
func ManufactureGuestContext(fn string) context.Context
```

Manufacture context is used to setup the context for a given state that makes sense for this, the Guest side of the wire. You pass the name of the function you are constructing this in.

<a name="MatchCompleter"></a>
## func MatchCompleter

```go
func MatchCompleter(cid id.CallId, comp future.Completer)
```

MatchCompleter is a utility for adding a new cid and completer to the tables used to look up the location where response values should be sent.

<a name="MustBindMethodName"></a>
## func MustBindMethodName

```go
func MustBindMethodName(in *syscall.BindMethodRequest) id.MethodId
```



<a name="NewExitCompleter"></a>
## func NewExitCompleter

```go
func NewExitCompleter(f *ExitFuture) future.Completer
```



<a name="NewLaunchCompleter"></a>
## func NewLaunchCompleter

```go
func NewLaunchCompleter(f *LaunchFuture) future.Completer
```



<a name="ReadOne"></a>
## func ReadOne

```go
func ReadOne(in *syscall.ReadOneRequest) (*syscall.ReadOneResponse, syscall.KernelErr)
```



<a name="ReadOne_"></a>
## func ReadOne\_

```go
func ReadOne_(int32, int32, int32, int32) int64
```

ReadOne checks to see if any of the service/method pairs have been called. Timeouts of negative values \(forever\) and 0 \(instant check\) are legal.

<a name="Register"></a>
## func Register

```go
func Register(inPtr *syscall.RegisterRequest) (*syscall.RegisterResponse, syscall.KernelErr)
```



<a name="Register_"></a>
## func Register\_

```go
func Register_(int32, int32, int32, int32) int64
```

Register should be called before any other services are Required, Exported, or Located.

<a name="Require"></a>
## func Require

```go
func Require(inPtr *syscall.RequireRequest) (*syscall.RequireResponse, syscall.KernelErr)
```



<a name="Require_"></a>
## func Require\_

```go
func Require_(int32, int32, int32, int32) int64
```

Require is a declaration that a service needs a particular interface. This is not needed by most user code that will use queue.ImpleQueueServiceOrPanic\(\) to import the queue service.

<a name="ReturnValue"></a>
## func ReturnValue

```go
func ReturnValue(in *syscall.ReturnValueRequest) syscall.KernelErr
```



<a name="ReturnValue_"></a>
## func ReturnValue\_

```go
func ReturnValue_(int32, int32, int32, int32) int64
```

ReturnValue is for providing return values for calls that have been made on the local service.

<a name="SynchronousExit"></a>
## func SynchronousExit

```go
func SynchronousExit(in *syscall.SynchronousExitRequest) (*syscall.SynchronousExitResponse, syscall.KernelErr)
```



<a name="SynchronousExit_"></a>
## func SynchronousExit\_

```go
func SynchronousExit_(int32, int32, int32, int32) int64
```

SynchronousExit is a request that is sent to a service to tell the service it will exit shortly \(order of milliseconds\) and resources should be cleaned up. Note that this can happen when another service actually made the Exit\(\) call.

<a name="ExitCompleter"></a>
## type ExitCompleter



```go
type ExitCompleter struct {
    // contains filtered or unexported fields
}
```

<a name="ExitCompleter.CompleteMethod"></a>
### func \(\*ExitCompleter\) CompleteMethod

```go
func (l *ExitCompleter) CompleteMethod(ctx context.Context, a proto.Message, e int32) syscall.KernelErr
```



<a name="ExitCompleter.Failure"></a>
### func \(\*ExitCompleter\) Failure

```go
func (l *ExitCompleter) Failure(failFunc func(int32))
```



<a name="ExitCompleter.Success"></a>
### func \(\*ExitCompleter\) Success

```go
func (l *ExitCompleter) Success(succFunc func(proto.Message))
```



<a name="ExitFuture"></a>
## type ExitFuture

ExitFuture is the return type of Exit\(\) on the guest side. This is a future because it is not certain exactly when the Exit will actually occur. Further, the exit itself might fail, so the program may not exit at all.

```go
type ExitFuture struct {
    // contains filtered or unexported fields
}
```

<a name="Exit"></a>
### func Exit

```go
func Exit(exitReq *syscall.ExitRequest) *ExitFuture
```



<a name="NewExitFuture"></a>
### func NewExitFuture

```go
func NewExitFuture() *ExitFuture
```

NewExitFuture returns an initialized exit future. It is not useful to attempt to determine if the exit has "completed" as the program would no longer exit.

<a name="ExitFuture.CompleteMethod"></a>
### func \(\*ExitFuture\) CompleteMethod

```go
func (l *ExitFuture) CompleteMethod(ctx context.Context, lr *syscall.ExitResponse, err syscall.KernelErr)
```

CompleteMethod is used to complete a previously defined future of type ExitFuture.

<a name="ExitFuture.Failure"></a>
### func \(\*ExitFuture\) Failure

```go
func (l *ExitFuture) Failure(fn func(syscall.KernelErr))
```

Failure should be called to add a function to be called when the Exit\(\) has fully completed and was unsuccessful. Note that this situation is a serious internal error in parigot when the given method fn is called. It is appropriate to take drastic measures like \`os.Exit\(1\)\` to force the abort of the program.

<a name="ExitFuture.Success"></a>
### func \(\*ExitFuture\) Success

```go
func (l *ExitFuture) Success(fn func(*syscall.ExitResponse))
```

Success should be called to add a function to be called when the Exit\(\) has fully completed and did so successfully. Adding an exit function here can useful to clean up resources, with the understanding that the program is \_about\_ to exit. The function fn should NOT exit the program with a call like os.Exit\(1\), this will happen once all the Success functions on the ExitFuture have been called.

<a name="LaunchCompleter"></a>
## type LaunchCompleter



```go
type LaunchCompleter struct {
    // contains filtered or unexported fields
}
```

<a name="LaunchCompleter.CompleteMethod"></a>
### func \(\*LaunchCompleter\) CompleteMethod

```go
func (l *LaunchCompleter) CompleteMethod(ctx context.Context, a proto.Message, e int32) syscall.KernelErr
```



<a name="LaunchCompleter.Failure"></a>
### func \(\*LaunchCompleter\) Failure

```go
func (l *LaunchCompleter) Failure(failFunc func(int32))
```



<a name="LaunchCompleter.Success"></a>
### func \(\*LaunchCompleter\) Success

```go
func (l *LaunchCompleter) Success(succFunc func(proto.Message))
```



<a name="LaunchFuture"></a>
## type LaunchFuture

LaunchFuture is the return type of Launch\(\) on the guest side. The guest receives the future in response to a Launch\(\) call and should attach Success\(\) and Failure\(\) funcs as needed. If the Completed\(\) call is true, the methods added in Success\(\) or Failure\(\) will be called immediately.

```go
type LaunchFuture struct {
    // contains filtered or unexported fields
}
```

<a name="Launch"></a>
### func Launch

```go
func Launch(inPtr *syscall.LaunchRequest) *LaunchFuture
```



<a name="NewLaunchFuture"></a>
### func NewLaunchFuture

```go
func NewLaunchFuture() *LaunchFuture
```



<a name="LaunchFuture.CompleteMethod"></a>
### func \(\*LaunchFuture\) CompleteMethod

```go
func (l *LaunchFuture) CompleteMethod(ctx context.Context, lr *syscall.LaunchResponse, err syscall.KernelErr)
```

CompleteMethod fills in the results for a Method future and it works the same for LaunchResponse.

<a name="LaunchFuture.Completed"></a>
### func \(\*LaunchFuture\) Completed

```go
func (l *LaunchFuture) Completed() bool
```

Completed returns if the given LaunchFuture has already been completed. This might be interesting for some guests if they wish to bypass the futures mechanism in the case where the Launch\(\) has already finished. Note that quick completion of Launch\(\) is NOT guaranteed in all cases so clients that use this method to bypass futures must also have a backup approach for when the Launch\(\) takes some time to complete.

<a name="LaunchFuture.Failure"></a>
### func \(\*LaunchFuture\) Failure

```go
func (l *LaunchFuture) Failure(fn func(syscall.KernelErr))
```

Failure should be called to add a function to be called when the Launch\(\) has fully completed and was unsuccessful.

<a name="LaunchFuture.Success"></a>
### func \(\*LaunchFuture\) Success

```go
func (l *LaunchFuture) Success(fn func(*syscall.LaunchResponse))
```

Success should be called to add a function to be called when the Launch\(\) has fully completed and did so successfully.

# lib

```go
import "github.com/iansmith/parigot/lib/go"
```

## Index

- [func ClientOnlyReadOneAndCall\(ctx context.Context, binding \*ServiceMethodMap, timeoutInMillis int32\) syscall.KernelErr](<#ClientOnlyReadOneAndCall>)
- [func ExitClient\(ctx context.Context, code int32, myId id.ServiceId, msgSuccess, msgFailure string\)](<#ExitClient>)
- [func Export1\(pkg, name string, serviceId id.ServiceId\) \(\*syscall.ExportResponse, syscall.KernelErr\)](<#Export1>)
- [func FlagParseCreateEnv\(\)](<#FlagParseCreateEnv>)
- [func Getenv\(envvar string\) string](<#Getenv>)
- [func LaunchClient\(ctx context.Context, myId id.ServiceId\) \*syscallguest.LaunchFuture](<#LaunchClient>)
- [func LookupEnv\(envvar string\) \(string, bool\)](<#LookupEnv>)
- [func MustInitClient\(ctx context.Context, requirement \[\]MustRequireFunc\) id.ServiceId](<#MustInitClient>)
- [func MustRegisterClient\(ctx context.Context\) id.ServiceId](<#MustRegisterClient>)
- [func MustRunClient\(ctx context.Context, timeoutInMillis int32\) syscall.KernelErr](<#MustRunClient>)
- [func Require1\(pkg, name string, source id.ServiceId\) \(\*syscall.RequireResponse, syscall.KernelErr\)](<#Require1>)
- [type Backgrounder](<#Backgrounder>)
- [type FuncAnyIO](<#FuncAnyIO>)
- [type MustRequireFunc](<#MustRequireFunc>)
- [type ServiceMethodMap](<#ServiceMethodMap>)
  - [func NewServiceMethodMap\(\) \*ServiceMethodMap](<#NewServiceMethodMap>)
  - [func \(s \*ServiceMethodMap\) AddServiceMethod\(sid id.ServiceId, mid id.MethodId, serviceName, methodName string, fn future.Invoker\)](<#ServiceMethodMap.AddServiceMethod>)
  - [func \(s \*ServiceMethodMap\) Call\(\) \[\]\*syscall.ServiceMethodCall](<#ServiceMethodMap.Call>)
  - [func \(s \*ServiceMethodMap\) Disable\(sid id.ServiceId, mid id.MethodId\)](<#ServiceMethodMap.Disable>)
  - [func \(s \*ServiceMethodMap\) Enable\(sid id.ServiceId, mid id.MethodId\)](<#ServiceMethodMap.Enable>)
  - [func \(s \*ServiceMethodMap\) Func\(sid id.ServiceId, mid id.MethodId\) future.Invoker](<#ServiceMethodMap.Func>)
  - [func \(s \*ServiceMethodMap\) Len\(\) int](<#ServiceMethodMap.Len>)
  - [func \(s \*ServiceMethodMap\) MethodIdToName\(mid id.MethodId\) string](<#ServiceMethodMap.MethodIdToName>)
  - [func \(s \*ServiceMethodMap\) MethodNameToId\(sid id.ServiceId, methodName string\) id.MethodId](<#ServiceMethodMap.MethodNameToId>)


<a name="ClientOnlyReadOneAndCall"></a>
## func ClientOnlyReadOneAndCall

```go
func ClientOnlyReadOneAndCall(ctx context.Context, binding *ServiceMethodMap, timeoutInMillis int32) syscall.KernelErr
```

ClientOnlyReadOneAndCall does the waiting for an incoming call and if one arrives, it dispatches the call to the appropriate method. Similarly, it will detect and respond to finished futures. It returns KernelErr\_ReadOneTimeout if the waiting timed out, otherwise the value should be KernelErr\_NoError or an appropriate error code.

<a name="ExitClient"></a>
## func ExitClient

```go
func ExitClient(ctx context.Context, code int32, myId id.ServiceId, msgSuccess, msgFailure string)
```

ExitClient sends a request to exit and attaches hanndlers that print the given strings. It only forces the exit if the Exit call itself fails. Only the values from 0 to 192 are permissable as the code; other values will be changed to 192.

<a name="Export1"></a>
## func Export1

```go
func Export1(pkg, name string, serviceId id.ServiceId) (*syscall.ExportResponse, syscall.KernelErr)
```

Export1 is a thin wrapper over syscall.Export so it's easy to export things by their name. This is used by the code generator primarily.

<a name="FlagParseCreateEnv"></a>
## func FlagParseCreateEnv

```go
func FlagParseCreateEnv()
```



<a name="Getenv"></a>
## func Getenv

```go
func Getenv(envvar string) string
```

This is a workalike for os.Getenv\(\)

<a name="LaunchClient"></a>
## func LaunchClient

```go
func LaunchClient(ctx context.Context, myId id.ServiceId) *syscallguest.LaunchFuture
```

LaunchClient is a convienence wrapper around Launch\(\) for clients that don't want to create their own request structure.

<a name="LookupEnv"></a>
## func LookupEnv

```go
func LookupEnv(envvar string) (string, bool)
```

This is a workalike for os.LookupEnv\(\). It can be used to differentiate an empty, but set, environment variable from the an enviroment variable that is simply not present.

<a name="MustInitClient"></a>
## func MustInitClient

```go
func MustInitClient(ctx context.Context, requirement []MustRequireFunc) id.ServiceId
```

MustInitClient is for clients only. In other words, you should only use this function if you do not implement services, just use them. A common case of this is a demo program or a program that performs a one off task. This function wraps MustRegisterClient and panics if things go wrong.

<a name="MustRegisterClient"></a>
## func MustRegisterClient

```go
func MustRegisterClient(ctx context.Context) id.ServiceId
```

MustRegisterClient should be used by the "main" function of a client program that is not service itself, in other words it is a client only. If you are a service, you should use the automagically generated code MustRegister\<BLAH\>\(\).

<a name="MustRunClient"></a>
## func MustRunClient

```go
func MustRunClient(ctx context.Context, timeoutInMillis int32) syscall.KernelErr
```



<a name="Require1"></a>
## func Require1

```go
func Require1(pkg, name string, source id.ServiceId) (*syscall.RequireResponse, syscall.KernelErr)
```

Require1 is a thin wrapper over syscall.Require so it's easy to require things by their name. This is used by the code generator primarily.

<a name="Backgrounder"></a>
## type Backgrounder

Backgrounder is an interface that can be implemented by types that want to get period background calls when the latest attempt to receive a call has timed out. Note that when the background is actually running \(in Background\) their are no attempts to retreive method calls on this service.

```go
type Backgrounder interface {
    Background(context.Context)
}
```

<a name="FuncAnyIO"></a>
## type FuncAnyIO

FuncAnyIO is the type of the guest\-side functions that implement the set and tear down of method implementations in a server. If a method fleazil is defined on a service, it will have FuncAnyIO wrapper that unmarshals input parameters and marshals the return value.

```go
type FuncAnyIO func(*anypb.Any) future.Method[*anypb.Any, int32]
```

<a name="MustRequireFunc"></a>
## type MustRequireFunc

MustRequireFunc is the type of the functions that are created by the code generator from protobuf definitions of the form MustRequireXXXX\(\). These are used in the function RunXXXX\(\) to indicate required services \(dependencies\).

```go
type MustRequireFunc func(context.Context, id.ServiceId)
```

<a name="ServiceMethodMap"></a>
## type ServiceMethodMap

ServiceMethodMap is the data structure that provides conversions between a service/method pair and their variants. A service or method can be converted to a string with their String\(\) method and this method can convert that string back to the appropriate service or method. The ServiceMethodMap can also convert between the human readable names of services and methods and their appropriate Ids. It contains a mapping from a service/method pair to a FuncAnyIO that is the guest\-side implementation of the method. Finally, it allows particular methods to be enabled and disabled so they will not be used when generating the list of pairs for a call to ReadOne\(\).

```go
type ServiceMethodMap struct {
    // contains filtered or unexported fields
}
```

<a name="NewServiceMethodMap"></a>
### func NewServiceMethodMap

```go
func NewServiceMethodMap() *ServiceMethodMap
```



<a name="ServiceMethodMap.AddServiceMethod"></a>
### func \(\*ServiceMethodMap\) AddServiceMethod

```go
func (s *ServiceMethodMap) AddServiceMethod(sid id.ServiceId, mid id.MethodId, serviceName, methodName string, fn future.Invoker)
```

AddServiceMethod is called when a new method has been bound. This method creates various data structures needed to be able to look up the service and method later, as well as find the appropriate Invoker associated with pair. Note that the Invoker may be nil when the function is not available in this address space and any caller must use Dispatch\(\).

<a name="ServiceMethodMap.Call"></a>
### func \(\*ServiceMethodMap\) Call

```go
func (s *ServiceMethodMap) Call() []*syscall.ServiceMethodCall
```

Pair returns a list of Service/Method pairs suitable for use in a ReadOneRequest. Particular elements of the map can be omitted or included with Disable and Enable.

<a name="ServiceMethodMap.Disable"></a>
### func \(\*ServiceMethodMap\) Disable

```go
func (s *ServiceMethodMap) Disable(sid id.ServiceId, mid id.MethodId)
```

Disable "turns off" a service/method pair within this map. This pair will not appear in results of Pair\(\) until Enable is called for this pair. If the values of this pair of ids does not correspond to a real pair that is known to the service, this call is ignored. Disable can be useful in production situations where you want disable methods on an object that are only for testing.

<a name="ServiceMethodMap.Enable"></a>
### func \(\*ServiceMethodMap\) Enable

```go
func (s *ServiceMethodMap) Enable(sid id.ServiceId, mid id.MethodId)
```

Enable "turns on" a given service/method pair within the map. Thus the pair will be returned as part of the Pair\(\) result. If the pair of these ids is not found, this call is ignored. Enable can be useful in testing situations where you want enable methods on an object that are only for testing.

<a name="ServiceMethodMap.Func"></a>
### func \(\*ServiceMethodMap\) Func

```go
func (s *ServiceMethodMap) Func(sid id.ServiceId, mid id.MethodId) future.Invoker
```

Func returns the FuncAnyIO object associated with the sid and mid pair. If either sid or mid cannot be found, it returns nil.

<a name="ServiceMethodMap.Len"></a>
### func \(\*ServiceMethodMap\) Len

```go
func (s *ServiceMethodMap) Len() int
```

Len returns the number of known methods in this ServiceMethodMap

<a name="ServiceMethodMap.MethodIdToName"></a>
### func \(\*ServiceMethodMap\) MethodIdToName

```go
func (s *ServiceMethodMap) MethodIdToName(mid id.MethodId) string
```

MethodIdToName is used to find a method given a particular service id. This function returns "" if either the service or the method cannot be found. This does not require a service id because method ids are unique.

<a name="ServiceMethodMap.MethodNameToId"></a>
### func \(\*ServiceMethodMap\) MethodNameToId

```go
func (s *ServiceMethodMap) MethodNameToId(sid id.ServiceId, methodName string) id.MethodId
```

MethodNameToId is used to find a method by name, given a particular service id. This function returns the value MethodIdZeroValue if either the service or the method cannot be found.

# client

```go
import "github.com/iansmith/parigot/lib/go/client"
```

## Index

- [type BaseService](<#BaseService>)
  - [func LocateDynamic\(ctx context.Context, protoPkg, serviceName string, calledBy id.ServiceId\) \(\*BaseService, syscall.KernelErr\)](<#LocateDynamic>)
  - [func NewBaseService\(ctx context.Context, id id.ServiceId, sm \*lib.ServiceMethodMap\) \*BaseService](<#NewBaseService>)
  - [func \(c \*BaseService\) Dispatch\(method id.MethodId, param proto.Message\) \(id.CallId, syscall.KernelErr\)](<#BaseService.Dispatch>)
  - [func \(c \*BaseService\) MethodIdByName\(str string\) \(id.MethodId, bool\)](<#BaseService.MethodIdByName>)
  - [func \(c \*BaseService\) ServiceId\(\) id.ServiceId](<#BaseService.ServiceId>)
  - [func \(c \*BaseService\) ServiceMethodMap\(\) \*lib.ServiceMethodMap](<#BaseService.ServiceMethodMap>)
  - [func \(c \*BaseService\) String\(\) string](<#BaseService.String>)


<a name="BaseService"></a>
## type BaseService

BaseService is a type that is used for all client \(call origin\) side implementations. This includes any client in the guest codespace. This object primarily just receives message call requests and this type sends it to the kernel.

```go
type BaseService struct {
    // contains filtered or unexported fields
}
```

<a name="LocateDynamic"></a>
### func LocateDynamic

```go
func LocateDynamic(ctx context.Context, protoPkg, serviceName string, calledBy id.ServiceId) (*BaseService, syscall.KernelErr)
```

LocateDynamic is an important interface to the infrastructure's knowlege about the types and methods of services. This method takes a package and a service name and returns a client side proxy that can call all the methods that the system knows about for the given service. This is usually used by the code generate to then wrap method declarations around to give the resulting client object an API that is more what is expected. However, it can be used "uncooked" and its methods called via Dispatch\(\). This is the only mechanism by which you can call methods on services that are not known at compile time, e.g. looking up a service by package and name, then and calling methods on the service entirely by using strings.

<a name="NewBaseService"></a>
### func NewBaseService

```go
func NewBaseService(ctx context.Context, id id.ServiceId, sm *lib.ServiceMethodMap) *BaseService
```

NewBaseService creates.

<a name="BaseService.Dispatch"></a>
### func \(\*BaseService\) Dispatch

```go
func (c *BaseService) Dispatch(method id.MethodId, param proto.Message) (id.CallId, syscall.KernelErr)
```

Dispatch is called by every client side "method" on the client side service. This funciton is the one that make a system call to the kernel and prepares for handling the result.

<a name="BaseService.MethodIdByName"></a>
### func \(\*BaseService\) MethodIdByName

```go
func (c *BaseService) MethodIdByName(str string) (id.MethodId, bool)
```



<a name="BaseService.ServiceId"></a>
### func \(\*BaseService\) ServiceId

```go
func (c *BaseService) ServiceId() id.ServiceId
```



<a name="BaseService.ServiceMethodMap"></a>
### func \(\*BaseService\) ServiceMethodMap

```go
func (c *BaseService) ServiceMethodMap() *lib.ServiceMethodMap
```



<a name="BaseService.String"></a>
### func \(\*BaseService\) String

```go
func (c *BaseService) String() string
```

String\(\) returns a useful string for debugging a client side service. This includes all the known methods for the service.

# future

```go
import "github.com/iansmith/parigot/lib/go/future"
```

The concept of a "future" is important in parigot. For any programming language that can create closures, this concept allows one to write parigot programs that are singly\-threaded. A future is similar to a promise in Javascript and related languages.

A future represents a computation that has not completed yet, but is expected to be completed in the near future. A future is "completed" when its value or values are known because the computation that was being waited on has finished. In the case of parigot, frequently that computation has been completed by another process or another process on another machine.

parigot offers two types of futures, Base and Method. Base futures represent a single value and the result can be acted upon in the method Handle\(\). Base futures are used when a single value, such as bool, is being computed but it is not completed as\-of yet. The method Ready\(\) on a service returns a Base future to inidicate if a service can start or not \(bool\).

Method futures are a special case of future that is used frequently in parigot. Method futures represent the value of a remote method call that has not completed yet. The value of a method call is computed by some other program and then set to indicate the value\(s\) of that this method has returned. In the simple case of all the programs being run in a single address space \(process\) this other program is another WASM binary executing inside the same WASM engine.

## Index

- [type AllFuture](<#AllFuture>)
  - [func All\[T proto.Message, U ErrorType\]\(dep ...\*Method\[T, U\]\) \*AllFuture\[T, U\]](<#All>)
  - [func NewAllFuture\[T proto.Message, U ErrorType\]\(dep \[\]\*Method\[T, U\]\) \*AllFuture\[T, U\]](<#NewAllFuture>)
  - [func \(a \*AllFuture\[T, U\]\) AllDependent\(\) \[\]\*Method\[T, U\]](<#AllFuture[T, U].AllDependent>)
  - [func \(a \*AllFuture\[T, U\]\) Failure\(fn func\(int\)\)](<#AllFuture[T, U].Failure>)
  - [func \(a \*AllFuture\[T, U\]\) Success\(fn func\(\)\)](<#AllFuture[T, U].Success>)
- [type Base](<#Base>)
  - [func NewBase\[T any\]\(\) \*Base\[T\]](<#NewBase>)
  - [func NewBaseWithValue\[T any\]\(t T\) \*Base\[T\]](<#NewBaseWithValue>)
  - [func \(f \*Base\[T\]\) Cancel\(\)](<#Base[T].Cancel>)
  - [func \(f \*Base\[T\]\) Completed\(\) bool](<#Base[T].Completed>)
  - [func \(f \*Base\[T\]\) Handle\(fn func\(T\)\)](<#Base[T].Handle>)
  - [func \(f \*Base\[T\]\) HandleLater\(fn func\(T\)\)](<#Base[T].HandleLater>)
  - [func \(f \*Base\[T\]\) Set\(t T\) bool](<#Base[T].Set>)
  - [func \(f \*Base\[T\]\) String\(\) string](<#Base[T].String>)
- [type Completer](<#Completer>)
- [type ErrorType](<#ErrorType>)
- [type Invoker](<#Invoker>)
- [type Method](<#Method>)
  - [func NewMethod\[T proto.Message, U ErrorType\]\(resolve func\(T\), reject func\(U\)\) \*Method\[T, U\]](<#NewMethod>)
  - [func \(m \*Method\[T, U\]\) Cancel\(\)](<#Method[T, U].Cancel>)
  - [func \(f \*Method\[T, U\]\) CompleteMethod\(ctx context.Context, result T, resultErr U\)](<#Method[T, U].CompleteMethod>)
  - [func \(f \*Method\[T, U\]\) Completed\(\) bool](<#Method[T, U].Completed>)
  - [func \(f \*Method\[T, U\]\) Failure\(fn func\(U\)\)](<#Method[T, U].Failure>)
  - [func \(f \*Method\[T, U\]\) String\(\) string](<#Method[T, U].String>)
  - [func \(f \*Method\[T, U\]\) Success\(fn func\(T\)\)](<#Method[T, U].Success>)
  - [func \(f \*Method\[T, U\]\) ValueErr\(\) U](<#Method[T, U].ValueErr>)
  - [func \(f \*Method\[T, U\]\) ValueResponse\(\) T](<#Method[T, U].ValueResponse>)
  - [func \(m \*Method\[T, U\]\) WaitingId\(\) string](<#Method[T, U].WaitingId>)
  - [func \(f \*Method\[T, U\]\) WasSuccess\(\) bool](<#Method[T, U].WasSuccess>)


<a name="AllFuture"></a>
## type AllFuture

AllFuture is the underlying Future type for a call to the All\(\) function. As with Base and Method, this future queues all the calls to Success\(\) and Failure\(\).

```go
type AllFuture[T proto.Message, U ErrorType] struct {
    // contains filtered or unexported fields
}
```

<a name="All"></a>
### func All

```go
func All[T proto.Message, U ErrorType](dep ...*Method[T, U]) *AllFuture[T, U]
```

All waits for all its dependent futures to complete and if they all complete successfully, it calls the Success function, otherwise the index of a failing future is sent to the Failure\(\) method.

<a name="NewAllFuture"></a>
### func NewAllFuture

```go
func NewAllFuture[T proto.Message, U ErrorType](dep []*Method[T, U]) *AllFuture[T, U]
```



<a name="AllFuture[T, U].AllDependent"></a>
### func \(\*AllFuture\[T, U\]\) AllDependent

```go
func (a *AllFuture[T, U]) AllDependent() []*Method[T, U]
```



<a name="AllFuture[T, U].Failure"></a>
### func \(\*AllFuture\[T, U\]\) Failure

```go
func (a *AllFuture[T, U]) Failure(fn func(int))
```



<a name="AllFuture[T, U].Success"></a>
### func \(\*AllFuture\[T, U\]\) Success

```go
func (a *AllFuture[T, U]) Success(fn func())
```



<a name="Base"></a>
## type Base

Base\[T\] represents a future computation resulting in a T. This is useful for simple value types such bool and int64. It only has one user\-visible method which is Handle\(\) and that is used to set a handler for when the value of type T actually arrives.

```go
type Base[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewBase"></a>
### func NewBase

```go
func NewBase[T any]() *Base[T]
```

NewBase returns a new pointer at a Base\[T\]. The value will be the zero value of T and the future is not marked completed. If you wish to make the zero value the result of the future you should use NewBaseWithValue or Set\(\).

<a name="NewBaseWithValue"></a>
### func NewBaseWithValue

```go
func NewBaseWithValue[T any](t T) *Base[T]
```

NewBaseWithValue creates a new pointer a Base\[T\] with the given value and with future marked as completed.

<a name="Base[T].Cancel"></a>
### func \(\*Base\[T\]\) Cancel

```go
func (f *Base[T]) Cancel()
```

Cancel causes the future's state to be cleared and the future to be marked completed. Any calls to Set\(\) that occur after Cancel\(\) and before any other calls to Handle\(\) will have no effect. Any existing chain of Handle\(\) functions will be removed from the future by Cancel\(\). Since the call to Cancel\(\) marks the

<a name="Base[T].Completed"></a>
### func \(\*Base\[T\]\) Completed

```go
func (f *Base[T]) Completed() bool
```

Completed returns true if all the Handle\(\) functions on this future have run. Note that is can be changed by the addition of new Handle\(\) functions via Handle\(\).

<a name="Base[T].Handle"></a>
### func \(\*Base\[T\]\) Handle

```go
func (f *Base[T]) Handle(fn func(T))
```



<a name="Base[T].HandleLater"></a>
### func \(\*Base\[T\]\) HandleLater

```go
func (f *Base[T]) HandleLater(fn func(T))
```

HnadleLater is used in the rare instance can where you have a future that has possibly completed all of its Handle\(\) functions and you wish to delay the excution of fn until the next Set\(\) call. Note that the default behavior of Handle\(\) would be to run fn immediately, and thus you only need this function if you call must Set multiple times on the same future with the possibility that is already completed.

<a name="Base[T].Set"></a>
### func \(\*Base\[T\]\) Set

```go
func (f *Base[T]) Set(t T) bool
```

Set causes the future it is called on be marked as completed with the given value. This will cause all registered Handle\(\) functions to run. Set can be called multiple times and the effect is that only the as yet incomplete Handle\(\) functions will be executed as a result. These previously unexecuted handle functions will be marked and and have their result values set to the value of \*this\* call to set. It is thus possible that different handlers will run with different values as their parameters. Set returns true if any Handle functions were run.

<a name="Base[T].String"></a>
### func \(\*Base\[T\]\) String

```go
func (f *Base[T]) String() string
```

Strings returns a human\-friendly representation of this Base futuer. It returns if the future is complete or not.

<a name="Completer"></a>
## type Completer

Completer is the interface that means that a given type can be "completed" at a later time. This is used only for Methods.

```go
type Completer interface {
    CompleteMethod(ctx context.Context, msg proto.Message, resultErr int32) syscall.KernelErr
    Success(func(proto.Message))
    Failure(func(int32))
}
```

<a name="ErrorType"></a>
## type ErrorType



```go
type ErrorType interface {
    // contains filtered or unexported methods
}
```

<a name="Invoker"></a>
## type Invoker

Invoker is the interface that means that a given type be run as an implementation of a function..

```go
type Invoker interface {
    // Invoke has to do the work to unmarshal the msg because it knows
    // the specific type to use whereas the caller does not.
    Invoke(ctx context.Context, msg *anypb.Any) Completer
}
```

<a name="Method"></a>
## type Method

Method is a special type of future that is used frequently in parigot because all the methods of a service, and the methods of clients that use that same service, must return this type. It has the special behavior that when CompleteMethod is called on this Method, the error value is compared to zero and this determines if the Success \(error value is 0\) or Failure \(error is not 0\) handler function is called.

It is thus impossible to have a Method that can behave in a failed way \(call to Failure\) based on the return value being 0. In this case, use a Base\[int32\], as parigot does.

```go
type Method[T proto.Message, U ErrorType] struct {
    // contains filtered or unexported fields
}
```

<a name="NewMethod"></a>
### func NewMethod

```go
func NewMethod[T proto.Message, U ErrorType](resolve func(T), reject func(U)) *Method[T, U]
```

NewMethod return as method future with two types given. The T type \(first\) must be a proto.Message and typically is a Response object from a previous call to the Method. The error value, U, is typically a named enum that is used for error signaling by the method called.

<a name="Method[T, U].Cancel"></a>
### func \(\*Method\[T, U\]\) Cancel

```go
func (m *Method[T, U]) Cancel()
```

Cancel causes a future to be marked completed and also to remove any and all possible calls to a Sucess\(\) or Failure\(\) function later. This enforces that a Cancel\(\) is permanent, even if the future is "completed" later. Calling Cancel\(\) on an already completed future will be ignored.

<a name="Method[T, U].CompleteMethod"></a>
### func \(\*Method\[T, U\]\) CompleteMethod

```go
func (f *Method[T, U]) CompleteMethod(ctx context.Context, result T, resultErr U)
```

CompleteMethod is called to indicate that the outcome, or value, of the future is now known. This method is typically called by the infrastructure of Parigot, but it can be useful to call this method directly in tests. Calling this method on completed Method future will be ignored.

<a name="Method[T, U].Completed"></a>
### func \(\*Method\[T, U\]\) Completed

```go
func (f *Method[T, U]) Completed() bool
```

Completed returns true if this method has already completed.

<a name="Method[T, U].Failure"></a>
### func \(\*Method\[T, U\]\) Failure

```go
func (f *Method[T, U]) Failure(fn func(U))
```

Failure provides a function to be called if the Method completion supplies a non zero error value. Calling failure on a completed Method that had an error causes the given function to run immediately.

<a name="Method[T, U].String"></a>
### func \(\*Method\[T, U\]\) String

```go
func (f *Method[T, U]) String() string
```

String\(\) returns a human\-friendly version of this Method future. It shows it is resolved and if so, if the completion was an error.

<a name="Method[T, U].Success"></a>
### func \(\*Method\[T, U\]\) Success

```go
func (f *Method[T, U]) Success(fn func(T))
```

Success provides a function to be called if the Method returns a success. Calling Success\(\) on an already completed method causes the code supplied in the success method to be run immediately if the future was resolved successfully.

<a name="Method[T, U].ValueErr"></a>
### func \(\*Method\[T, U\]\) ValueErr

```go
func (f *Method[T, U]) ValueErr() U
```

ValueErr may not do what you expect: This function does not force the world to stop and wait for the Error in question to be received. It can only be trusted when the function Completed\(\) returns true and the function WasSuccess\(\) returns false. It returns the value of the error on a completed Method.

<a name="Method[T, U].ValueResponse"></a>
### func \(\*Method\[T, U\]\) ValueResponse

```go
func (f *Method[T, U]) ValueResponse() T
```

ValueResponse may not do what you expect: This function does not force the world to stop and wait for the Response in question to be received. It can only be trusted when the function Completed\(\) returns true and the function WasSuccess\(\) returns true. This function returns the value of a response \(type T\) on a completed method

<a name="Method[T, U].WaitingId"></a>
### func \(\*Method\[T, U\]\) WaitingId

```go
func (m *Method[T, U]) WaitingId() string
```

WaitingId is useful only to the go client side library. The WaitingId is a repurposing of the CallId to create a key value, a string, for use in a map, since Method\[T,U\] is not a valid key type in go.

<a name="Method[T, U].WasSuccess"></a>
### func \(\*Method\[T, U\]\) WasSuccess

```go
func (f *Method[T, U]) WasSuccess() bool
```

WasSuccess returns true if the Method is completed and finished as a sucess. Before a Method is completed, it returns false.

# apishared

```go
import "github.com/iansmith/parigot/api/shared"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)


## Constants

<a name="EntryPointSymbol"></a>EntryPointSymbol is what should be used to start up a ready instance. Note that we are turning off the instantiation's normal call to start so that we can control the startup and its entry point.

```go
const EntryPointSymbol = "_start"
```

<a name="ExpectedStackDumpSize"></a>ExpectedStackDumpSize is used to allocate space so that stack trace can be placed in it, then read back line by line.

```go
const ExpectedStackDumpSize = 4096 * 2
```

<a name="FileServiceMaxBufSize"></a>

```go
const FileServiceMaxBufSize = 2048
```

<a name="FileServiceMaxPathPart"></a>

```go
const FileServiceMaxPathPart = 20
```

<a name="FileServicePathPrefix"></a>

```go
const FileServicePathPrefix = "/parigot/app/"
```

<a name="GuestReceiveBufferSize"></a>GuestReceiveBufferSize is the maximum amount data that the guest expects to read in a response back from the server. Usually the send side is known apriori.

```go
const GuestReceiveBufferSize = WasmPageSize
```

<a name="WasmPageSize"></a>WasmPageSize is the size of a memory page in wasm. I believe this is dictated by the spec.

```go
const WasmPageSize = 4096
```

## Variables

<a name="ControlledExit"></a>this is the value used for a panic that is intended to be a controlled exit

```go
var ControlledExit = "controlled exit via panic:"
```

<a name="ExitMethod"></a>all calls to exit use the same Id

```go
var ExitMethod = id.MethodId(id.NewIdTyped[id.DefMethod](^uint64(0), 0xfffffffffffffff1))
```

<a name="FunctionTimeoutInMillis"></a>The amount of time we will wait for a function call to be completed.

```go
var FunctionTimeoutInMillis = int64(3000)
```

<a name="KoopmanTable"></a>KoopmanTable is the \`crc32.Koopman\` data in a table ready to use for CRC32 computations.

```go
var KoopmanTable = crc32.MakeTable(crc32.Koopman)
```

<a name="LaunchMethod"></a>all calls to launch use the same Id

```go
var LaunchMethod = id.MethodId(id.NewIdTyped[id.DefMethod](^uint64(0), 0xfffffffffffffff0))
```

<a name="MagicStringOfBytes"></a>In parigot the 8 byte magic value, when needed, is the date of the french and us revolutions, in hex.

```go
var MagicStringOfBytes = uint64(0x1789071417760704)
```

<a name="ReadBufferSize"></a>ReadBuffer is the maximum amount of data you can expect to receive in single read call with files or the network.

```go
var ReadBufferSize = 8192
```

<a name="WasmIs32Bit"></a>WasmIs32Bit is true on a 32 bit wasm implementation

```go
var WasmIs32Bit bool // init function
```

<a name="WasmWidth"></a>WasmWith is the size of a uintptr for the wasm virtual machine.

```go
var WasmWidth = int32(unsafe.Sizeof(uintptr(0))) // in bytes
```

# id

```go
import "github.com/iansmith/parigot/api/shared/id"
```

## Index

- [type CallId](<#CallId>)
  - [func CallIdEmptyValue\(\) CallId](<#CallIdEmptyValue>)
  - [func CallIdFromPair\(high, low uint64\) CallId](<#CallIdFromPair>)
  - [func CallIdZeroValue\(\) CallId](<#CallIdZeroValue>)
  - [func NewCallId\(\) CallId](<#NewCallId>)
  - [func UnmarshalCallId\(b \*protosupport.IdRaw\) CallId](<#UnmarshalCallId>)
  - [func \(f CallId\) Equal\(other CallId\) bool](<#CallId.Equal>)
  - [func \(f CallId\) High\(\) uint64](<#CallId.High>)
  - [func \(f CallId\) IsEmptyValue\(\) bool](<#CallId.IsEmptyValue>)
  - [func \(f CallId\) IsZeroOrEmptyValue\(\) bool](<#CallId.IsZeroOrEmptyValue>)
  - [func \(f CallId\) IsZeroValue\(\) bool](<#CallId.IsZeroValue>)
  - [func \(f CallId\) Low\(\) uint64](<#CallId.Low>)
  - [func \(f CallId\) Marshal\(\) \*protosupport.IdRaw](<#CallId.Marshal>)
  - [func \(f CallId\) Short\(\) string](<#CallId.Short>)
  - [func \(f CallId\) String\(\) string](<#CallId.String>)
- [type DefCall](<#DefCall>)
  - [func \(f DefCall\) Letter\(\) byte](<#DefCall.Letter>)
  - [func \(f DefCall\) ShortString\(\) string](<#DefCall.ShortString>)
- [type DefHost](<#DefHost>)
  - [func \(f DefHost\) Letter\(\) byte](<#DefHost.Letter>)
  - [func \(f DefHost\) ShortString\(\) string](<#DefHost.ShortString>)
- [type DefMethod](<#DefMethod>)
  - [func \(f DefMethod\) Letter\(\) byte](<#DefMethod.Letter>)
  - [func \(f DefMethod\) ShortString\(\) string](<#DefMethod.ShortString>)
- [type DefService](<#DefService>)
  - [func \(f DefService\) Letter\(\) byte](<#DefService.Letter>)
  - [func \(f DefService\) ShortString\(\) string](<#DefService.ShortString>)
- [type HostId](<#HostId>)
  - [func HostIdEmptyValue\(\) HostId](<#HostIdEmptyValue>)
  - [func HostIdFromPair\(high, low uint64\) HostId](<#HostIdFromPair>)
  - [func HostIdZeroValue\(\) HostId](<#HostIdZeroValue>)
  - [func NewHostId\(\) HostId](<#NewHostId>)
  - [func UnmarshalHostId\(b \*protosupport.IdRaw\) HostId](<#UnmarshalHostId>)
  - [func \(f HostId\) Equal\(other HostId\) bool](<#HostId.Equal>)
  - [func \(f HostId\) High\(\) uint64](<#HostId.High>)
  - [func \(f HostId\) IsEmptyValue\(\) bool](<#HostId.IsEmptyValue>)
  - [func \(f HostId\) IsZeroOrEmptyValue\(\) bool](<#HostId.IsZeroOrEmptyValue>)
  - [func \(f HostId\) IsZeroValue\(\) bool](<#HostId.IsZeroValue>)
  - [func \(f HostId\) Low\(\) uint64](<#HostId.Low>)
  - [func \(f HostId\) Marshal\(\) \*protosupport.IdRaw](<#HostId.Marshal>)
  - [func \(f HostId\) Short\(\) string](<#HostId.Short>)
  - [func \(f HostId\) String\(\) string](<#HostId.String>)
- [type IdRoot](<#IdRoot>)
  - [func NewIdRoot\[T NameInfo\]\(\) IdRoot\[T\]](<#NewIdRoot>)
  - [func NewIdTyped\[T NameInfo\]\(h, l uint64\) IdRoot\[T\]](<#NewIdTyped>)
  - [func ZeroValue\[T NameInfo\]\(\) IdRoot\[T\]](<#ZeroValue>)
  - [func \(i IdRoot\[T\]\) Equal\(other IdRoot\[T\]\) bool](<#IdRoot[T].Equal>)
  - [func \(i IdRoot\[T\]\) High\(\) uint64](<#IdRoot[T].High>)
  - [func \(i IdRoot\[T\]\) IsEmptyValue\(\) bool](<#IdRoot[T].IsEmptyValue>)
  - [func \(i IdRoot\[T\]\) IsZeroOrEmptyValue\(\) bool](<#IdRoot[T].IsZeroOrEmptyValue>)
  - [func \(i IdRoot\[T\]\) IsZeroValue\(\) bool](<#IdRoot[T].IsZeroValue>)
  - [func \(i IdRoot\[T\]\) Low\(\) uint64](<#IdRoot[T].Low>)
  - [func \(i IdRoot\[T\]\) Short\(\) string](<#IdRoot[T].Short>)
  - [func \(i IdRoot\[T\]\) String\(\) string](<#IdRoot[T].String>)
  - [func \(i IdRoot\[V\]\) WriteGuestLe\(mem api.Memory, offset uint32\) bool](<#IdRoot[V].WriteGuestLe>)
- [type MethodId](<#MethodId>)
  - [func MethodIdEmptyValue\(\) MethodId](<#MethodIdEmptyValue>)
  - [func MethodIdFromPair\(high, low uint64\) MethodId](<#MethodIdFromPair>)
  - [func MethodIdZeroValue\(\) MethodId](<#MethodIdZeroValue>)
  - [func NewMethodId\(\) MethodId](<#NewMethodId>)
  - [func UnmarshalMethodId\(b \*protosupport.IdRaw\) MethodId](<#UnmarshalMethodId>)
  - [func \(f MethodId\) Equal\(other MethodId\) bool](<#MethodId.Equal>)
  - [func \(f MethodId\) High\(\) uint64](<#MethodId.High>)
  - [func \(f MethodId\) IsEmptyValue\(\) bool](<#MethodId.IsEmptyValue>)
  - [func \(f MethodId\) IsZeroOrEmptyValue\(\) bool](<#MethodId.IsZeroOrEmptyValue>)
  - [func \(f MethodId\) IsZeroValue\(\) bool](<#MethodId.IsZeroValue>)
  - [func \(f MethodId\) Low\(\) uint64](<#MethodId.Low>)
  - [func \(f MethodId\) Marshal\(\) \*protosupport.IdRaw](<#MethodId.Marshal>)
  - [func \(f MethodId\) Short\(\) string](<#MethodId.Short>)
  - [func \(f MethodId\) String\(\) string](<#MethodId.String>)
- [type NameInfo](<#NameInfo>)
- [type ServiceId](<#ServiceId>)
  - [func NewServiceId\(\) ServiceId](<#NewServiceId>)
  - [func ServiceIdEmptyValue\(\) ServiceId](<#ServiceIdEmptyValue>)
  - [func ServiceIdFromPair\(high, low uint64\) ServiceId](<#ServiceIdFromPair>)
  - [func ServiceIdZeroValue\(\) ServiceId](<#ServiceIdZeroValue>)
  - [func UnmarshalServiceId\(b \*protosupport.IdRaw\) ServiceId](<#UnmarshalServiceId>)
  - [func \(f ServiceId\) Equal\(other ServiceId\) bool](<#ServiceId.Equal>)
  - [func \(f ServiceId\) High\(\) uint64](<#ServiceId.High>)
  - [func \(f ServiceId\) IsEmptyValue\(\) bool](<#ServiceId.IsEmptyValue>)
  - [func \(f ServiceId\) IsZeroOrEmptyValue\(\) bool](<#ServiceId.IsZeroOrEmptyValue>)
  - [func \(f ServiceId\) IsZeroValue\(\) bool](<#ServiceId.IsZeroValue>)
  - [func \(f ServiceId\) Low\(\) uint64](<#ServiceId.Low>)
  - [func \(f ServiceId\) Marshal\(\) \*protosupport.IdRaw](<#ServiceId.Marshal>)
  - [func \(f ServiceId\) Short\(\) string](<#ServiceId.Short>)
  - [func \(f ServiceId\) String\(\) string](<#ServiceId.String>)


<a name="CallId"></a>
## type CallId



```go
type CallId IdRoot[DefCall]
```

<a name="CallIdEmptyValue"></a>
### func CallIdEmptyValue

```go
func CallIdEmptyValue() CallId
```



<a name="CallIdFromPair"></a>
### func CallIdFromPair

```go
func CallIdFromPair(high, low uint64) CallId
```

FromPair is probably not something you want to use unless you are pulling values from external storage or files. If you pulling values from the network, use the Marshal\(\) ad Unmarshal\(\) functions to work with Ids. Absolutely no checking is done on the values provided, so much caution is advised.

<a name="CallIdZeroValue"></a>
### func CallIdZeroValue

```go
func CallIdZeroValue() CallId
```



<a name="NewCallId"></a>
### func NewCallId

```go
func NewCallId() CallId
```



<a name="UnmarshalCallId"></a>
### func UnmarshalCallId

```go
func UnmarshalCallId(b *protosupport.IdRaw) CallId
```



<a name="CallId.Equal"></a>
### func \(CallId\) Equal

```go
func (f CallId) Equal(other CallId) bool
```



<a name="CallId.High"></a>
### func \(CallId\) High

```go
func (f CallId) High() uint64
```



<a name="CallId.IsEmptyValue"></a>
### func \(CallId\) IsEmptyValue

```go
func (f CallId) IsEmptyValue() bool
```



<a name="CallId.IsZeroOrEmptyValue"></a>
### func \(CallId\) IsZeroOrEmptyValue

```go
func (f CallId) IsZeroOrEmptyValue() bool
```



<a name="CallId.IsZeroValue"></a>
### func \(CallId\) IsZeroValue

```go
func (f CallId) IsZeroValue() bool
```



<a name="CallId.Low"></a>
### func \(CallId\) Low

```go
func (f CallId) Low() uint64
```



<a name="CallId.Marshal"></a>
### func \(CallId\) Marshal

```go
func (f CallId) Marshal() *protosupport.IdRaw
```



<a name="CallId.Short"></a>
### func \(CallId\) Short

```go
func (f CallId) Short() string
```



<a name="CallId.String"></a>
### func \(CallId\) String

```go
func (f CallId) String() string
```



<a name="DefCall"></a>
## type DefCall



```go
type DefCall struct{}
```

<a name="DefCall.Letter"></a>
### func \(DefCall\) Letter

```go
func (f DefCall) Letter() byte
```



<a name="DefCall.ShortString"></a>
### func \(DefCall\) ShortString

```go
func (f DefCall) ShortString() string
```



<a name="DefHost"></a>
## type DefHost



```go
type DefHost struct{}
```

<a name="DefHost.Letter"></a>
### func \(DefHost\) Letter

```go
func (f DefHost) Letter() byte
```



<a name="DefHost.ShortString"></a>
### func \(DefHost\) ShortString

```go
func (f DefHost) ShortString() string
```



<a name="DefMethod"></a>
## type DefMethod



```go
type DefMethod struct{}
```

<a name="DefMethod.Letter"></a>
### func \(DefMethod\) Letter

```go
func (f DefMethod) Letter() byte
```



<a name="DefMethod.ShortString"></a>
### func \(DefMethod\) ShortString

```go
func (f DefMethod) ShortString() string
```



<a name="DefService"></a>
## type DefService



```go
type DefService struct{}
```

<a name="DefService.Letter"></a>
### func \(DefService\) Letter

```go
func (f DefService) Letter() byte
```



<a name="DefService.ShortString"></a>
### func \(DefService\) ShortString

```go
func (f DefService) ShortString() string
```



<a name="HostId"></a>
## type HostId



```go
type HostId IdRoot[DefHost]
```

<a name="HostIdEmptyValue"></a>
### func HostIdEmptyValue

```go
func HostIdEmptyValue() HostId
```



<a name="HostIdFromPair"></a>
### func HostIdFromPair

```go
func HostIdFromPair(high, low uint64) HostId
```

FromPair is probably not something you want to use unless you are pulling values from external storage or files. If you pulling values from the network, use the Marshal\(\) ad Unmarshal\(\) functions to work with Ids. Absolutely no checking is done on the values provided, so much caution is advised.

<a name="HostIdZeroValue"></a>
### func HostIdZeroValue

```go
func HostIdZeroValue() HostId
```



<a name="NewHostId"></a>
### func NewHostId

```go
func NewHostId() HostId
```



<a name="UnmarshalHostId"></a>
### func UnmarshalHostId

```go
func UnmarshalHostId(b *protosupport.IdRaw) HostId
```



<a name="HostId.Equal"></a>
### func \(HostId\) Equal

```go
func (f HostId) Equal(other HostId) bool
```



<a name="HostId.High"></a>
### func \(HostId\) High

```go
func (f HostId) High() uint64
```



<a name="HostId.IsEmptyValue"></a>
### func \(HostId\) IsEmptyValue

```go
func (f HostId) IsEmptyValue() bool
```



<a name="HostId.IsZeroOrEmptyValue"></a>
### func \(HostId\) IsZeroOrEmptyValue

```go
func (f HostId) IsZeroOrEmptyValue() bool
```



<a name="HostId.IsZeroValue"></a>
### func \(HostId\) IsZeroValue

```go
func (f HostId) IsZeroValue() bool
```



<a name="HostId.Low"></a>
### func \(HostId\) Low

```go
func (f HostId) Low() uint64
```



<a name="HostId.Marshal"></a>
### func \(HostId\) Marshal

```go
func (f HostId) Marshal() *protosupport.IdRaw
```



<a name="HostId.Short"></a>
### func \(HostId\) Short

```go
func (f HostId) Short() string
```



<a name="HostId.String"></a>
### func \(HostId\) String

```go
func (f HostId) String() string
```



<a name="IdRoot"></a>
## type IdRoot

IdRoot\[T\] is used to indicate an id in parigot. This type is usually "covered up" by generated code that will given it a name lile FileId or QueueId so these types cannot be compared for equality, assigned to each other, and similar, despite being the same underlying type.

```go
type IdRoot[T NameInfo] struct {
    // contains filtered or unexported fields
}
```

<a name="NewIdRoot"></a>
### func NewIdRoot

```go
func NewIdRoot[T NameInfo]() IdRoot[T]
```

NewIdRoot\[T\] returns a new Id of type\[T\] fille with 120 bits of randomness.

<a name="NewIdTyped"></a>
### func NewIdTyped

```go
func NewIdTyped[T NameInfo](h, l uint64) IdRoot[T]
```

NewIdType is dangerous in that it performs no checks about the validity of the data provided. Its use is discouraged. It will obey the values provided by the T type parameter regarding the high order byte, even if this value is provided in h.

<a name="ZeroValue"></a>
### func ZeroValue

```go
func ZeroValue[T NameInfo]() IdRoot[T]
```

ZeroValue is a special value of an id. Thes should be returned when an Id should not be used, such as when an error is also returned from a function. Note that the zero value is not the same as the empty value.

<a name="IdRoot[T].Equal"></a>
### func \(IdRoot\[T\]\) Equal

```go
func (i IdRoot[T]) Equal(other IdRoot[T]) bool
```

Equal will compare two ids for equality. At this level it can compare \_any\_ two ids, but most users will be using generated code that disallows comparisons between id types. Note that the empty value and the zero value are not equal to anything, including each other.

<a name="IdRoot[T].High"></a>
### func \(IdRoot\[T\]\) High

```go
func (i IdRoot[T]) High() uint64
```

Use of High\(\) is not recommended for user code. It returns the high 8 bytes of the 128bit id.

<a name="IdRoot[T].IsEmptyValue"></a>
### func \(IdRoot\[T\]\) IsEmptyValue

```go
func (i IdRoot[T]) IsEmptyValue() bool
```

IsEmptyValue tells you if the given id is actually just full of zeros in the 15 data bytes. This almost means that the caller gave you a bad id, since the chance of all 15 data bytes being zero is very low, and vastly lower than somebody forgetting to initialize a value.

<a name="IdRoot[T].IsZeroOrEmptyValue"></a>
### func \(IdRoot\[T\]\) IsZeroOrEmptyValue

```go
func (i IdRoot[T]) IsZeroOrEmptyValue() bool
```



<a name="IdRoot[T].IsZeroValue"></a>
### func \(IdRoot\[T\]\) IsZeroValue

```go
func (i IdRoot[T]) IsZeroValue() bool
```

IsZeroValue checks an id value to see if it is the bit pattern of the zero value.

<a name="IdRoot[T].Low"></a>
### func \(IdRoot\[T\]\) Low

```go
func (i IdRoot[T]) Low() uint64
```

Use of Low\(\) is not recommended for user code. It returns the low 8 bytes of the 128bit id.

<a name="IdRoot[T].Short"></a>
### func \(IdRoot\[T\]\) Short

```go
func (i IdRoot[T]) Short() string
```

Short returns a short string representing this value. Strings returned represent the low order 16 bits of the this Id. However, for debugging, this amount data is enough to uniquely identify a particular id. If you want to see the entire 120 bits, then use String\(\).

<a name="IdRoot[T].String"></a>
### func \(IdRoot\[T\]\) String

```go
func (i IdRoot[T]) String() string
```

String\(\) returns a string that contains the short string name of this id \(like "file" or "queue"\) and then 5 groups of numbers. From left to right these are bytes\[4\-6\] of the high part, bytes\[0\-3\] of the high part, bytes \[4\-7\] of the low part, bytes\[2\-3\] of the low part, and then low order two bytes of the low part. The low part is printed this way so the last section of the string match the portion of the id printed by Short\(\)

<a name="IdRoot[V].WriteGuestLe"></a>
### func \(IdRoot\[V\]\) WriteGuestLe

```go
func (i IdRoot[V]) WriteGuestLe(mem api.Memory, offset uint32) bool
```

WriteGuestLe will write an id into the guest memory when running on the host. This always writes the data in Little Endian format.

<a name="MethodId"></a>
## type MethodId



```go
type MethodId IdRoot[DefMethod]
```

<a name="MethodIdEmptyValue"></a>
### func MethodIdEmptyValue

```go
func MethodIdEmptyValue() MethodId
```



<a name="MethodIdFromPair"></a>
### func MethodIdFromPair

```go
func MethodIdFromPair(high, low uint64) MethodId
```

FromPair is probably not something you want to use unless you are pulling values from external storage or files. If you pulling values from the network, use the Marshal\(\) ad Unmarshal\(\) functions to work with Ids. Absolutely no checking is done on the values provided, so much caution is advised.

<a name="MethodIdZeroValue"></a>
### func MethodIdZeroValue

```go
func MethodIdZeroValue() MethodId
```



<a name="NewMethodId"></a>
### func NewMethodId

```go
func NewMethodId() MethodId
```



<a name="UnmarshalMethodId"></a>
### func UnmarshalMethodId

```go
func UnmarshalMethodId(b *protosupport.IdRaw) MethodId
```



<a name="MethodId.Equal"></a>
### func \(MethodId\) Equal

```go
func (f MethodId) Equal(other MethodId) bool
```



<a name="MethodId.High"></a>
### func \(MethodId\) High

```go
func (f MethodId) High() uint64
```



<a name="MethodId.IsEmptyValue"></a>
### func \(MethodId\) IsEmptyValue

```go
func (f MethodId) IsEmptyValue() bool
```



<a name="MethodId.IsZeroOrEmptyValue"></a>
### func \(MethodId\) IsZeroOrEmptyValue

```go
func (f MethodId) IsZeroOrEmptyValue() bool
```



<a name="MethodId.IsZeroValue"></a>
### func \(MethodId\) IsZeroValue

```go
func (f MethodId) IsZeroValue() bool
```



<a name="MethodId.Low"></a>
### func \(MethodId\) Low

```go
func (f MethodId) Low() uint64
```



<a name="MethodId.Marshal"></a>
### func \(MethodId\) Marshal

```go
func (f MethodId) Marshal() *protosupport.IdRaw
```



<a name="MethodId.Short"></a>
### func \(MethodId\) Short

```go
func (f MethodId) Short() string
```



<a name="MethodId.String"></a>
### func \(MethodId\) String

```go
func (f MethodId) String() string
```



<a name="NameInfo"></a>
## type NameInfo



```go
type NameInfo interface {
    ShortString() string
    Letter() byte
}
```

<a name="ServiceId"></a>
## type ServiceId



```go
type ServiceId IdRoot[DefService]
```

<a name="NewServiceId"></a>
### func NewServiceId

```go
func NewServiceId() ServiceId
```



<a name="ServiceIdEmptyValue"></a>
### func ServiceIdEmptyValue

```go
func ServiceIdEmptyValue() ServiceId
```



<a name="ServiceIdFromPair"></a>
### func ServiceIdFromPair

```go
func ServiceIdFromPair(high, low uint64) ServiceId
```

FromPair is probably not something you want to use unless you are pulling values from external storage or files. If you pulling values from the network, use the Marshal\(\) ad Unmarshal\(\) functions to work with Ids. Absolutely no checking is done on the values provided, so much caution is advised.

<a name="ServiceIdZeroValue"></a>
### func ServiceIdZeroValue

```go
func ServiceIdZeroValue() ServiceId
```



<a name="UnmarshalServiceId"></a>
### func UnmarshalServiceId

```go
func UnmarshalServiceId(b *protosupport.IdRaw) ServiceId
```



<a name="ServiceId.Equal"></a>
### func \(ServiceId\) Equal

```go
func (f ServiceId) Equal(other ServiceId) bool
```



<a name="ServiceId.High"></a>
### func \(ServiceId\) High

```go
func (f ServiceId) High() uint64
```



<a name="ServiceId.IsEmptyValue"></a>
### func \(ServiceId\) IsEmptyValue

```go
func (f ServiceId) IsEmptyValue() bool
```



<a name="ServiceId.IsZeroOrEmptyValue"></a>
### func \(ServiceId\) IsZeroOrEmptyValue

```go
func (f ServiceId) IsZeroOrEmptyValue() bool
```



<a name="ServiceId.IsZeroValue"></a>
### func \(ServiceId\) IsZeroValue

```go
func (f ServiceId) IsZeroValue() bool
```



<a name="ServiceId.Low"></a>
### func \(ServiceId\) Low

```go
func (f ServiceId) Low() uint64
```



<a name="ServiceId.Marshal"></a>
### func \(ServiceId\) Marshal

```go
func (f ServiceId) Marshal() *protosupport.IdRaw
```



<a name="ServiceId.Short"></a>
### func \(ServiceId\) Short

```go
func (f ServiceId) Short() string
```



<a name="ServiceId.String"></a>
### func \(ServiceId\) String

```go
func (f ServiceId) String() string
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
