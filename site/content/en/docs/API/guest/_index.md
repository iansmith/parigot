---
title: Guest-side API
description: Golang guests interacting with parigot and built-in services
date: 2023-07-01
weight: 1
---
{{% pageinfo %}} 

All of this information applies the current version of parigot, `atlanta-0.3.0`.
Versions up to `some_city-1.0.0` carry no backward compatibility guarantees,
promises or anything else to protect you from change..  One may assume that
there will be significant changes in any and all publicly facing APIs and
internal code as well.  

{{% /pageinfo %}}

{{% pageinfo %}} 

We expect to have more "guest side" libraries for other languages soon.  Notable
priorities are python and languages that compile to the Java VM. 

{{% /pageinfo %}}

All of these libraries are available to golang developers who are build a 
guest application on top of parigot.  It is expected that developers using
these libraries will be using at least [go1.23](https://go.dev/dl/) and with
the go build environment variables `GOOS=wasip1 GOARCH=wasm` or equivalent
command line flags.
<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# background

```go
import "github.com/iansmith/parigot/api/guest/background"
```

## Index

- [type Background](<#Background>)


<a name="Background"></a>
## type Background



```go
type Background interface {
    Background(ctx context.Context)
}
```

# lib

```go
import "github.com/iansmith/parigot/lib/go"
```

## Index

- [func AddServerReturn\(fut future.Method\[proto.Message, int32\]\)](<#AddServerReturn>)
- [func CompleteCall\(ctx context.Context, cid id.CallId, result \*anypb.Any, resultErr int32\) syscall.KernelErr](<#CompleteCall>)
- [func CurrentHostId\(\) id.HostId](<#CurrentHostId>)
- [func ExpireMethod\(ctx context.Context\)](<#ExpireMethod>)
- [func Export1\(pkg, name string\) \(\*syscall.ExportResponse, syscall.KernelErr\)](<#Export1>)
- [func FlagParseCreateEnv\(\)](<#FlagParseCreateEnv>)
- [func Getenv\(envvar string\) string](<#Getenv>)
- [func LookupEnv\(envvar string\) \(string, bool\)](<#LookupEnv>)
- [func MatchCompleter\(cid id.CallId, comp future.Completer\)](<#MatchCompleter>)
- [func MustRegisterClient\(ctx context.Context\) id.ServiceId](<#MustRegisterClient>)
- [func Require1\(pkg, name string, source id.ServiceId\) \(\*syscall.RequireResponse, syscall.KernelErr\)](<#Require1>)
- [type Backgrounder](<#Backgrounder>)
- [type FuncAnyIO](<#FuncAnyIO>)
- [type MustRequireFunc](<#MustRequireFunc>)
- [type ServiceMethodMap](<#ServiceMethodMap>)
  - [func NewServiceMethodMap\(\) \*ServiceMethodMap](<#NewServiceMethodMap>)
  - [func \(s \*ServiceMethodMap\) AddServiceMethod\(sid id.ServiceId, mid id.MethodId, serviceName, methodName string, fn future.Invoker\)](<#ServiceMethodMap.AddServiceMethod>)
  - [func \(s \*ServiceMethodMap\) Call\(\) \[\]\*syscall.ServiceMethodCall](<#ServiceMethodMap.Call>)
  - [func \(s \*ServiceMethodMap\) Disable\(sid id.ServiceId, mid id.MethodId\)](<#ServiceMethodMap.Disable>)
  - [func \(s \*ServiceMethodMap\) Enable\(sid id.ServiceId, mid id.MethodId\)](<#ServiceMethodMap.Enable>)
  - [func \(s \*ServiceMethodMap\) Func\(sid id.ServiceId, mid id.MethodId\) future.Invoker](<#ServiceMethodMap.Func>)
  - [func \(s \*ServiceMethodMap\) Len\(\) int](<#ServiceMethodMap.Len>)
  - [func \(s \*ServiceMethodMap\) MethodIdToName\(mid id.MethodId\) string](<#ServiceMethodMap.MethodIdToName>)
  - [func \(s \*ServiceMethodMap\) MethodNameToId\(sid id.ServiceId, methodName string\) id.MethodId](<#ServiceMethodMap.MethodNameToId>)


<a name="AddServerReturn"></a>
## func AddServerReturn

```go
func AddServerReturn(fut future.Method[proto.Message, int32])
```

AddServerReturn is called to register a server side function result as a future.

<a name="CompleteCall"></a>
## func CompleteCall

```go
func CompleteCall(ctx context.Context, cid id.CallId, result *anypb.Any, resultErr int32) syscall.KernelErr
```

CompleteCall is called from the CallOne handler to cause a prior dispatch call to be completed. The matching is done based on the cid.

<a name="CurrentHostId"></a>
## func CurrentHostId

```go
func CurrentHostId() id.HostId
```



<a name="ExpireMethod"></a>
## func ExpireMethod

```go
func ExpireMethod(ctx context.Context)
```

ExpireMethod\(\) checks the internal list of guest side futures that have no call id associated with them. These futures come about when a implementation of a server function returns a future that is not completed. This future likely exists because the implementation of the server function called another service and the result of the server function thus cannot be calculated immediately. When the call is completed, the Success or Failure functions will be called on the original future. This function exists to maintain a list so that we can expire and cancel futures that have waiting longer than the timeout time.

<a name="Export1"></a>
## func Export1

```go
func Export1(pkg, name string) (*syscall.ExportResponse, syscall.KernelErr)
```

Export1 is a thin wrapper over syscall.Export so it's easy to export things by their name. This is used by the code generator primarily.

<a name="FlagParseCreateEnv"></a>
## func FlagParseCreateEnv

```go
func FlagParseCreateEnv()
```



<a name="Getenv"></a>
## func Getenv

```go
func Getenv(envvar string) string
```

This is a workalike for os.Getenv\(\)

<a name="LookupEnv"></a>
## func LookupEnv

```go
func LookupEnv(envvar string) (string, bool)
```

This is a workalike for os.LookupEnv\(\). It can be used to differentiate an empty, but set, environment variable from the an enviroment variable that is simply not present.

<a name="MatchCompleter"></a>
## func MatchCompleter

```go
func MatchCompleter(cid id.CallId, comp future.Completer)
```

MatchCompleter is a utility for adding a new cid and completer to the tables used to look up the location where response values should be sent.

<a name="MustRegisterClient"></a>
## func MustRegisterClient

```go
func MustRegisterClient(ctx context.Context) id.ServiceId
```

MustRegisterClient should be used by the "main" function of a client program that is not service itself, in other words it is a client only. If you are a service, you should use the automagically generated code MustRegister\<BLAH\>\(\).

<a name="Require1"></a>
## func Require1

```go
func Require1(pkg, name string, source id.ServiceId) (*syscall.RequireResponse, syscall.KernelErr)
```

Require1 is a thin wrapper over syscall.Require so it's easy to require things by their name. This is used by the code generator primarily.

<a name="Backgrounder"></a>
## type Backgrounder

Backgrounder is an interface that can be implemented by types that want to get period background calls when the latest attempt to receive a call has timed out. Note that when the background is actually running \(in Background\) their are no attempts to retreive method calls on this service.

```go
type Backgrounder interface {
    Background(context.Context)
}
```

<a name="FuncAnyIO"></a>
## type FuncAnyIO

FuncAnyIO is the type of the guest\-side functions that implement the set and tear down of method implementations in a server. If a method fleazil is defined on a service, it will have FuncAnyIO wrapper that unmarshals input parameters and marshals the return value.

```go
type FuncAnyIO func(*anypb.Any) future.Method[*anypb.Any, int32]
```

<a name="MustRequireFunc"></a>
## type MustRequireFunc

MustRequireFunc is the type of the functions that are created by the code generator from protobuf definitions of the form MustRequireXXXX\(\). These are used in the function RunXXXX\(\) to indicate required services \(dependencies\).

```go
type MustRequireFunc func(context.Context, id.ServiceId)
```

<a name="ServiceMethodMap"></a>
## type ServiceMethodMap

ServiceMethodMap is the data structure that provides conversions between a service/method pair and their variants. A service or method can be converted to a string with their String\(\) method and this method can convert that string back to the appropriate service or method. The ServiceMethodMap can also convert between the human readable names of services and methods and their appropriate Ids. It contains a mapping from a service/method pair to a FuncAnyIO that is the guest\-side implementation of the method. Finally, it allows particular methods to be enabled and disabled so they will not be used when generating the list of pairs for a call to ReadOne\(\).

```go
type ServiceMethodMap struct {
    // contains filtered or unexported fields
}
```

<a name="NewServiceMethodMap"></a>
### func NewServiceMethodMap

```go
func NewServiceMethodMap() *ServiceMethodMap
```



<a name="ServiceMethodMap.AddServiceMethod"></a>
### func \(\*ServiceMethodMap\) AddServiceMethod

```go
func (s *ServiceMethodMap) AddServiceMethod(sid id.ServiceId, mid id.MethodId, serviceName, methodName string, fn future.Invoker)
```

AddServiceMethod is called when a new method has been bound. This method creates various data structures needed to be able to look up the service and method later, as well as find the appropriate FuncAnyIO associated with pair. Note that the funcAnyIO may be nil when the function is not available in this address space and any caller must use Dispatch\(\).

<a name="ServiceMethodMap.Call"></a>
### func \(\*ServiceMethodMap\) Call

```go
func (s *ServiceMethodMap) Call() []*syscall.ServiceMethodCall
```

Pair returns a list of Service/Method pairs suitable for use in a ReadOneRequest. Particular elements of the map can be omitted or included with Disable and Enable.

<a name="ServiceMethodMap.Disable"></a>
### func \(\*ServiceMethodMap\) Disable

```go
func (s *ServiceMethodMap) Disable(sid id.ServiceId, mid id.MethodId)
```

Disable "turns off" a service/method pair within this map. This pair will not appear in results of Pair\(\) until Enable is called for this pair. If the values of this pair of ids does not correspond to a real pair that is known to the service, this call is ignored. Disable can be useful in production situations where you want disable methods on an object that are only for testing.

<a name="ServiceMethodMap.Enable"></a>
### func \(\*ServiceMethodMap\) Enable

```go
func (s *ServiceMethodMap) Enable(sid id.ServiceId, mid id.MethodId)
```

Enable "turns on" a given service/method pair within the map. Thus the pair will be returned as part of the Pair\(\) result. If the pair of these ids is not found, this call is ignored. Enable can be useful in testing situations where you want enable methods on an object that are only for testing.

<a name="ServiceMethodMap.Func"></a>
### func \(\*ServiceMethodMap\) Func

```go
func (s *ServiceMethodMap) Func(sid id.ServiceId, mid id.MethodId) future.Invoker
```

Func returns the FuncAnyIO object associated with the sid and mid pair. If either sid or mid cannot be found, it returns nil.

<a name="ServiceMethodMap.Len"></a>
### func \(\*ServiceMethodMap\) Len

```go
func (s *ServiceMethodMap) Len() int
```

Len returns the number of known methods in this ServiceMethodMap

<a name="ServiceMethodMap.MethodIdToName"></a>
### func \(\*ServiceMethodMap\) MethodIdToName

```go
func (s *ServiceMethodMap) MethodIdToName(mid id.MethodId) string
```

MethodIdToName is used to find a method given a particular service id. This function returns "" if either the service or the method cannot be found. This does not require a service id because method ids are unique.

<a name="ServiceMethodMap.MethodNameToId"></a>
### func \(\*ServiceMethodMap\) MethodNameToId

```go
func (s *ServiceMethodMap) MethodNameToId(sid id.ServiceId, methodName string) id.MethodId
```

MethodNameToId is used to find a method by name, given a particular service id. This function returns the value MethodIdZeroValue if either the service or the method cannot be found.

# apishared

```go
import "github.com/iansmith/parigot/api/shared"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)


## Constants

<a name="EntryPointSymbol"></a>EntryPointSymbol is what should be used to start up a ready instance. Note that we are turning off the instantiation's normal call to start so that we can control the startup and its entry point.

```go
const EntryPointSymbol = "_start"
```

<a name="ExpectedStackDumpSize"></a>ExpectedStackDumpSize is used to allocate space so that stack trace can be placed in it, then read back line by line.

```go
const ExpectedStackDumpSize = 4096 * 2
```

<a name="GuestReceiveBufferSize"></a>GuestReceiveBufferSize is the maximum amount data that the guest expects to read in a response back from the server. Usually the send side is known apriori.

```go
const GuestReceiveBufferSize = WasmPageSize
```

<a name="WasmPageSize"></a>WasmPageSize is the size of a memory page in wasm. I believe this is dictated by the spec.

```go
const WasmPageSize = 4096
```

## Variables

<a name="FunctionTimeoutInMillis"></a>The amount of time we will wait for a function call to be completed.

```go
var FunctionTimeoutInMillis = int64(3000)
```

<a name="KoopmanTable"></a>KoopmanTable is the \`crc32.Koopman\` data in a table ready to use for CRC32 computations.

```go
var KoopmanTable = crc32.MakeTable(crc32.Koopman)
```

<a name="MagicStringOfBytes"></a>In parigot the 8 byte magic value, when needed, is the date of the french and us revolutions, in hex.

```go
var MagicStringOfBytes = uint64(0x1789071417760704)
```

<a name="ReadBufferSize"></a>ReadBuffer is the maximum amount of data you can expect to receive in single read call with files or the network.

```go
var ReadBufferSize = 8192
```

<a name="WasmIs32Bit"></a>WasmIs32Bit is true on a 32 bit wasm implementation

```go
var WasmIs32Bit bool // init function
```

<a name="WasmWidth"></a>WasmWith is the size of a uintptr for the wasm virtual machine.

```go
var WasmWidth = int32(unsafe.Sizeof(uintptr(0))) // in bytes
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
