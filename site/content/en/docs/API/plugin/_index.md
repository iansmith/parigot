---
title: Plugins (native servers)
description: utilities for building a golang service that uses native code
date: 2023-07-01
weight: 1
---
{{% pageinfo %}} 

All of this information applies the current version of parigot, `atlanta-0.3.0`.
Versions up to `some_city-1.0.0` carry no backward compatibility guarantees,
promises or anything else to protect you from change..  One may assume that
there will be significant changes in any and all publicly facing APIs and
internal code as well.  

{{% /pageinfo %}}

{{% pageinfo %}} 

This documentation sections also has documentation for some build-in parigot
services that are implemented via the plugin mechanism.  These are intended
to be used by future implementors as samples.

{{% /pageinfo %}}

Sometimes developers building services cannot implement their service, or the
entirety of their service, in pure guest code (WASM).  Since parigot guests
cannot see the true filesystem and cannot make unexpected network requests, a
common use of these types of services is cases where the service is a "wrapper"
or "bridge" to some existing network service such as Redis, a network
filesystem, or internal legacy system.  In these cases, a plugin must be built
to support the service.

Plugins are loaded into the __host__ to provide the "extra" function calls
not available to normal services.  Plugins need to be compiled using 
-buildmode=shared and the resulting file should be named `foo.so` for a 
linux shared object representing the native code for foo.

Parigot generates "bridge" or "glue" code for every service and every method of
every service to allow a service implementor to use a plugin if desired.  Obviously,
using purely guest code provides far better safety and isolation properties and
it is always preferred to the use of plugins. If a plugin crashes, it is likely
to bring down the host and thus all of the guest programs. 

{{% pageinfo %}} 

Plugin crashes are likely to bring down all guest programs as well as the host.
Plugins should be considered armed and dangerous.

{{% /pageinfo %}}


At the moment, the plugin API can only be used from golang.

The plugin support is not related to the ["normal" API](../guest) that is used for
building a service. parigot's generated code does some work to make the API
at the plugin level be similar to the normal API. In particular, a plugin function
like a normal service function implementation, receives a `FooRequest` for a
function called `Foo` and responds with a `FooResponse`.  However, the plugin
does not return a future, it is expected that the native code can produce its
result in a very short period of time and thus it is ok for the caller of the
plugin-based service to block.  

{{% pageinfo %}} 

Plugins should return from their functions "quickly".  Plugins do not return
futures and the caller of a function implemented in a plugin will block until
the plugin's implementation returns.  Quickly might considered to be a maximum
of 200ms.

{{% /pageinfo %}}




<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# plugin

```go
import "github.com/iansmith/parigot/api/plugin"
```

## Index

- [Variables](<#variables>)
- [func InvokeImplFromStack\[T proto.Message, U proto.Message\]\(ctx context.Context, name string, m api.Module, stack \[\]uint64, fn func\(context.Context, T, U\) int32, t T, u U\)](<#InvokeImplFromStack>)
- [func ManufactureHostContext\(ctx context.Context, funcName string\) context.Context](<#ManufactureHostContext>)
- [type ParigotInit](<#ParigotInit>)
  - [func LoadAndReturnInit\(ctx context.Context, pluginPath, pluginSymbol, \_ string\) \(ParigotInit, error\)](<#LoadAndReturnInit>)


## Variables

<a name="NoReturnedStruct"></a>

```go
var NoReturnedStruct = uint64(0)
```

<a name="InvokeImplFromStack"></a>
## func InvokeImplFromStack

```go
func InvokeImplFromStack[T proto.Message, U proto.Message](ctx context.Context, name string, m api.Module, stack []uint64, fn func(context.Context, T, U) int32, t T, u U)
```

InvokeImplFromStack is the primary interface between host code and the machinery to communicate with the guest. This function takes the parameters like an api.Module and a section of the stack provided by Wazero and then reads and writes an input and output protocol buffer to the guest memory. The name is provided here just for human error messages. This functions uses pullRequestFromStack and and pushResponseToStack to do the actual work of encoding and decoding the values to/from the guest memory.

<a name="ManufactureHostContext"></a>
## func ManufactureHostContext

```go
func ManufactureHostContext(ctx context.Context, funcName string) context.Context
```

ManufactureHostContext is a helper to return a context configured for the given function name and set the source to ServerGo.

<a name="ParigotInit"></a>
## type ParigotInit

ParigotInit is the interface that plugins must meet to be initialized. It is expected that they will use the supplied Engine in the call to Init to register Host functions.

```go
type ParigotInit interface {
    Init(ctx context.Context, e eng.Engine) bool
}
```

<a name="LoadAndReturnInit"></a>
### func LoadAndReturnInit

```go
func LoadAndReturnInit(ctx context.Context, pluginPath, pluginSymbol, _ string) (ParigotInit, error)
```

LoadAndReturnInit is a utility function for plugins that want the default implementation. This function accepts third string param \(name\) but ignores it.

# file

```go
import "github.com/iansmith/parigot/api/plugin/file"
```

## Index

- [type FilePlugin](<#FilePlugin>)
  - [func \(\*FilePlugin\) Init\(ctx context.Context, e eng.Engine\) bool](<#FilePlugin.Init>)
- [type FileStatus](<#FileStatus>)
  - [func \(fs FileStatus\) String\(\) string](<#FileStatus.String>)


<a name="FilePlugin"></a>
## type FilePlugin



```go
type FilePlugin struct{}
```

<a name="FilePlugin.Init"></a>
### func \(\*FilePlugin\) Init

```go
func (*FilePlugin) Init(ctx context.Context, e eng.Engine) bool
```



<a name="FileStatus"></a>
## type FileStatus

enum for file status

```go
type FileStatus int
```

<a name="Fs_Open"></a>

```go
const (
    Fs_Open FileStatus = iota
    Fs_Close
)
```

<a name="FileStatus.String"></a>
### func \(FileStatus\) String

```go
func (fs FileStatus) String() string
```



# queue

```go
import "github.com/iansmith/parigot/api/plugin/queue"
```

## Index

- [type CreateIdToKeyMappingParams](<#CreateIdToKeyMappingParams>)
- [type CreateMessageParams](<#CreateMessageParams>)
- [type DBTX](<#DBTX>)
- [type LocateRow](<#LocateRow>)
- [type MarkDoneParams](<#MarkDoneParams>)
- [type ParigotTestMessage](<#ParigotTestMessage>)
- [type ParigotTestQueue](<#ParigotTestQueue>)
- [type ParigotTestQueueIDToKey](<#ParigotTestQueueIDToKey>)
- [type Queries](<#Queries>)
  - [func New\(db DBTX\) \*Queries](<#New>)
  - [func \(q \*Queries\) CreateIdToKeyMapping\(ctx context.Context, arg CreateIdToKeyMappingParams\) \(ParigotTestQueueIDToKey, error\)](<#Queries.CreateIdToKeyMapping>)
  - [func \(q \*Queries\) CreateMessage\(ctx context.Context, arg CreateMessageParams\) \(ParigotTestMessage, error\)](<#Queries.CreateMessage>)
  - [func \(q \*Queries\) CreateQueue\(ctx context.Context, name string\) \(ParigotTestQueue, error\)](<#Queries.CreateQueue>)
  - [func \(q \*Queries\) DeleteQueue\(ctx context.Context, id int64\) error](<#Queries.DeleteQueue>)
  - [func \(q \*Queries\) GetQueue\(ctx context.Context, id int64\) \(ParigotTestQueue, error\)](<#Queries.GetQueue>)
  - [func \(q \*Queries\) Length\(ctx context.Context, queueKey sql.NullInt64\) \(int64, error\)](<#Queries.Length>)
  - [func \(q \*Queries\) Locate\(ctx context.Context, name string\) \(LocateRow, error\)](<#Queries.Locate>)
  - [func \(q \*Queries\) MarkDone\(ctx context.Context, arg MarkDoneParams\) error](<#Queries.MarkDone>)
  - [func \(q \*Queries\) RetrieveMessage\(ctx context.Context, arg RetrieveMessageParams\) \(\[\]ParigotTestMessage, error\)](<#Queries.RetrieveMessage>)
  - [func \(q \*Queries\) TestNameExists\(ctx context.Context, name string\) \(int64, error\)](<#Queries.TestNameExists>)
  - [func \(q \*Queries\) UpdateMessageRetrieved\(ctx context.Context, arg UpdateMessageRetrievedParams\) error](<#Queries.UpdateMessageRetrieved>)
  - [func \(q \*Queries\) WithTx\(tx \*sql.Tx\) \*Queries](<#Queries.WithTx>)
- [type QueuePlugin](<#QueuePlugin>)
  - [func \(\*QueuePlugin\) Init\(ctx context.Context, e eng.Engine\) bool](<#QueuePlugin.Init>)
- [type RetrieveMessageParams](<#RetrieveMessageParams>)
- [type UpdateMessageRetrievedParams](<#UpdateMessageRetrievedParams>)


<a name="CreateIdToKeyMappingParams"></a>
## type CreateIdToKeyMappingParams



```go
type CreateIdToKeyMappingParams struct {
    IDLow    sql.NullInt64
    IDHigh   sql.NullInt64
    QueueKey sql.NullInt64
}
```

<a name="CreateMessageParams"></a>
## type CreateMessageParams



```go
type CreateMessageParams struct {
    IDLow    sql.NullInt64
    IDHigh   sql.NullInt64
    QueueKey sql.NullInt64
    Sender   []byte
    Payload  []byte
}
```

<a name="DBTX"></a>
## type DBTX



```go
type DBTX interface {
    ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
    PrepareContext(context.Context, string) (*sql.Stmt, error)
    QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
    QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}
```

<a name="LocateRow"></a>
## type LocateRow



```go
type LocateRow struct {
    IDHigh sql.NullInt64
    IDLow  sql.NullInt64
}
```

<a name="MarkDoneParams"></a>
## type MarkDoneParams



```go
type MarkDoneParams struct {
    QueueKey sql.NullInt64
    IDLow    sql.NullInt64
    IDHigh   sql.NullInt64
}
```

<a name="ParigotTestMessage"></a>
## type ParigotTestMessage



```go
type ParigotTestMessage struct {
    IDLow         sql.NullInt64
    IDHigh        sql.NullInt64
    QueueKey      sql.NullInt64
    LastReceived  sql.NullString
    ReceivedCount sql.NullInt64
    OriginalSent  sql.NullString
    MarkedDone    sql.NullString
    Sender        []byte
    Payload       []byte
}
```

<a name="ParigotTestQueue"></a>
## type ParigotTestQueue



```go
type ParigotTestQueue struct {
    ID   int64
    Name string
}
```

<a name="ParigotTestQueueIDToKey"></a>
## type ParigotTestQueueIDToKey



```go
type ParigotTestQueueIDToKey struct {
    IDLow    sql.NullInt64
    IDHigh   sql.NullInt64
    QueueKey sql.NullInt64
}
```

<a name="Queries"></a>
## type Queries



```go
type Queries struct {
    // contains filtered or unexported fields
}
```

<a name="New"></a>
### func New

```go
func New(db DBTX) *Queries
```



<a name="Queries.CreateIdToKeyMapping"></a>
### func \(\*Queries\) CreateIdToKeyMapping

```go
func (q *Queries) CreateIdToKeyMapping(ctx context.Context, arg CreateIdToKeyMappingParams) (ParigotTestQueueIDToKey, error)
```



<a name="Queries.CreateMessage"></a>
### func \(\*Queries\) CreateMessage

```go
func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (ParigotTestMessage, error)
```



<a name="Queries.CreateQueue"></a>
### func \(\*Queries\) CreateQueue

```go
func (q *Queries) CreateQueue(ctx context.Context, name string) (ParigotTestQueue, error)
```



<a name="Queries.DeleteQueue"></a>
### func \(\*Queries\) DeleteQueue

```go
func (q *Queries) DeleteQueue(ctx context.Context, id int64) error
```



<a name="Queries.GetQueue"></a>
### func \(\*Queries\) GetQueue

```go
func (q *Queries) GetQueue(ctx context.Context, id int64) (ParigotTestQueue, error)
```



<a name="Queries.Length"></a>
### func \(\*Queries\) Length

```go
func (q *Queries) Length(ctx context.Context, queueKey sql.NullInt64) (int64, error)
```



<a name="Queries.Locate"></a>
### func \(\*Queries\) Locate

```go
func (q *Queries) Locate(ctx context.Context, name string) (LocateRow, error)
```



<a name="Queries.MarkDone"></a>
### func \(\*Queries\) MarkDone

```go
func (q *Queries) MarkDone(ctx context.Context, arg MarkDoneParams) error
```



<a name="Queries.RetrieveMessage"></a>
### func \(\*Queries\) RetrieveMessage

```go
func (q *Queries) RetrieveMessage(ctx context.Context, arg RetrieveMessageParams) ([]ParigotTestMessage, error)
```



<a name="Queries.TestNameExists"></a>
### func \(\*Queries\) TestNameExists

```go
func (q *Queries) TestNameExists(ctx context.Context, name string) (int64, error)
```



<a name="Queries.UpdateMessageRetrieved"></a>
### func \(\*Queries\) UpdateMessageRetrieved

```go
func (q *Queries) UpdateMessageRetrieved(ctx context.Context, arg UpdateMessageRetrievedParams) error
```



<a name="Queries.WithTx"></a>
### func \(\*Queries\) WithTx

```go
func (q *Queries) WithTx(tx *sql.Tx) *Queries
```



<a name="QueuePlugin"></a>
## type QueuePlugin



```go
type QueuePlugin struct{}
```

<a name="QueuePlugin.Init"></a>
### func \(\*QueuePlugin\) Init

```go
func (*QueuePlugin) Init(ctx context.Context, e eng.Engine) bool
```

This init functions points the host functions at the functions that are the ones to a short setup before calling the real implementation.

<a name="RetrieveMessageParams"></a>
## type RetrieveMessageParams



```go
type RetrieveMessageParams struct {
    IDHigh sql.NullInt64
    IDLow  sql.NullInt64
}
```

<a name="UpdateMessageRetrievedParams"></a>
## type UpdateMessageRetrievedParams



```go
type UpdateMessageRetrievedParams struct {
    QueueKey sql.NullInt64
    IDLow    sql.NullInt64
    IDHigh   sql.NullInt64
}
```

# syscall

```go
import "github.com/iansmith/parigot/api/plugin/syscall"
```

## Index

- [Variables](<#variables>)
- [type CallInfo](<#CallInfo>)
- [type CallMatcher](<#CallMatcher>)
- [type HostFinder](<#HostFinder>)
- [type Service](<#Service>)
- [type SyscallData](<#SyscallData>)
- [type SyscallPlugin](<#SyscallPlugin>)
  - [func \(\*SyscallPlugin\) Init\(ctx context.Context, e eng.Engine\) bool](<#SyscallPlugin.Init>)


## Variables

<a name="ParigotInitialize"></a>

```go
var ParigotInitialize apiplugin.ParigotInit = &SyscallPlugin{}
```

<a name="CallInfo"></a>
## type CallInfo

CallInfo is sent to the channels that represent service/method calls.

```go
type CallInfo struct {
    // contains filtered or unexported fields
}
```

<a name="CallMatcher"></a>
## type CallMatcher

CallMatcher is an internal data structure object that connects calls to Dispatch \(the call\) with the response which are created by ReturnValue requests.

```go
type CallMatcher interface {
    // Response is called when a return value is
    // being processed. Any value that
    // is returned is NOT from the execution but from
    // the Response call itself.  Be aware that the
    // Response call is likely to be from a different
    // host than the original Dispatch call.
    Response(cid id.CallId, a *anypb.Any, err int32) syscall.KernelErr
    // Dispatch creates the necessary entries to handle
    // a future call to Response.  The value returned is
    // related to the Dispatch itself, it is not related
    // to the execution of the call being registered.
    Dispatch(hid id.HostId, cid id.CallId) syscall.KernelErr
    // Ready returns a resolved call or nil if no Promises are
    // resolved for the given host.
    Ready(hid id.HostId) (*syscall.ResolvedCall, syscall.KernelErr)
}
```

<a name="HostFinder"></a>
## type HostFinder

HostFinder returns information about a host in the format used by the syscall struct. It is convention to use the fully qualified name of the service for the name.

```go
type HostFinder interface {
    // FindByName finds the correct host by the name field.
    // If the name cannot be found, it returns nil.
    FindByName(name string) *hostInfo
    // FindById finds the correct host by the id field.
    // If the id cannot be found it returns nil.
    FindById(id id.HostId) *hostInfo
    // AddHost is used to add a record to the set of hosts
    // that are know. This call will panic if either the
    // name or id is not set.
    AddHost(name string, hid id.HostId) syscall.KernelErr
}
```

<a name="Service"></a>
## type Service

Service is the logical representation of a service. This is used internally and is not intended for external use.

```go
type Service interface {
    Id() id.ServiceId
    // Name returns a human readable name of the service.
    Name() string
    // Package returns the package name (not the proto package name)
    // of the service.
    Package() string
    // Short returns a nice-to-read version of the service's id.
    Short() string
    // String returns the full id of the service.
    String() string
    // RunRequested returns true if the service has requested
    // to run, but its dependencies are not yet satisfied. Once
    // they are met, the service can start and the Started()
    // method will return true.
    RunRequested() bool
    // Started returns true if the service has started.
    Started() bool
    // Exported returns true if some service provider has said that
    // they implement this service.
    Exported() bool
    // Method returns all the pairs of MethodName and MethodId
    // for a service known to the SyscallData.  You provide the
    // service to this method to know which set of pairs you want.
    Method() []*syscall.MethodBinding
    // AddMethod is called by the syscall bind method to add a
    // given name/id pair to this service.
    AddMethod(string, id.MethodId)
    //Run is badly named. This really means "block until everything
    //I need is ready."
    Run(context.Context) syscall.KernelErr
}
```

<a name="SyscallData"></a>
## type SyscallData



```go
type SyscallData interface {
    //ServiceByName looks up a service and returns it based on the
    //values package_ and name.  If this returns nil, the service could
    //not be found.
    ServiceByName(ctx context.Context, package_, name string) Service
    //ServiceById looks up a service and returns it based on the
    //value sid.  If this returns nil, the service could
    //not be found.
    ServiceById(ctx context.Context, sid id.ServiceId) Service
    //ServiceByIdString looks up a service based on the printed representation
    //of the service id.  If the service cannot be found ServiceByIdString
    //returns nil.
    ServiceByIdString(ctx context.Context, str string) Service
    // SetService puts a service into SyscallData.  This should only be
    // called once for each package_ and name pair. It returns the
    // ServiceId for the service named, creating a new one if necessary.
    // The client flag should be set to true only when the requesting
    // party is a client.  All services should pass false here.  This
    // flag effectively means that the requester (package_,name) does not
    // to export their service to be ready to run.
    // If the bool result is false, then the pair already existed and
    // we made no changes to it.
    SetService(ctx context.Context, package_, name string, client bool) (Service, bool)
    // Export finds a service by the given sid and then marks that
    // service as being exported. This function returns nil if
    // there is no such service.
    Export(ctx context.Context, svc id.ServiceId) Service
    // Import introduces a dendency between the sourge and dest
    // services. Thus,  dest must be running before source can run.
    // This function returns a kernel error in two primary cases.
    // 1. one of the src or destination could not be found.  2. The
    // newly introduced edge would create a cycle.
    Import(ctx context.Context, src, dest id.ServiceId) syscall.KernelErr
    // Launch blocks the caller until all the prerequistes have been
    // launched.  It returns false if it returned because of
    // a timeout or the service id cannot be found, otherwise true.
    Launch(context.Context, id.ServiceId) syscall.KernelErr
    // PathExists returns true if there is a sequence of dependency
    // graph vertices that eventually leads from source to target.
    PathExists(ctx context.Context, source, target string) bool
}
```

<a name="SyscallPlugin"></a>
## type SyscallPlugin



```go
type SyscallPlugin struct {
}
```

<a name="SyscallPlugin.Init"></a>
### func \(\*SyscallPlugin\) Init

```go
func (*SyscallPlugin) Init(ctx context.Context, e eng.Engine) bool
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
