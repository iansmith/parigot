package main

import (
	"context"
	"log/slog"

	"github.com/iansmith/parigot/api/guest"
	syscallguest "github.com/iansmith/parigot/api/guest/syscall"
	"github.com/iansmith/parigot/api/shared/id"
	"github.com/iansmith/parigot/example/httpsimple/g/simple/v1"
	"github.com/iansmith/parigot/g/http/v1"
	"github.com/iansmith/parigot/g/httpconnector/v1"
	"github.com/iansmith/parigot/g/syscall/v1"
	lib "github.com/iansmith/parigot/lib/go"

	"github.com/iansmith/parigot/lib/go/future"

	_ "time/tzdata"
)

//
// The front door service that receives the initial request. It then forwards the
// received request to the simple service via parigot.
//

var timeoutInMillis = int32(50)
var logger *slog.Logger

type myService struct {
	simple simple.Client
}

var _ httpconnector.HttpConnector = &myService{}

func main() {

	// the implementation of the service (no state right now)
	impl := &myService{}

	// Init initiaizes a service and normally receives a list of functions
	// that indicate dependencies, but we don't have any here.
	binding, fut, ctx, sid :=
		httpconnector.Init([]lib.MustRequireFunc{simple.MustRequire}, impl)

	// create a logger
	logger = slog.New(guest.NewParigotHandler(sid))

	fut.Failure(func(err syscall.KernelErr) {
		logger.Error("failed to launch the frontdoor service: %s", syscall.KernelErr_name[int32(err)])
		lib.ExitSelf(ctx, 1, sid)
	})

	fut.Success(func(resp *syscall.LaunchResponse) {
		logger.Info("frontdoor launched successfully",
			slog.String("frontdoor host", syscallguest.CurrentHostId().Short()))
	})

	// does not return except when the world is broken
	err := httpconnector.Run(ctx, binding, simple.TimeoutInMillis, nil)

	logger.Error("we got an error that is not normal from ReadOneAndCallClient", "kernel error", syscall.KernelErr_name[int32(err)])

	lib.ExitSelf(ctx, 1, sid)
}

func (m *myService) Handle(ctx context.Context, req *httpconnector.HandleRequest) *httpconnector.FutureHandle {
	sid := id.UnmarshalServiceId(req.GetServiceId())
	mid := id.UnmarshalMethodId(req.GetMethodId())
	logger.Info("Reached handle", "method", req.GetHttpMethod(), "service", sid.Short(), "method", mid.Short(),
		"current host", syscallguest.CurrentHostId().Short())

	if req.GetHttpMethod() != "GET" {
		slog.Info("xxxx method is not get", "method", req.GetHttpMethod())
		fh := httpconnector.NewFutureHandle()
		result := &httpconnector.HandleResponse{
			HttpStatus:   401,
			HttpResponse: []byte("not permitted, you jerk"),
			Headers: map[string]string{
				"try": "GET",
			},
		}
		if e := fh.CompleteMethod(ctx, result, int32(httpconnector.HttpConnectorErr_NoError)); e != syscall.KernelErr_NoError {
			slog.Error("unable to complete Handle() method future", "kernel error", syscall.KernelErr_name[int32(e)])
			// not much we can do here, panic?
			return nil
		}
		return fh
	}

	httpClient, err := http.Locate(ctx, id.ServiceIdZeroValue())
	if err == syscall.KernelErr_NotFound {
		badfut := httpconnector.NewFutureHandle()
		badfut.Method.CompleteMethod(ctx, nil, httpconnector.HttpConnectorErr_NoReceiver)
		return badfut
	}
	if err != syscall.KernelErr_NoError {
		slog.Error("unable to locate an http receiver", "kernel error", syscall.KernelErr_name[int32(err)])
		return nil
	}

	futGet := httpClient.Get(ctx, &http.GetRequest{
		Request: &http.HttpRequest{
			Url:     "",
			Header:  map[string]string{},
			Body:    []byte{},
			Trailer: map[string]string{},
		},
	})
	futHandle := httpconnector.NewFutureHandle()
	futGet.Method.Success(func(resp *http.GetResponse) {
		slog.Info("received message from GET receiver", "size in bytes", resp.Response.GetContentLength())
		futHandle.Method.CompleteMethod(ctx, &httpconnector.HandleResponse{
			HttpStatus: resp.Response.StatusCode,
			Headers:    resp.Response.Header,
		}, httpconnector.HttpConnectorErr_NoError)
	})
	futGet.Method.Failure(func(err http.HttpErr) {
		slog.Info("error received from GET receiver", "name", http.HttpErr_name[int32(err)])
		futHandle.Method.CompleteMethod(ctx, nil, httpconnector.HttpConnectorErr_ReceiverFailed)
	})
	return futHandle
}

func (m *myService) Ready(ctx context.Context, sid id.ServiceId) *future.Base[bool] {
	m.simple = simple.MustLocate(ctx, sid)
	return future.NewBaseWithValue[bool](true)
}

// kernelSetup is a utility routine for doing some tasks that are needed,
// but normally generated by parigot at build time.  However, because we are
// using a reverse API we have to induce the structures we want inside the
// kernel.
func kernelSetup(ctx context.Context, sid id.ServiceId, impl httpconnector.HttpConnector) *lib.ServiceMethodMap {
	// synchronous: Export the name of the reverse interface
	_, kerr := lib.Export1(ctx, "httpconnector.v1", "httpconnector", sid)
	if kerr != syscall.KernelErr_NoError {
		logger.Error("unable to export the httpconnector interface")
		lib.ExitSelf(ctx, 1, sid)
	}

	// sync: bind the method we implement
	bindReq := &syscall.BindMethodRequest{}
	bindReq.HostId = syscallguest.CurrentHostId().Marshal()
	bindReq.ServiceId = sid.Marshal()
	bindReq.MethodName = "Handle"
	bindResp, err := syscallguest.BindMethod(ctx, bindReq)
	if err != syscall.KernelErr_NoError {
		logger.Error("unable to bind the httpconnector to Handle implementation")
		lib.ExitSelf(ctx, 1, sid)
	}
	mid := id.UnmarshalMethodId(bindResp.GetMethodId())
	smmap := lib.NewServiceMethodMap()

	// completer already prepared elsewhere
	smmap.AddServiceMethod(sid, mid, "HttpConnector", "Handle", httpconnector.GenerateHandleInvoker(impl))

	logger.Info("success binding method 'Handle'", "method", mid.Short(), "host", syscallguest.CurrentHostId())
	return smmap

}
